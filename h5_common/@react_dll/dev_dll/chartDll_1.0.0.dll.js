var chartDll =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/highcharts/highcharts.js":
/***/ (function(module, exports) {

eval("/*\n Highcharts JS v6.1.0 (2018-04-13)\n\n (c) 2009-2016 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (T, K) {\n  \"object\" === typeof module && module.exports ? module.exports = T.document ? K(T) : K : T.Highcharts = K(T);\n})(\"undefined\" !== typeof window ? window : this, function (T) {\n  var K = function () {\n    var a = \"undefined\" === typeof T ? window : T,\n        C = a.document,\n        F = a.navigator && a.navigator.userAgent || \"\",\n        D = C && C.createElementNS && !!C.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        r = /(edge|msie|trident)/i.test(F) && !a.opera,\n        g = -1 !== F.indexOf(\"Firefox\"),\n        e = -1 !== F.indexOf(\"Chrome\"),\n        t = g && 4 > parseInt(F.split(\"Firefox/\")[1], 10);return a.Highcharts ? a.Highcharts.error(16, !0) : { product: \"Highcharts\", version: \"6.1.0\", deg2rad: 2 * Math.PI / 360, doc: C, hasBidiBug: t, hasTouch: C && void 0 !== C.documentElement.ontouchstart, isMS: r, isWebKit: -1 !== F.indexOf(\"AppleWebKit\"), isFirefox: g, isChrome: e, isSafari: !e && -1 !== F.indexOf(\"Safari\"), isTouchDevice: /(Mobile|Android|Windows Phone)/.test(F), SVG_NS: \"http://www.w3.org/2000/svg\", chartCount: 0, seriesTypes: {}, symbolSizes: {}, svg: D, win: a, marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"], noop: function () {},\n      charts: [] };\n  }();(function (a) {\n    a.timers = [];var C = a.charts,\n        F = a.doc,\n        D = a.win;a.error = function (r, g) {\n      r = a.isNumber(r) ? \"Highcharts error #\" + r + \": www.highcharts.com/errors/\" + r : r;if (g) throw Error(r);D.console && console.log(r);\n    };a.Fx = function (a, g, e) {\n      this.options = g;this.elem = a;this.prop = e;\n    };a.Fx.prototype = { dSetter: function () {\n        var a = this.paths[0],\n            g = this.paths[1],\n            e = [],\n            t = this.now,\n            w = a.length,\n            l;if (1 === t) e = this.toD;else if (w === g.length && 1 > t) for (; w--;) l = parseFloat(a[w]), e[w] = isNaN(l) ? g[w] : t * parseFloat(g[w] - l) + l;else e = g;this.elem.attr(\"d\", e, null, !0);\n      }, update: function () {\n        var a = this.elem,\n            g = this.prop,\n            e = this.now,\n            t = this.options.step;if (this[g + \"Setter\"]) this[g + \"Setter\"]();else a.attr ? a.element && a.attr(g, e, null, !0) : a.style[g] = e + this.unit;t && t.call(a, e, this);\n      }, run: function (r, g, e) {\n        var t = this,\n            w = t.options,\n            l = function (a) {\n          return l.stopped ? !1 : t.step(a);\n        },\n            u = D.requestAnimationFrame || function (a) {\n          setTimeout(a, 13);\n        },\n            c = function () {\n          for (var d = 0; d < a.timers.length; d++) a.timers[d]() || a.timers.splice(d--, 1);a.timers.length && u(c);\n        };r !== g || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = r, this.end = g, this.unit = e, this.now = this.start, this.pos = 0, l.elem = this.elem, l.prop = this.prop, l() && 1 === a.timers.push(l) && u(c)) : (delete w.curAnim[this.prop], w.complete && 0 === a.keys(w.curAnim).length && w.complete.call(this.elem));\n      }, step: function (r) {\n        var g = +new Date(),\n            e,\n            t = this.options,\n            w = this.elem,\n            l = t.complete,\n            u = t.duration,\n            c = t.curAnim;w.attr && !w.element ? r = !1 : r || g >= u + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), e = c[this.prop] = !0, a.objectEach(c, function (a) {\n          !0 !== a && (e = !1);\n        }), e && l && l.call(w), r = !1) : (this.pos = t.easing((g - this.startTime) / u), this.now = this.start + (this.end - this.start) * this.pos, this.update(), r = !0);return r;\n      }, initPath: function (r, g, e) {\n        function t(a) {\n          var f, c;for (b = a.length; b--;) f = \"M\" === a[b] || \"L\" === a[b], c = /[a-zA-Z]/.test(a[b + 3]), f && c && a.splice(b + 1, 0, a[b + 1], a[b + 2], a[b + 1], a[b + 2]);\n        }function w(a, f) {\n          for (; a.length < p;) {\n            a[0] = f[p - a.length];var c = a.slice(0, x);[].splice.apply(a, [0, 0].concat(c));n && (c = a.slice(a.length - x), [].splice.apply(a, [a.length, 0].concat(c)), b--);\n          }a[0] = \"M\";\n        }function l(a, b) {\n          for (var c = (p - a.length) / x; 0 < c && c--;) f = a.slice().splice(a.length / z - x, x * z), f[0] = b[p - x - c * x], k && (f[x - 6] = f[x - 2], f[x - 5] = f[x - 1]), [].splice.apply(a, [a.length / z, 0].concat(f)), n && c--;\n        }g = g || \"\";var u,\n            c = r.startX,\n            d = r.endX,\n            k = -1 < g.indexOf(\"C\"),\n            x = k ? 7 : 3,\n            p,\n            f,\n            b;g = g.split(\" \");e = e.slice();var n = r.isArea,\n            z = n ? 2 : 1,\n            J;k && (t(g), t(e));if (c && d) {\n          for (b = 0; b < c.length; b++) if (c[b] === d[0]) {\n            u = b;break;\n          } else if (c[0] === d[d.length - c.length + b]) {\n            u = b;J = !0;break;\n          }void 0 === u && (g = []);\n        }g.length && a.isNumber(u) && (p = e.length + u * z * x, J ? (w(g, e), l(e, g)) : (w(e, g), l(g, e)));return [g, e];\n      } };a.Fx.prototype.fillSetter = a.Fx.prototype.strokeSetter = function () {\n      this.elem.attr(this.prop, a.color(this.start).tweenTo(a.color(this.end), this.pos), null, !0);\n    };a.merge = function () {\n      var r,\n          g = arguments,\n          e,\n          t = {},\n          w = function (e, u) {\n        \"object\" !== typeof e && (e = {});a.objectEach(u, function (c, d) {\n          !a.isObject(c, !0) || a.isClass(c) || a.isDOMElement(c) ? e[d] = u[d] : e[d] = w(e[d] || {}, c);\n        });return e;\n      };!0 === g[0] && (t = g[1], g = Array.prototype.slice.call(g, 2));e = g.length;for (r = 0; r < e; r++) t = w(t, g[r]);return t;\n    };a.pInt = function (a, g) {\n      return parseInt(a, g || 10);\n    };a.isString = function (a) {\n      return \"string\" === typeof a;\n    };a.isArray = function (a) {\n      a = Object.prototype.toString.call(a);return \"[object Array]\" === a || \"[object Array Iterator]\" === a;\n    };a.isObject = function (r, g) {\n      return !!r && \"object\" === typeof r && (!g || !a.isArray(r));\n    };a.isDOMElement = function (r) {\n      return a.isObject(r) && \"number\" === typeof r.nodeType;\n    };a.isClass = function (r) {\n      var g = r && r.constructor;return !(!a.isObject(r, !0) || a.isDOMElement(r) || !g || !g.name || \"Object\" === g.name);\n    };a.isNumber = function (a) {\n      return \"number\" === typeof a && !isNaN(a) && Infinity > a && -Infinity < a;\n    };a.erase = function (a, g) {\n      for (var e = a.length; e--;) if (a[e] === g) {\n        a.splice(e, 1);break;\n      }\n    };a.defined = function (a) {\n      return void 0 !== a && null !== a;\n    };a.attr = function (r, g, e) {\n      var t;a.isString(g) ? a.defined(e) ? r.setAttribute(g, e) : r && r.getAttribute && ((t = r.getAttribute(g)) || \"class\" !== g || (t = r.getAttribute(g + \"Name\"))) : a.defined(g) && a.isObject(g) && a.objectEach(g, function (a, e) {\n        r.setAttribute(e, a);\n      });return t;\n    };a.splat = function (r) {\n      return a.isArray(r) ? r : [r];\n    };a.syncTimeout = function (a, g, e) {\n      if (g) return setTimeout(a, g, e);a.call(0, e);\n    };a.clearTimeout = function (r) {\n      a.defined(r) && clearTimeout(r);\n    };a.extend = function (a, g) {\n      var e;a || (a = {});for (e in g) a[e] = g[e];return a;\n    };a.pick = function () {\n      var a = arguments,\n          g,\n          e,\n          t = a.length;for (g = 0; g < t; g++) if (e = a[g], void 0 !== e && null !== e) return e;\n    };a.css = function (r, g) {\n      a.isMS && !a.svg && g && void 0 !== g.opacity && (g.filter = \"alpha(opacity\\x3d\" + 100 * g.opacity + \")\");a.extend(r.style, g);\n    };a.createElement = function (r, g, e, t, w) {\n      r = F.createElement(r);var l = a.css;g && a.extend(r, g);w && l(r, { padding: 0, border: \"none\", margin: 0 });e && l(r, e);t && t.appendChild(r);return r;\n    };a.extendClass = function (r, g) {\n      var e = function () {};e.prototype = new r();a.extend(e.prototype, g);return e;\n    };a.pad = function (a, g, e) {\n      return Array((g || 2) + 1 - String(a).replace(\"-\", \"\").length).join(e || 0) + a;\n    };a.relativeLength = function (a, g, e) {\n      return (/%$/.test(a) ? g * parseFloat(a) / 100 + (e || 0) : parseFloat(a)\n      );\n    };a.wrap = function (a, g, e) {\n      var t = a[g];a[g] = function () {\n        var a = Array.prototype.slice.call(arguments),\n            l = arguments,\n            u = this;\n        u.proceed = function () {\n          t.apply(u, arguments.length ? arguments : l);\n        };a.unshift(t);a = e.apply(this, a);u.proceed = null;return a;\n      };\n    };a.formatSingle = function (r, g, e) {\n      var t = /\\.([0-9])/,\n          w = a.defaultOptions.lang;/f$/.test(r) ? (e = (e = r.match(t)) ? e[1] : -1, null !== g && (g = a.numberFormat(g, e, w.decimalPoint, -1 < r.indexOf(\",\") ? w.thousandsSep : \"\"))) : g = (e || a.time).dateFormat(r, g);return g;\n    };a.format = function (r, g, e) {\n      for (var t = \"{\", w = !1, l, u, c, d, k = [], x; r;) {\n        t = r.indexOf(t);if (-1 === t) break;l = r.slice(0, t);if (w) {\n          l = l.split(\":\");u = l.shift().split(\".\");\n          d = u.length;x = g;for (c = 0; c < d; c++) x && (x = x[u[c]]);l.length && (x = a.formatSingle(l.join(\":\"), x, e));k.push(x);\n        } else k.push(l);r = r.slice(t + 1);t = (w = !w) ? \"}\" : \"{\";\n      }k.push(r);return k.join(\"\");\n    };a.getMagnitude = function (a) {\n      return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));\n    };a.normalizeTickInterval = function (r, g, e, t, w) {\n      var l,\n          u = r;e = a.pick(e, 1);l = r / e;g || (g = w ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === t && (1 === e ? g = a.grep(g, function (a) {\n        return 0 === a % 1;\n      }) : .1 >= e && (g = [1 / e])));for (t = 0; t < g.length && !(u = g[t], w && u * e >= r || !w && l <= (g[t] + (g[t + 1] || g[t])) / 2); t++);return u = a.correctFloat(u * e, -Math.round(Math.log(.001) / Math.LN10));\n    };a.stableSort = function (a, g) {\n      var e = a.length,\n          t,\n          w;for (w = 0; w < e; w++) a[w].safeI = w;a.sort(function (a, e) {\n        t = g(a, e);return 0 === t ? a.safeI - e.safeI : t;\n      });for (w = 0; w < e; w++) delete a[w].safeI;\n    };a.arrayMin = function (a) {\n      for (var g = a.length, e = a[0]; g--;) a[g] < e && (e = a[g]);return e;\n    };a.arrayMax = function (a) {\n      for (var g = a.length, e = a[0]; g--;) a[g] > e && (e = a[g]);return e;\n    };a.destroyObjectProperties = function (r, g) {\n      a.objectEach(r, function (a, t) {\n        a && a !== g && a.destroy && a.destroy();delete r[t];\n      });\n    };a.discardElement = function (r) {\n      var g = a.garbageBin;g || (g = a.createElement(\"div\"));r && g.appendChild(r);g.innerHTML = \"\";\n    };a.correctFloat = function (a, g) {\n      return parseFloat(a.toPrecision(g || 14));\n    };a.setAnimation = function (r, g) {\n      g.renderer.globalAnimation = a.pick(r, g.options.chart.animation, !0);\n    };a.animObject = function (r) {\n      return a.isObject(r) ? a.merge(r) : { duration: r ? 500 : 0 };\n    };a.timeUnits = { millisecond: 1, second: 1E3, minute: 6E4, hour: 36E5, day: 864E5, week: 6048E5, month: 24192E5,\n      year: 314496E5 };a.numberFormat = function (r, g, e, t) {\n      r = +r || 0;g = +g;var w = a.defaultOptions.lang,\n          l = (r.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          u,\n          c,\n          d = r.toString().split(\"e\");-1 === g ? g = Math.min(l, 20) : a.isNumber(g) ? g && d[1] && 0 > d[1] && (u = g + +d[1], 0 <= u ? (d[0] = (+d[0]).toExponential(u).split(\"e\")[0], g = u) : (d[0] = d[0].split(\".\")[0] || 0, r = 20 > g ? (d[0] * Math.pow(10, d[1])).toFixed(g) : 0, d[1] = 0)) : g = 2;c = (Math.abs(d[1] ? d[0] : r) + Math.pow(10, -Math.max(g, l) - 1)).toFixed(g);l = String(a.pInt(c));u = 3 < l.length ? l.length % 3 : 0;e = a.pick(e, w.decimalPoint);t = a.pick(t, w.thousandsSep);r = (0 > r ? \"-\" : \"\") + (u ? l.substr(0, u) + t : \"\");r += l.substr(u).replace(/(\\d{3})(?=\\d)/g, \"$1\" + t);g && (r += e + c.slice(-g));d[1] && 0 !== +r && (r += \"e\" + d[1]);return r;\n    };Math.easeInOutSine = function (a) {\n      return -.5 * (Math.cos(Math.PI * a) - 1);\n    };a.getStyle = function (r, g, e) {\n      if (\"width\" === g) return Math.min(r.offsetWidth, r.scrollWidth) - a.getStyle(r, \"padding-left\") - a.getStyle(r, \"padding-right\");if (\"height\" === g) return Math.min(r.offsetHeight, r.scrollHeight) - a.getStyle(r, \"padding-top\") - a.getStyle(r, \"padding-bottom\");D.getComputedStyle || a.error(27, !0);if (r = D.getComputedStyle(r, void 0)) r = r.getPropertyValue(g), a.pick(e, \"opacity\" !== g) && (r = a.pInt(r));return r;\n    };a.inArray = function (r, g, e) {\n      return (a.indexOfPolyfill || Array.prototype.indexOf).call(g, r, e);\n    };a.grep = function (r, g) {\n      return (a.filterPolyfill || Array.prototype.filter).call(r, g);\n    };a.find = Array.prototype.find ? function (a, g) {\n      return a.find(g);\n    } : function (a, g) {\n      var e,\n          t = a.length;for (e = 0; e < t; e++) if (g(a[e], e)) return a[e];\n    };a.some = function (r, g, e) {\n      return (a.somePolyfill || Array.prototype.some).call(r, g, e);\n    };a.map = function (a, g) {\n      for (var e = [], t = 0, w = a.length; t < w; t++) e[t] = g.call(a[t], a[t], t, a);return e;\n    };a.keys = function (r) {\n      return (a.keysPolyfill || Object.keys).call(void 0, r);\n    };a.reduce = function (r, g, e) {\n      return (a.reducePolyfill || Array.prototype.reduce).call(r, g, e);\n    };a.offset = function (a) {\n      var g = F.documentElement;a = a.parentElement ? a.getBoundingClientRect() : { top: 0, left: 0 };return { top: a.top + (D.pageYOffset || g.scrollTop) - (g.clientTop || 0), left: a.left + (D.pageXOffset || g.scrollLeft) - (g.clientLeft || 0) };\n    };a.stop = function (r, g) {\n      for (var e = a.timers.length; e--;) a.timers[e].elem !== r || g && g !== a.timers[e].prop || (a.timers[e].stopped = !0);\n    };a.each = function (r, g, e) {\n      return (a.forEachPolyfill || Array.prototype.forEach).call(r, g, e);\n    };a.objectEach = function (a, g, e) {\n      for (var t in a) a.hasOwnProperty(t) && g.call(e || a[t], a[t], t, a);\n    };a.addEvent = function (r, g, e) {\n      var t,\n          w = r.addEventListener || a.addEventListenerPolyfill;t = \"function\" === typeof r && r.prototype ? r.prototype.protoEvents = r.prototype.protoEvents || {} : r.hcEvents = r.hcEvents || {};w && w.call(r, g, e, !1);t[g] || (t[g] = []);t[g].push(e);return function () {\n        a.removeEvent(r, g, e);\n      };\n    };a.removeEvent = function (r, g, e) {\n      function t(c, d) {\n        var k = r.removeEventListener || a.removeEventListenerPolyfill;k && k.call(r, c, d, !1);\n      }function w(c) {\n        var d, k;r.nodeName && (g ? (d = {}, d[g] = !0) : d = c, a.objectEach(d, function (a, d) {\n          if (c[d]) for (k = c[d].length; k--;) t(d, c[d][k]);\n        }));\n      }var l, u;a.each([\"protoEvents\", \"hcEvents\"], function (c) {\n        var d = r[c];d && (g ? (l = d[g] || [], e ? (u = a.inArray(e, l), -1 < u && (l.splice(u, 1), d[g] = l), t(g, e)) : (w(d), d[g] = [])) : (w(d), r[c] = {}));\n      });\n    };a.fireEvent = function (r, g, e, t) {\n      var w, l, u, c, d;e = e || {};F.createEvent && (r.dispatchEvent || r.fireEvent) ? (w = F.createEvent(\"Events\"), w.initEvent(g, !0, !0), a.extend(w, e), r.dispatchEvent ? r.dispatchEvent(w) : r.fireEvent(g, w)) : a.each([\"protoEvents\", \"hcEvents\"], function (k) {\n        if (r[k]) for (l = r[k][g] || [], u = l.length, e.target || a.extend(e, { preventDefault: function () {\n            e.defaultPrevented = !0;\n          }, target: r, type: g }), c = 0; c < u; c++) (d = l[c]) && !1 === d.call(r, e) && e.preventDefault();\n      });t && !e.defaultPrevented && t.call(r, e);\n    };a.animate = function (r, g, e) {\n      var t,\n          w = \"\",\n          l,\n          u,\n          c;a.isObject(e) || (c = arguments, e = { duration: c[2], easing: c[3], complete: c[4] });a.isNumber(e.duration) || (e.duration = 400);e.easing = \"function\" === typeof e.easing ? e.easing : Math[e.easing] || Math.easeInOutSine;e.curAnim = a.merge(g);a.objectEach(g, function (c, k) {\n        a.stop(r, k);u = new a.Fx(r, e, k);l = null;\"d\" === k ? (u.paths = u.initPath(r, r.d, g.d), u.toD = g.d, t = 0, l = 1) : r.attr ? t = r.attr(k) : (t = parseFloat(a.getStyle(r, k)) || 0, \"opacity\" !== k && (w = \"px\"));l || (l = c);l && l.match && l.match(\"px\") && (l = l.replace(/px/g, \"\"));u.run(t, l, w);\n      });\n    };a.seriesType = function (r, g, e, t, w) {\n      var l = a.getOptions(),\n          u = a.seriesTypes;l.plotOptions[r] = a.merge(l.plotOptions[g], e);u[r] = a.extendClass(u[g] || function () {}, t);u[r].prototype.type = r;w && (u[r].prototype.pointClass = a.extendClass(a.Point, w));return u[r];\n    };a.uniqueKey = function () {\n      var a = Math.random().toString(36).substring(2, 9),\n          g = 0;return function () {\n        return \"highcharts-\" + a + \"-\" + g++;\n      };\n    }();D.jQuery && (D.jQuery.fn.highcharts = function () {\n      var r = [].slice.call(arguments);if (this[0]) return r[0] ? (new a[a.isString(r[0]) ? r.shift() : \"Chart\"](this[0], r[0], r[1]), this) : C[a.attr(this[0], \"data-highcharts-chart\")];\n    });\n  })(K);(function (a) {\n    var C = a.each,\n        F = a.isNumber,\n        D = a.map,\n        r = a.merge,\n        g = a.pInt;a.Color = function (e) {\n      if (!(this instanceof a.Color)) return new a.Color(e);this.init(e);\n    };a.Color.prototype = { parsers: [{ regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/, parse: function (a) {\n          return [g(a[1]), g(a[2]), g(a[3]), parseFloat(a[4], 10)];\n        } }, { regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function (a) {\n          return [g(a[1]), g(a[2]), g(a[3]), 1];\n        } }], names: { none: \"rgba(255,255,255,0)\", white: \"#ffffff\", black: \"#000000\" }, init: function (e) {\n        var g, w, l, u;if ((this.input = e = this.names[e && e.toLowerCase ? e.toLowerCase() : \"\"] || e) && e.stops) this.stops = D(e.stops, function (c) {\n          return new a.Color(c[1]);\n        });else if (e && e.charAt && \"#\" === e.charAt() && (g = e.length, e = parseInt(e.substr(1), 16), 7 === g ? w = [(e & 16711680) >> 16, (e & 65280) >> 8, e & 255, 1] : 4 === g && (w = [(e & 3840) >> 4 | (e & 3840) >> 8, (e & 240) >> 4 | e & 240, (e & 15) << 4 | e & 15, 1])), !w) for (l = this.parsers.length; l-- && !w;) u = this.parsers[l], (g = u.regex.exec(e)) && (w = u.parse(g));this.rgba = w || [];\n      }, get: function (a) {\n        var e = this.input,\n            g = this.rgba,\n            l;this.stops ? (l = r(e), l.stops = [].concat(l.stops), C(this.stops, function (e, c) {\n          l.stops[c] = [l.stops[c][0], e.get(a)];\n        })) : l = g && F(g[0]) ? \"rgb\" === a || !a && 1 === g[3] ? \"rgb(\" + g[0] + \",\" + g[1] + \",\" + g[2] + \")\" : \"a\" === a ? g[3] : \"rgba(\" + g.join(\",\") + \")\" : e;return l;\n      }, brighten: function (a) {\n        var e,\n            w = this.rgba;if (this.stops) C(this.stops, function (e) {\n          e.brighten(a);\n        });else if (F(a) && 0 !== a) for (e = 0; 3 > e; e++) w[e] += g(255 * a), 0 > w[e] && (w[e] = 0), 255 < w[e] && (w[e] = 255);return this;\n      }, setOpacity: function (a) {\n        this.rgba[3] = a;return this;\n      }, tweenTo: function (a, g) {\n        var e = this.rgba,\n            l = a.rgba;l.length && e && e.length ? (a = 1 !== l[3] || 1 !== e[3], g = (a ? \"rgba(\" : \"rgb(\") + Math.round(l[0] + (e[0] - l[0]) * (1 - g)) + \",\" + Math.round(l[1] + (e[1] - l[1]) * (1 - g)) + \",\" + Math.round(l[2] + (e[2] - l[2]) * (1 - g)) + (a ? \",\" + (l[3] + (e[3] - l[3]) * (1 - g)) : \"\") + \")\") : g = a.input || \"none\";return g;\n      } };a.color = function (e) {\n      return new a.Color(e);\n    };\n  })(K);(function (a) {\n    var C,\n        F,\n        D = a.addEvent,\n        r = a.animate,\n        g = a.attr,\n        e = a.charts,\n        t = a.color,\n        w = a.css,\n        l = a.createElement,\n        u = a.defined,\n        c = a.deg2rad,\n        d = a.destroyObjectProperties,\n        k = a.doc,\n        x = a.each,\n        p = a.extend,\n        f = a.erase,\n        b = a.grep,\n        n = a.hasTouch,\n        z = a.inArray,\n        J = a.isArray,\n        q = a.isFirefox,\n        L = a.isMS,\n        B = a.isObject,\n        H = a.isString,\n        m = a.isWebKit,\n        E = a.merge,\n        A = a.noop,\n        M = a.objectEach,\n        G = a.pick,\n        h = a.pInt,\n        v = a.removeEvent,\n        Q = a.stop,\n        P = a.svg,\n        I = a.SVG_NS,\n        O = a.symbolSizes,\n        N = a.win;C = a.SVGElement = function () {\n      return this;\n    };p(C.prototype, { opacity: 1, SVG_NS: I, textProps: \"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline\".split(\" \"),\n      init: function (a, h) {\n        this.element = \"span\" === h ? l(h) : k.createElementNS(this.SVG_NS, h);this.renderer = a;\n      }, animate: function (y, h, b) {\n        h = a.animObject(G(h, this.renderer.globalAnimation, !0));0 !== h.duration ? (b && (h.complete = b), r(this, y, h)) : (this.attr(y, null, b), h.step && h.step.call(this));return this;\n      }, complexColor: function (y, h, b) {\n        var f = this.renderer,\n            v,\n            c,\n            d,\n            m,\n            I,\n            p,\n            A,\n            n,\n            k,\n            R,\n            q,\n            z = [],\n            P;a.fireEvent(this.renderer, \"complexColor\", { args: arguments }, function () {\n          y.radialGradient ? c = \"radialGradient\" : y.linearGradient && (c = \"linearGradient\");\n          c && (d = y[c], I = f.gradients, A = y.stops, R = b.radialReference, J(d) && (y[c] = d = { x1: d[0], y1: d[1], x2: d[2], y2: d[3], gradientUnits: \"userSpaceOnUse\" }), \"radialGradient\" === c && R && !u(d.gradientUnits) && (m = d, d = E(d, f.getRadialAttr(R, m), { gradientUnits: \"userSpaceOnUse\" })), M(d, function (a, y) {\n            \"id\" !== y && z.push(y, a);\n          }), M(A, function (a) {\n            z.push(a);\n          }), z = z.join(\",\"), I[z] ? q = I[z].attr(\"id\") : (d.id = q = a.uniqueKey(), I[z] = p = f.createElement(c).attr(d).add(f.defs), p.radAttr = m, p.stops = [], x(A, function (y) {\n            0 === y[1].indexOf(\"rgba\") ? (v = a.color(y[1]), n = v.get(\"rgb\"), k = v.get(\"a\")) : (n = y[1], k = 1);y = f.createElement(\"stop\").attr({ offset: y[0], \"stop-color\": n, \"stop-opacity\": k }).add(p);p.stops.push(y);\n          })), P = \"url(\" + f.url + \"#\" + q + \")\", b.setAttribute(h, P), b.gradient = z, y.toString = function () {\n            return P;\n          });\n        });\n      }, applyTextOutline: function (y) {\n        var h = this.element,\n            b,\n            v,\n            c,\n            d,\n            m;-1 !== y.indexOf(\"contrast\") && (y = y.replace(/contrast/g, this.renderer.getContrast(h.style.fill)));y = y.split(\" \");v = y[y.length - 1];if ((c = y[0]) && \"none\" !== c && a.svg) {\n          this.fakeTS = !0;y = [].slice.call(h.getElementsByTagName(\"tspan\"));\n          this.ySetter = this.xSetter;c = c.replace(/(^[\\d\\.]+)(.*?)$/g, function (a, y, h) {\n            return 2 * y + h;\n          });for (m = y.length; m--;) b = y[m], \"highcharts-text-outline\" === b.getAttribute(\"class\") && f(y, h.removeChild(b));d = h.firstChild;x(y, function (a, y) {\n            0 === y && (a.setAttribute(\"x\", h.getAttribute(\"x\")), y = h.getAttribute(\"y\"), a.setAttribute(\"y\", y || 0), null === y && h.setAttribute(\"y\", 0));a = a.cloneNode(1);g(a, { \"class\": \"highcharts-text-outline\", fill: v, stroke: v, \"stroke-width\": c, \"stroke-linejoin\": \"round\" });h.insertBefore(a, d);\n          });\n        }\n      }, attr: function (a, h, b, c) {\n        var y,\n            f = this.element,\n            v,\n            d = this,\n            m,\n            I;\"string\" === typeof a && void 0 !== h && (y = a, a = {}, a[y] = h);\"string\" === typeof a ? d = (this[a + \"Getter\"] || this._defaultGetter).call(this, a, f) : (M(a, function (y, h) {\n          m = !1;c || Q(this, h);this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(h) && (v || (this.symbolAttr(a), v = !0), m = !0);!this.rotation || \"x\" !== h && \"y\" !== h || (this.doTransform = !0);m || (I = this[h + \"Setter\"] || this._defaultSetter, I.call(this, y, h, f), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(h) && this.updateShadows(h, y, I));\n        }, this), this.afterSetters());b && b.call(this);return d;\n      }, afterSetters: function () {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      }, updateShadows: function (a, h, b) {\n        for (var y = this.shadows, c = y.length; c--;) b.call(y[c], \"height\" === a ? Math.max(h - (y[c].cutHeight || 0), 0) : \"d\" === a ? this.d : h, a, y[c]);\n      }, addClass: function (a, h) {\n        var y = this.attr(\"class\") || \"\";-1 === y.indexOf(a) && (h || (a = (y + (y ? \" \" : \"\") + a).replace(\"  \", \" \")), this.attr(\"class\", a));return this;\n      }, hasClass: function (a) {\n        return -1 !== z(a, (this.attr(\"class\") || \"\").split(\" \"));\n      }, removeClass: function (a) {\n        return this.attr(\"class\", (this.attr(\"class\") || \"\").replace(a, \"\"));\n      }, symbolAttr: function (a) {\n        var y = this;x(\"x y r start end width height innerR anchorX anchorY\".split(\" \"), function (h) {\n          y[h] = G(a[h], y[h]);\n        });y.attr({ d: y.renderer.symbols[y.symbolName](y.x, y.y, y.width, y.height, y) });\n      }, clip: function (a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      }, crisp: function (a, h) {\n        var y;h = h || a.strokeWidth || 0;y = Math.round(h) % 2 / 2;\n        a.x = Math.floor(a.x || this.x || 0) + y;a.y = Math.floor(a.y || this.y || 0) + y;a.width = Math.floor((a.width || this.width || 0) - 2 * y);a.height = Math.floor((a.height || this.height || 0) - 2 * y);u(a.strokeWidth) && (a.strokeWidth = h);return a;\n      }, css: function (a) {\n        var y = this.styles,\n            b = {},\n            c = this.element,\n            f,\n            v = \"\",\n            d,\n            m = !y,\n            I = [\"textOutline\", \"textOverflow\", \"width\"];a && a.color && (a.fill = a.color);y && M(a, function (a, h) {\n          a !== y[h] && (b[h] = a, m = !0);\n        });m && (y && (a = p(y, b)), f = this.textWidth = a && a.width && \"auto\" !== a.width && \"text\" === c.nodeName.toLowerCase() && h(a.width), this.styles = a, f && !P && this.renderer.forExport && delete a.width, c.namespaceURI === this.SVG_NS ? (d = function (a, y) {\n          return \"-\" + y.toLowerCase();\n        }, M(a, function (a, y) {\n          -1 === z(y, I) && (v += y.replace(/([A-Z])/g, d) + \":\" + a + \";\");\n        }), v && g(c, \"style\", v)) : w(c, a), this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline)));return this;\n      }, strokeWidth: function () {\n        return this[\"stroke-width\"] || 0;\n      }, on: function (a, h) {\n        var y = this,\n            b = y.element;n && \"click\" === a ? (b.ontouchstart = function (a) {\n          y.touchEventFired = Date.now();a.preventDefault();h.call(b, a);\n        }, b.onclick = function (a) {\n          (-1 === N.navigator.userAgent.indexOf(\"Android\") || 1100 < Date.now() - (y.touchEventFired || 0)) && h.call(b, a);\n        }) : b[\"on\" + a] = h;return this;\n      }, setRadialReference: function (a) {\n        var y = this.renderer.gradients[this.element.gradient];this.element.radialReference = a;y && y.radAttr && y.animate(this.renderer.getRadialAttr(a, y.radAttr));return this;\n      }, translate: function (a, h) {\n        return this.attr({ translateX: a, translateY: h });\n      }, invert: function (a) {\n        this.inverted = a;this.updateTransform();return this;\n      }, updateTransform: function () {\n        var a = this.translateX || 0,\n            h = this.translateY || 0,\n            b = this.scaleX,\n            c = this.scaleY,\n            v = this.inverted,\n            f = this.rotation,\n            d = this.matrix,\n            m = this.element;v && (a += this.width, h += this.height);a = [\"translate(\" + a + \",\" + h + \")\"];u(d) && a.push(\"matrix(\" + d.join(\",\") + \")\");v ? a.push(\"rotate(90) scale(-1,1)\") : f && a.push(\"rotate(\" + f + \" \" + G(this.rotationOriginX, m.getAttribute(\"x\"), 0) + \" \" + G(this.rotationOriginY, m.getAttribute(\"y\") || 0) + \")\");(u(b) || u(c)) && a.push(\"scale(\" + G(b, 1) + \" \" + G(c, 1) + \")\");a.length && m.setAttribute(\"transform\", a.join(\" \"));\n      }, toFront: function () {\n        var a = this.element;a.parentNode.appendChild(a);return this;\n      }, align: function (a, h, b) {\n        var y,\n            c,\n            v,\n            d,\n            m = {};c = this.renderer;v = c.alignedObjects;var I, p;if (a) {\n          if (this.alignOptions = a, this.alignByTranslate = h, !b || H(b)) this.alignTo = y = b || \"renderer\", f(v, this), v.push(this), b = null;\n        } else a = this.alignOptions, h = this.alignByTranslate, y = this.alignTo;b = G(b, c[y], c);y = a.align;c = a.verticalAlign;v = (b.x || 0) + (a.x || 0);d = (b.y || 0) + (a.y || 0);\"right\" === y ? I = 1 : \"center\" === y && (I = 2);I && (v += (b.width - (a.width || 0)) / I);m[h ? \"translateX\" : \"x\"] = Math.round(v);\"bottom\" === c ? p = 1 : \"middle\" === c && (p = 2);p && (d += (b.height - (a.height || 0)) / p);m[h ? \"translateY\" : \"y\"] = Math.round(d);this[this.placed ? \"animate\" : \"attr\"](m);this.placed = !0;this.alignAttr = m;return this;\n      }, getBBox: function (a, h) {\n        var y,\n            b = this.renderer,\n            v,\n            f = this.element,\n            d = this.styles,\n            m,\n            I = this.textStr,\n            A,\n            n = b.cache,\n            k = b.cacheKeys,\n            q;h = G(h, this.rotation);v = h * c;m = d && d.fontSize;u(I) && (q = I.toString(), -1 === q.indexOf(\"\\x3c\") && (q = q.replace(/[0-9]/g, \"0\")), q += [\"\", h || 0, m, this.textWidth, d && d.textOverflow].join());q && !a && (y = n[q]);if (!y) {\n          if (f.namespaceURI === this.SVG_NS || b.forExport) {\n            try {\n              (A = this.fakeTS && function (a) {\n                x(f.querySelectorAll(\".highcharts-text-outline\"), function (y) {\n                  y.style.display = a;\n                });\n              }) && A(\"none\"), y = f.getBBox ? p({}, f.getBBox()) : { width: f.offsetWidth, height: f.offsetHeight }, A && A(\"\");\n            } catch (W) {}if (!y || 0 > y.width) y = { width: 0, height: 0 };\n          } else y = this.htmlGetBBox();b.isSVG && (a = y.width, b = y.height, d && \"11px\" === d.fontSize && 17 === Math.round(b) && (y.height = b = 14), h && (y.width = Math.abs(b * Math.sin(v)) + Math.abs(a * Math.cos(v)), y.height = Math.abs(b * Math.cos(v)) + Math.abs(a * Math.sin(v))));if (q && 0 < y.height) {\n            for (; 250 < k.length;) delete n[k.shift()];n[q] || k.push(q);n[q] = y;\n          }\n        }return y;\n      }, show: function (a) {\n        return this.attr({ visibility: a ? \"inherit\" : \"visible\" });\n      }, hide: function () {\n        return this.attr({ visibility: \"hidden\" });\n      }, fadeOut: function (a) {\n        var y = this;y.animate({ opacity: 0 }, { duration: a || 150, complete: function () {\n            y.attr({ y: -9999 });\n          } });\n      }, add: function (a) {\n        var y = this.renderer,\n            h = this.element,\n            b;a && (this.parentGroup = a);this.parentInverted = a && a.inverted;void 0 !== this.textStr && y.buildText(this);this.added = !0;if (!a || a.handleZ || this.zIndex) b = this.zIndexSetter();b || (a ? a.element : y.box).appendChild(h);if (this.onAdd) this.onAdd();return this;\n      }, safeRemoveChild: function (a) {\n        var y = a.parentNode;y && y.removeChild(a);\n      }, destroy: function () {\n        var a = this,\n            h = a.element || {},\n            b = a.renderer.isSVG && \"SPAN\" === h.nodeName && a.parentGroup,\n            c = h.ownerSVGElement,\n            v = a.clipPath;h.onclick = h.onmouseout = h.onmouseover = h.onmousemove = h.point = null;Q(a);v && c && (x(c.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (a) {\n          var h = a.getAttribute(\"clip-path\"),\n              y = v.element.id;(-1 < h.indexOf(\"(#\" + y + \")\") || -1 < h.indexOf('(\"#' + y + '\")')) && a.removeAttribute(\"clip-path\");\n        }), a.clipPath = v.destroy());if (a.stops) {\n          for (c = 0; c < a.stops.length; c++) a.stops[c] = a.stops[c].destroy();a.stops = null;\n        }a.safeRemoveChild(h);for (a.destroyShadows(); b && b.div && 0 === b.div.childNodes.length;) h = b.parentGroup, a.safeRemoveChild(b.div), delete b.div, b = h;a.alignTo && f(a.renderer.alignedObjects, a);M(a, function (h, y) {\n          delete a[y];\n        });return null;\n      }, shadow: function (a, h, b) {\n        var y = [],\n            c,\n            v,\n            f = this.element,\n            d,\n            m,\n            I,\n            p;if (!a) this.destroyShadows();else if (!this.shadows) {\n          m = G(a.width, 3);I = (a.opacity || .15) / m;p = this.parentInverted ? \"(-1,-1)\" : \"(\" + G(a.offsetX, 1) + \", \" + G(a.offsetY, 1) + \")\";for (c = 1; c <= m; c++) v = f.cloneNode(0), d = 2 * m + 1 - 2 * c, g(v, { isShadow: \"true\", stroke: a.color || \"#000000\", \"stroke-opacity\": I * c, \"stroke-width\": d, transform: \"translate\" + p, fill: \"none\" }), b && (g(v, \"height\", Math.max(g(v, \"height\") - d, 0)), v.cutHeight = d), h ? h.element.appendChild(v) : f.parentNode && f.parentNode.insertBefore(v, f), y.push(v);this.shadows = y;\n        }return this;\n      }, destroyShadows: function () {\n        x(this.shadows || [], function (a) {\n          this.safeRemoveChild(a);\n        }, this);this.shadows = void 0;\n      }, xGetter: function (a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));return this._defaultGetter(a);\n      }, _defaultGetter: function (a) {\n        a = G(this[a + \"Value\"], this[a], this.element ? this.element.getAttribute(a) : null, 0);/^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));return a;\n      }, dSetter: function (a, h, b) {\n        a && a.join && (a = a.join(\" \"));/(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");this[h] !== a && (b.setAttribute(h, a), this[h] = a);\n      }, dashstyleSetter: function (a) {\n        var b,\n            y = this[\"stroke-width\"];\"inherit\" === y && (y = 1);if (a = a && a.toLowerCase()) {\n          a = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");for (b = a.length; b--;) a[b] = h(a[b]) * y;a = a.join(\",\").replace(/NaN/g, \"none\");this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      }, alignSetter: function (a) {\n        this.alignValue = a;this.element.setAttribute(\"text-anchor\", { left: \"start\", center: \"middle\", right: \"end\" }[a]);\n      }, opacitySetter: function (a, h, b) {\n        this[h] = a;b.setAttribute(h, a);\n      }, titleSetter: function (a) {\n        var h = this.element.getElementsByTagName(\"title\")[0];h || (h = k.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(h));h.firstChild && h.removeChild(h.firstChild);h.appendChild(k.createTextNode(String(G(a), \"\").replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"\\x3c\").replace(/&gt;/g, \"\\x3e\")));\n      }, textSetter: function (a) {\n        a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this));\n      }, fillSetter: function (a, h, b) {\n        \"string\" === typeof a ? b.setAttribute(h, a) : a && this.complexColor(a, h, b);\n      }, visibilitySetter: function (a, h, b) {\n        \"inherit\" === a ? b.removeAttribute(h) : this[h] !== a && b.setAttribute(h, a);this[h] = a;\n      }, zIndexSetter: function (a, b) {\n        var c = this.renderer,\n            v = this.parentGroup,\n            y = (v || c).element || c.box,\n            f,\n            d = this.element,\n            m,\n            I,\n            c = y === c.box;\n        f = this.added;var p;u(a) && (d.zIndex = a, a = +a, this[b] === a && (f = !1), this[b] = a);if (f) {\n          (a = this.zIndex) && v && (v.handleZ = !0);b = y.childNodes;for (p = b.length - 1; 0 <= p && !m; p--) if (v = b[p], f = v.zIndex, I = !u(f), v !== d) if (0 > a && I && !c && !p) y.insertBefore(d, b[p]), m = !0;else if (h(f) <= a || I && (!u(a) || 0 <= a)) y.insertBefore(d, b[p + 1] || null), m = !0;m || (y.insertBefore(d, b[c ? 3 : 0] || null), m = !0);\n        }return m;\n      }, _defaultSetter: function (a, h, b) {\n        b.setAttribute(h, a);\n      } });C.prototype.yGetter = C.prototype.xGetter;C.prototype.translateXSetter = C.prototype.translateYSetter = C.prototype.rotationSetter = C.prototype.verticalAlignSetter = C.prototype.rotationOriginXSetter = C.prototype.rotationOriginYSetter = C.prototype.scaleXSetter = C.prototype.scaleYSetter = C.prototype.matrixSetter = function (a, h) {\n      this[h] = a;this.doTransform = !0;\n    };C.prototype[\"stroke-widthSetter\"] = C.prototype.strokeSetter = function (a, h, b) {\n      this[h] = a;this.stroke && this[\"stroke-width\"] ? (C.prototype.fillSetter.call(this, this.stroke, \"stroke\", b), b.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === h && 0 === a && this.hasStroke && (b.removeAttribute(\"stroke\"), this.hasStroke = !1);\n    };F = a.SVGRenderer = function () {\n      this.init.apply(this, arguments);\n    };p(F.prototype, { Element: C, SVG_NS: I, init: function (a, h, b, c, v, f) {\n        var y;c = this.createElement(\"svg\").attr({ version: \"1.1\", \"class\": \"highcharts-root\" }).css(this.getStyle(c));y = c.element;a.appendChild(y);g(a, \"dir\", \"ltr\");-1 === a.innerHTML.indexOf(\"xmlns\") && g(y, \"xmlns\", this.SVG_NS);this.isSVG = !0;this.box = y;this.boxWrapper = c;this.alignedObjects = [];this.url = (q || m) && k.getElementsByTagName(\"base\").length ? N.location.href.replace(/#.*?$/, \"\").replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";this.createElement(\"desc\").add().element.appendChild(k.createTextNode(\"Created with Highcharts 6.1.0\"));this.defs = this.createElement(\"defs\").add();this.allowHTML = f;this.forExport = v;this.gradients = {};this.cache = {};this.cacheKeys = [];this.imgCount = 0;this.setSize(h, b, !1);var d;q && a.getBoundingClientRect && (h = function () {\n          w(a, { left: 0, top: 0 });d = a.getBoundingClientRect();w(a, { left: Math.ceil(d.left) - d.left + \"px\", top: Math.ceil(d.top) - d.top + \"px\" });\n        }, h(), this.unSubPixelFix = D(N, \"resize\", h));\n      }, getStyle: function (a) {\n        return this.style = p({ fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif', fontSize: \"12px\" }, a);\n      }, setStyle: function (a) {\n        this.boxWrapper.css(this.getStyle(a));\n      }, isHidden: function () {\n        return !this.boxWrapper.getBBox().width;\n      }, destroy: function () {\n        var a = this.defs;this.box = null;this.boxWrapper = this.boxWrapper.destroy();d(this.gradients || {});this.gradients = null;a && (this.defs = a.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();return this.alignedObjects = null;\n      }, createElement: function (a) {\n        var h = new this.Element();h.init(this, a);return h;\n      }, draw: A, getRadialAttr: function (a, h) {\n        return { cx: a[0] - a[2] / 2 + h.cx * a[2], cy: a[1] - a[2] / 2 + h.cy * a[2], r: h.r * a[2] };\n      }, getSpanWidth: function (a) {\n        return a.getBBox(!0).width;\n      }, applyEllipsis: function (a, h, b, c) {\n        var v = a.rotation,\n            f = b,\n            d,\n            y = 0,\n            m = b.length,\n            I = function (a) {\n          h.removeChild(h.firstChild);a && h.appendChild(k.createTextNode(a));\n        },\n            p;a.rotation = 0;f = this.getSpanWidth(a, h);if (p = f > c) {\n          for (; y <= m;) d = Math.ceil((y + m) / 2), f = b.substring(0, d) + \"\\u2026\", I(f), f = this.getSpanWidth(a, h), y === m ? y = m + 1 : f > c ? m = d - 1 : y = d;0 === m && I(\"\");\n        }a.rotation = v;return p;\n      }, escapes: { \"\\x26\": \"\\x26amp;\", \"\\x3c\": \"\\x26lt;\", \"\\x3e\": \"\\x26gt;\", \"'\": \"\\x26#39;\", '\"': \"\\x26quot;\" }, buildText: function (a) {\n        var c = a.element,\n            v = this,\n            f = v.forExport,\n            d = G(a.textStr, \"\").toString(),\n            y = -1 !== d.indexOf(\"\\x3c\"),\n            m = c.childNodes,\n            p,\n            A = g(c, \"x\"),\n            n = a.styles,\n            q = a.textWidth,\n            E = n && n.lineHeight,\n            e = n && n.textOutline,\n            B = n && \"ellipsis\" === n.textOverflow,\n            Q = n && \"nowrap\" === n.whiteSpace,\n            u = n && n.fontSize,\n            l,\n            O,\n            H = m.length,\n            n = q && !a.added && this.box,\n            J = function (a) {\n          var b;b = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : u || v.style.fontSize || 12;return E ? h(E) : v.fontMetrics(b, a.getAttribute(\"style\") ? a : c).h;\n        },\n            N = function (a, h) {\n          M(v.escapes, function (b, c) {\n            h && -1 !== z(b, h) || (a = a.toString().replace(new RegExp(b, \"g\"), c));\n          });return a;\n        },\n            t = function (a, h) {\n          var b;b = a.indexOf(\"\\x3c\");a = a.substring(b, a.indexOf(\"\\x3e\") - b);b = a.indexOf(h + \"\\x3d\");if (-1 !== b && (b = b + h.length + 1, h = a.charAt(b), '\"' === h || \"'\" === h)) return a = a.substring(b + 1), a.substring(0, a.indexOf(h));\n        };l = [d, B, Q, E, e, u, q].join();if (l !== a.textCache) {\n          for (a.textCache = l; H--;) c.removeChild(m[H]);y || e || B || q || -1 !== d.indexOf(\" \") ? (n && n.appendChild(c), d = y ? d.replace(/<(b|strong)>/g, '\\x3cspan style\\x3d\"font-weight:bold\"\\x3e').replace(/<(i|em)>/g, '\\x3cspan style\\x3d\"font-style:italic\"\\x3e').replace(/<a/g, \"\\x3cspan\").replace(/<\\/(b|strong|i|em|a)>/g, \"\\x3c/span\\x3e\").split(/<br.*?>/g) : [d], d = b(d, function (a) {\n            return \"\" !== a;\n          }), x(d, function (h, b) {\n            var d,\n                y = 0;h = h.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||\\x3cspan\").replace(/<\\/span>/g, \"\\x3c/span\\x3e|||\");d = h.split(\"|||\");x(d, function (h) {\n              if (\"\" !== h || 1 === d.length) {\n                var m = {},\n                    n = k.createElementNS(v.SVG_NS, \"tspan\"),\n                    E,\n                    z;(E = t(h, \"class\")) && g(n, \"class\", E);if (E = t(h, \"style\")) E = E.replace(/(;| |^)color([ :])/, \"$1fill$2\"), g(n, \"style\", E);(z = t(h, \"href\")) && !f && (g(n, \"onclick\", 'location.href\\x3d\"' + z + '\"'), g(n, \"class\", \"highcharts-anchor\"), w(n, { cursor: \"pointer\" }));h = N(h.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, \"\") || \" \");if (\" \" !== h) {\n                  n.appendChild(k.createTextNode(h));\n                  y ? m.dx = 0 : b && null !== A && (m.x = A);g(n, m);c.appendChild(n);!y && O && (!P && f && w(n, { display: \"block\" }), g(n, \"dy\", J(n)));if (q) {\n                    m = h.replace(/([^\\^])-/g, \"$1- \").split(\" \");z = 1 < d.length || b || 1 < m.length && !Q;var e = [],\n                        x,\n                        G = J(n),\n                        u = a.rotation;for (B && (p = v.applyEllipsis(a, n, h, q)); !B && z && (m.length || e.length);) a.rotation = 0, x = v.getSpanWidth(a, n), h = x > q, void 0 === p && (p = h), h && 1 !== m.length ? (n.removeChild(n.firstChild), e.unshift(m.pop())) : (m = e, e = [], m.length && !Q && (n = k.createElementNS(I, \"tspan\"), g(n, { dy: G, x: A }), E && g(n, \"style\", E), c.appendChild(n)), x > q && (q = x)), m.length && n.appendChild(k.createTextNode(m.join(\" \").replace(/- /g, \"-\")));a.rotation = u;\n                  }y++;\n                }\n              }\n            });O = O || c.childNodes.length;\n          }), p && a.attr(\"title\", N(a.textStr, [\"\\x26lt;\", \"\\x26gt;\"])), n && n.removeChild(c), e && a.applyTextOutline && a.applyTextOutline(e)) : c.appendChild(k.createTextNode(N(d)));\n        }\n      }, getContrast: function (a) {\n        a = t(a).rgba;return 510 < a[0] + a[1] + a[2] ? \"#000000\" : \"#FFFFFF\";\n      }, button: function (a, h, b, c, v, f, d, m, I) {\n        var y = this.label(a, h, b, I, null, null, null, null, \"button\"),\n            n = 0;y.attr(E({ padding: 8, r: 2 }, v));var A, k, q, z;v = E({ fill: \"#f7f7f7\", stroke: \"#cccccc\", \"stroke-width\": 1, style: { color: \"#333333\", cursor: \"pointer\", fontWeight: \"normal\" } }, v);A = v.style;delete v.style;f = E(v, { fill: \"#e6e6e6\" }, f);k = f.style;delete f.style;d = E(v, { fill: \"#e6ebf5\", style: { color: \"#000000\", fontWeight: \"bold\" } }, d);q = d.style;delete d.style;m = E(v, { style: { color: \"#cccccc\" } }, m);z = m.style;delete m.style;D(y.element, L ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== n && y.setState(1);\n        });D(y.element, L ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== n && y.setState(n);\n        });y.setState = function (a) {\n          1 !== a && (y.state = n = a);y.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][a || 0]);y.attr([v, f, d, m][a || 0]).css([A, k, q, z][a || 0]);\n        };y.attr(v).css(p({ cursor: \"default\" }, A));return y.on(\"click\", function (a) {\n          3 !== n && c.call(y, a);\n        });\n      }, crispLine: function (a, h) {\n        a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - h % 2 / 2);a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + h % 2 / 2);return a;\n      }, path: function (a) {\n        var h = { fill: \"none\" };J(a) ? h.d = a : B(a) && p(h, a);return this.createElement(\"path\").attr(h);\n      }, circle: function (a, h, b) {\n        a = B(a) ? a : { x: a, y: h, r: b };h = this.createElement(\"circle\");h.xSetter = h.ySetter = function (a, h, b) {\n          b.setAttribute(\"c\" + h, a);\n        };return h.attr(a);\n      }, arc: function (a, h, b, c, v, f) {\n        B(a) ? (c = a, h = c.y, b = c.r, a = c.x) : c = { innerR: c, start: v, end: f };a = this.symbol(\"arc\", a, h, b, b, c);a.r = b;return a;\n      }, rect: function (a, h, b, c, v, f) {\n        v = B(a) ? a.r : v;var d = this.createElement(\"rect\");a = B(a) ? a : void 0 === a ? {} : { x: a, y: h, width: Math.max(b, 0), height: Math.max(c, 0) };void 0 !== f && (a.strokeWidth = f, a = d.crisp(a));a.fill = \"none\";v && (a.r = v);d.rSetter = function (a, h, b) {\n          g(b, { rx: a, ry: a });\n        };return d.attr(a);\n      }, setSize: function (a, h, b) {\n        var c = this.alignedObjects,\n            v = c.length;this.width = a;this.height = h;for (this.boxWrapper.animate({ width: a, height: h }, { step: function () {\n            this.attr({ viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\") });\n          }, duration: G(b, !0) ? void 0 : 0 }); v--;) c[v].align();\n      }, g: function (a) {\n        var h = this.createElement(\"g\");return a ? h.attr({ \"class\": \"highcharts-\" + a }) : h;\n      }, image: function (a, h, b, c, v, f) {\n        var d = { preserveAspectRatio: \"none\" },\n            m,\n            I = function (a, h) {\n          a.setAttributeNS ? a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", h) : a.setAttribute(\"hc-svg-href\", h);\n        };1 < arguments.length && p(d, { x: h, y: b, width: c, height: v });m = this.createElement(\"image\").attr(d);f ? (I(m.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw\\x3d\\x3d\"), d = new N.Image(), D(d, \"load\", function (h) {\n          I(m.element, a);f.call(m, h);\n        }), d.src = a) : I(m.element, a);return m;\n      }, symbol: function (a, h, b, c, v, f) {\n        var d = this,\n            m,\n            I = /^url\\((.*?)\\)$/,\n            n = I.test(a),\n            y = !n && (this.symbols[a] ? a : \"circle\"),\n            A = y && this.symbols[y],\n            q = u(h) && A && A.call(this.symbols, Math.round(h), Math.round(b), c, v, f),\n            E,\n            z;A ? (m = this.path(q), m.attr(\"fill\", \"none\"), p(m, { symbolName: y, x: h, y: b, width: c, height: v }), f && p(m, f)) : n && (E = a.match(I)[1], m = this.image(E), m.imgwidth = G(O[E] && O[E].width, f && f.width), m.imgheight = G(O[E] && O[E].height, f && f.height), z = function () {\n          m.attr({ width: m.width, height: m.height });\n        }, x([\"width\", \"height\"], function (a) {\n          m[a + \"Setter\"] = function (a, h) {\n            var b = {},\n                c = this[\"img\" + h],\n                v = \"width\" === h ? \"translateX\" : \"translateY\";\n            this[h] = a;u(c) && (this.element && this.element.setAttribute(h, c), this.alignByTranslate || (b[v] = ((this[h] || 0) - c) / 2, this.attr(b)));\n          };\n        }), u(h) && m.attr({ x: h, y: b }), m.isImg = !0, u(m.imgwidth) && u(m.imgheight) ? z() : (m.attr({ width: 0, height: 0 }), l(\"img\", { onload: function () {\n            var a = e[d.chartIndex];0 === this.width && (w(this, { position: \"absolute\", top: \"-999em\" }), k.body.appendChild(this));O[E] = { width: this.width, height: this.height };m.imgwidth = this.width;m.imgheight = this.height;m.element && z();this.parentNode && this.parentNode.removeChild(this);\n            d.imgCount--;if (!d.imgCount && a && a.onload) a.onload();\n          }, src: E }), this.imgCount++));return m;\n      }, symbols: { circle: function (a, h, b, c) {\n          return this.arc(a + b / 2, h + c / 2, b / 2, c / 2, { start: 0, end: 2 * Math.PI, open: !1 });\n        }, square: function (a, h, b, c) {\n          return [\"M\", a, h, \"L\", a + b, h, a + b, h + c, a, h + c, \"Z\"];\n        }, triangle: function (a, h, b, c) {\n          return [\"M\", a + b / 2, h, \"L\", a + b, h + c, a, h + c, \"Z\"];\n        }, \"triangle-down\": function (a, h, b, c) {\n          return [\"M\", a, h, \"L\", a + b, h, a + b / 2, h + c, \"Z\"];\n        }, diamond: function (a, h, b, c) {\n          return [\"M\", a + b / 2, h, \"L\", a + b, h + c / 2, a + b / 2, h + c, a, h + c / 2, \"Z\"];\n        }, arc: function (a, h, b, c, v) {\n          var f = v.start,\n              d = v.r || b,\n              m = v.r || c || b,\n              I = v.end - .001;b = v.innerR;c = G(v.open, .001 > Math.abs(v.end - v.start - 2 * Math.PI));var n = Math.cos(f),\n              p = Math.sin(f),\n              y = Math.cos(I),\n              I = Math.sin(I);v = .001 > v.end - f - Math.PI ? 0 : 1;d = [\"M\", a + d * n, h + m * p, \"A\", d, m, 0, v, 1, a + d * y, h + m * I];u(b) && d.push(c ? \"M\" : \"L\", a + b * y, h + b * I, \"A\", b, b, 0, v, 0, a + b * n, h + b * p);d.push(c ? \"\" : \"Z\");return d;\n        }, callout: function (a, h, b, c, v) {\n          var f = Math.min(v && v.r || 0, b, c),\n              d = f + 6,\n              m = v && v.anchorX;v = v && v.anchorY;var I;I = [\"M\", a + f, h, \"L\", a + b - f, h, \"C\", a + b, h, a + b, h, a + b, h + f, \"L\", a + b, h + c - f, \"C\", a + b, h + c, a + b, h + c, a + b - f, h + c, \"L\", a + f, h + c, \"C\", a, h + c, a, h + c, a, h + c - f, \"L\", a, h + f, \"C\", a, h, a, h, a + f, h];m && m > b ? v > h + d && v < h + c - d ? I.splice(13, 3, \"L\", a + b, v - 6, a + b + 6, v, a + b, v + 6, a + b, h + c - f) : I.splice(13, 3, \"L\", a + b, c / 2, m, v, a + b, c / 2, a + b, h + c - f) : m && 0 > m ? v > h + d && v < h + c - d ? I.splice(33, 3, \"L\", a, v + 6, a - 6, v, a, v - 6, a, h + f) : I.splice(33, 3, \"L\", a, c / 2, m, v, a, c / 2, a, h + f) : v && v > c && m > a + d && m < a + b - d ? I.splice(23, 3, \"L\", m + 6, h + c, m, h + c + 6, m - 6, h + c, a + f, h + c) : v && 0 > v && m > a + d && m < a + b - d && I.splice(3, 3, \"L\", m - 6, h, m, h - 6, m + 6, h, b - f, h);return I;\n        } }, clipRect: function (h, b, c, v) {\n        var f = a.uniqueKey(),\n            d = this.createElement(\"clipPath\").attr({ id: f }).add(this.defs);h = this.rect(h, b, c, v, 0).add(d);h.id = f;h.clipPath = d;h.count = 0;return h;\n      }, text: function (a, h, b, c) {\n        var v = {};if (c && (this.allowHTML || !this.forExport)) return this.html(a, h, b);v.x = Math.round(h || 0);b && (v.y = Math.round(b));if (a || 0 === a) v.text = a;a = this.createElement(\"text\").attr(v);c || (a.xSetter = function (a, h, b) {\n          var c = b.getElementsByTagName(\"tspan\"),\n              v,\n              f = b.getAttribute(h),\n              d;for (d = 0; d < c.length; d++) v = c[d], v.getAttribute(h) === f && v.setAttribute(h, a);b.setAttribute(h, a);\n        });return a;\n      }, fontMetrics: function (a, b) {\n        a = a || b && b.style && b.style.fontSize || this.style && this.style.fontSize;a = /px/.test(a) ? h(a) : /em/.test(a) ? parseFloat(a) * (b ? this.fontMetrics(null, b.parentNode).f : 16) : 12;b = 24 > a ? a + 3 : Math.round(1.2 * a);return { h: b, b: Math.round(.8 * b), f: a };\n      }, rotCorr: function (a, h, b) {\n        var v = a;h && b && (v = Math.max(v * Math.cos(h * c), 4));return { x: -a / 3 * Math.sin(h * c), y: v };\n      }, label: function (h, b, c, f, d, m, I, n, A) {\n        var k = this,\n            q = k.g(\"button\" !== A && \"label\"),\n            z = q.text = k.text(\"\", 0, 0, I).attr({ zIndex: 1 }),\n            y,\n            e,\n            P = 0,\n            B = 3,\n            Q = 0,\n            g,\n            G,\n            l,\n            O,\n            H,\n            J = {},\n            M,\n            N,\n            w = /^url\\((.*?)\\)$/.test(f),\n            t = w,\n            L,\n            r,\n            R,\n            U;A && q.addClass(\"highcharts-\" + A);t = w;L = function () {\n          return (M || 0) % 2 / 2;\n        };r = function () {\n          var a = z.element.style,\n              h = {};e = (void 0 === g || void 0 === G || H) && u(z.textStr) && z.getBBox();q.width = (g || e.width || 0) + 2 * B + Q;q.height = (G || e.height || 0) + 2 * B;N = B + k.fontMetrics(a && a.fontSize, z).b;t && (y || (q.box = y = k.symbols[f] || w ? k.symbol(f) : k.rect(), y.addClass((\"button\" === A ? \"\" : \"highcharts-label-box\") + (A ? \" highcharts-\" + A + \"-box\" : \"\")), y.add(q), a = L(), h.x = a, h.y = (n ? -N : 0) + a), h.width = Math.round(q.width), h.height = Math.round(q.height), y.attr(p(h, J)), J = {});\n        };R = function () {\n          var a = Q + B,\n              h;h = n ? 0 : N;u(g) && e && (\"center\" === H || \"right\" === H) && (a += { center: .5, right: 1 }[H] * (g - e.width));if (a !== z.x || h !== z.y) z.attr(\"x\", a), void 0 !== h && z.attr(\"y\", h);z.x = a;z.y = h;\n        };U = function (a, h) {\n          y ? y.attr(a, h) : J[a] = h;\n        };q.onAdd = function () {\n          z.add(q);q.attr({ text: h || 0 === h ? h : \"\", x: b, y: c });y && u(d) && q.attr({ anchorX: d, anchorY: m });\n        };q.widthSetter = function (h) {\n          g = a.isNumber(h) ? h : null;\n        };q.heightSetter = function (a) {\n          G = a;\n        };q[\"text-alignSetter\"] = function (a) {\n          H = a;\n        };q.paddingSetter = function (a) {\n          u(a) && a !== B && (B = q.padding = a, R());\n        };q.paddingLeftSetter = function (a) {\n          u(a) && a !== Q && (Q = a, R());\n        };q.alignSetter = function (a) {\n          a = { left: 0, center: .5, right: 1 }[a];a !== P && (P = a, e && q.attr({ x: l }));\n        };q.textSetter = function (a) {\n          void 0 !== a && z.textSetter(a);r();R();\n        };q[\"stroke-widthSetter\"] = function (a, h) {\n          a && (t = !0);M = this[\"stroke-width\"] = a;U(h, a);\n        };q.strokeSetter = q.fillSetter = q.rSetter = function (a, h) {\n          \"r\" !== h && (\"fill\" === h && a && (t = !0), q[h] = a);U(h, a);\n        };q.anchorXSetter = function (a, h) {\n          d = q.anchorX = a;U(h, Math.round(a) - L() - l);\n        };q.anchorYSetter = function (a, h) {\n          m = q.anchorY = a;U(h, a - O);\n        };q.xSetter = function (a) {\n          q.x = a;P && (a -= P * ((g || e.width) + 2 * B), q[\"forceAnimate:x\"] = !0);l = Math.round(a);q.attr(\"translateX\", l);\n        };q.ySetter = function (a) {\n          O = q.y = Math.round(a);q.attr(\"translateY\", O);\n        };var S = q.css;return p(q, { css: function (a) {\n            if (a) {\n              var h = {};a = E(a);x(q.textProps, function (b) {\n                void 0 !== a[b] && (h[b] = a[b], delete a[b]);\n              });z.css(h);\"width\" in h && r();\n            }return S.call(q, a);\n          }, getBBox: function () {\n            return { width: e.width + 2 * B, height: e.height + 2 * B, x: e.x - B, y: e.y - B };\n          }, shadow: function (a) {\n            a && (r(), y && y.shadow(a));return q;\n          }, destroy: function () {\n            v(q.element, \"mouseenter\");v(q.element, \"mouseleave\");z && (z = z.destroy());y && (y = y.destroy());C.prototype.destroy.call(q);q = k = r = R = U = null;\n          } });\n      } });a.Renderer = F;\n  })(K);(function (a) {\n    var C = a.attr,\n        F = a.createElement,\n        D = a.css,\n        r = a.defined,\n        g = a.each,\n        e = a.extend,\n        t = a.isFirefox,\n        w = a.isMS,\n        l = a.isWebKit,\n        u = a.pick,\n        c = a.pInt,\n        d = a.SVGRenderer,\n        k = a.win,\n        x = a.wrap;e(a.SVGElement.prototype, { htmlCss: function (a) {\n        var c = this.element;if (c = a && \"SPAN\" === c.tagName && a.width) delete a.width, this.textWidth = c, this.htmlUpdateTransform();a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");this.styles = e(this.styles, a);D(this.element, a);return this;\n      }, htmlGetBBox: function () {\n        var a = this.element;return { x: a.offsetLeft, y: a.offsetTop, width: a.offsetWidth, height: a.offsetHeight };\n      }, htmlUpdateTransform: function () {\n        if (this.added) {\n          var a = this.renderer,\n              f = this.element,\n              b = this.translateX || 0,\n              d = this.translateY || 0,\n              k = this.x || 0,\n              e = this.y || 0,\n              q = this.textAlign || \"left\",\n              x = { left: 0, center: .5, right: 1 }[q],\n              B = this.styles,\n              l = B && B.whiteSpace;D(f, { marginLeft: b, marginTop: d });this.shadows && g(this.shadows, function (a) {\n            D(a, { marginLeft: b + 1, marginTop: d + 1 });\n          });this.inverted && g(f.childNodes, function (b) {\n            a.invertChild(b, f);\n          });if (\"SPAN\" === f.tagName) {\n            var B = this.rotation,\n                m = this.textWidth && c(this.textWidth),\n                E = [B, q, f.innerHTML, this.textWidth, this.textAlign].join(),\n                A;(A = m !== this.oldTextWidth) && !(A = m > this.oldTextWidth) && ((A = this.textPxLength) || (D(f, { width: \"\", whiteSpace: l || \"nowrap\" }), A = f.offsetWidth), A = A > m);A && /[ \\-]/.test(f.textContent || f.innerText) && (D(f, { width: m + \"px\", display: \"block\", whiteSpace: l || \"normal\" }), this.oldTextWidth = m);E !== this.cTT && (l = a.fontMetrics(f.style.fontSize).b, r(B) && B !== (this.oldRotation || 0) && this.setSpanRotation(B, x, l), this.getSpanCorrection(!r(B) && this.textPxLength || f.offsetWidth, l, x, B, q));D(f, { left: k + (this.xCorr || 0) + \"px\", top: e + (this.yCorr || 0) + \"px\" });this.cTT = E;this.oldRotation = B;\n          }\n        } else this.alignOnAdd = !0;\n      }, setSpanRotation: function (a, c, b) {\n        var f = {},\n            d = this.renderer.getTransformKey();\n        f[d] = f.transform = \"rotate(\" + a + \"deg)\";f[d + (t ? \"Origin\" : \"-origin\")] = f.transformOrigin = 100 * c + \"% \" + b + \"px\";D(this.element, f);\n      }, getSpanCorrection: function (a, c, b) {\n        this.xCorr = -a * b;this.yCorr = -c;\n      } });e(d.prototype, { getTransformKey: function () {\n        return w && !/Edge/.test(k.navigator.userAgent) ? \"-ms-transform\" : l ? \"-webkit-transform\" : t ? \"MozTransform\" : k.opera ? \"-o-transform\" : \"\";\n      }, html: function (a, c, b) {\n        var f = this.createElement(\"span\"),\n            d = f.element,\n            p = f.renderer,\n            q = p.isSVG,\n            k = function (a, b) {\n          g([\"opacity\", \"visibility\"], function (c) {\n            x(a, c + \"Setter\", function (a, c, f, d) {\n              a.call(this, c, f, d);b[f] = c;\n            });\n          });a.addedSetters = !0;\n        };f.textSetter = function (a) {\n          a !== d.innerHTML && delete this.bBox;this.textStr = a;d.innerHTML = u(a, \"\");f.doTransform = !0;\n        };q && k(f, f.element.style);f.xSetter = f.ySetter = f.alignSetter = f.rotationSetter = function (a, b) {\n          \"align\" === b && (b = \"textAlign\");f[b] = a;f.doTransform = !0;\n        };f.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };f.attr({ text: a, x: Math.round(c), y: Math.round(b) }).css({ fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize, position: \"absolute\" });d.style.whiteSpace = \"nowrap\";f.css = f.htmlCss;q && (f.add = function (a) {\n          var b,\n              c = p.box.parentNode,\n              q = [];if (this.parentGroup = a) {\n            if (b = a.div, !b) {\n              for (; a;) q.push(a), a = a.parentGroup;g(q.reverse(), function (a) {\n                function d(h, b) {\n                  a[b] = h;\"translateX\" === b ? m.left = h + \"px\" : m.top = h + \"px\";a.doTransform = !0;\n                }var m,\n                    h = C(a.element, \"class\");h && (h = { className: h });b = a.div = a.div || F(\"div\", h, { position: \"absolute\", left: (a.translateX || 0) + \"px\", top: (a.translateY || 0) + \"px\", display: a.display, opacity: a.opacity,\n                  pointerEvents: a.styles && a.styles.pointerEvents }, b || c);m = b.style;e(a, { classSetter: function (a) {\n                    return function (h) {\n                      this.element.setAttribute(\"class\", h);a.className = h;\n                    };\n                  }(b), on: function () {\n                    q[0].div && f.on.apply({ element: q[0].div }, arguments);return a;\n                  }, translateXSetter: d, translateYSetter: d });a.addedSetters || k(a, m);\n              });\n            }\n          } else b = c;b.appendChild(d);f.added = !0;f.alignOnAdd && f.htmlUpdateTransform();return f;\n        });return f;\n      } });\n  })(K);(function (a) {\n    var C = a.defined,\n        F = a.each,\n        D = a.extend,\n        r = a.merge,\n        g = a.pick,\n        e = a.timeUnits,\n        t = a.win;\n    a.Time = function (a) {\n      this.update(a, !1);\n    };a.Time.prototype = { defaultOptions: {}, update: function (e) {\n        var l = g(e && e.useUTC, !0),\n            u = this;this.options = e = r(!0, this.options || {}, e);this.Date = e.Date || t.Date;this.timezoneOffset = (this.useUTC = l) && e.timezoneOffset;this.getTimezoneOffset = this.timezoneOffsetFunction();(this.variableTimezone = !(l && !e.getTimezoneOffset && !e.timezone)) || this.timezoneOffset ? (this.get = function (a, d) {\n          var c = d.getTime(),\n              e = c - u.getTimezoneOffset(d);d.setTime(e);a = d[\"getUTC\" + a]();d.setTime(c);return a;\n        }, this.set = function (c, d, k) {\n          var e;if (-1 !== a.inArray(c, [\"Milliseconds\", \"Seconds\", \"Minutes\"])) d[\"set\" + c](k);else e = u.getTimezoneOffset(d), e = d.getTime() - e, d.setTime(e), d[\"setUTC\" + c](k), c = u.getTimezoneOffset(d), e = d.getTime() + c, d.setTime(e);\n        }) : l ? (this.get = function (a, d) {\n          return d[\"getUTC\" + a]();\n        }, this.set = function (a, d, k) {\n          return d[\"setUTC\" + a](k);\n        }) : (this.get = function (a, d) {\n          return d[\"get\" + a]();\n        }, this.set = function (a, d, k) {\n          return d[\"set\" + a](k);\n        });\n      }, makeTime: function (e, l, u, c, d, k) {\n        var x, p, f;this.useUTC ? (x = this.Date.UTC.apply(0, arguments), p = this.getTimezoneOffset(x), x += p, f = this.getTimezoneOffset(x), p !== f ? x += f - p : p - 36E5 !== this.getTimezoneOffset(x - 36E5) || a.isSafari || (x -= 36E5)) : x = new this.Date(e, l, g(u, 1), g(c, 0), g(d, 0), g(k, 0)).getTime();return x;\n      }, timezoneOffsetFunction: function () {\n        var e = this,\n            g = this.options,\n            u = t.moment;if (!this.useUTC) return function (a) {\n          return 6E4 * new Date(a).getTimezoneOffset();\n        };if (g.timezone) {\n          if (u) return function (a) {\n            return 6E4 * -u.tz(a, g.timezone).utcOffset();\n          };a.error(25);\n        }return this.useUTC && g.getTimezoneOffset ? function (a) {\n          return 6E4 * g.getTimezoneOffset(a);\n        } : function () {\n          return 6E4 * (e.timezoneOffset || 0);\n        };\n      }, dateFormat: function (e, g, u) {\n        if (!a.defined(g) || isNaN(g)) return a.defaultOptions.lang.invalidDate || \"\";e = a.pick(e, \"%Y-%m-%d %H:%M:%S\");var c = this,\n            d = new this.Date(g),\n            k = this.get(\"Hours\", d),\n            x = this.get(\"Day\", d),\n            p = this.get(\"Date\", d),\n            f = this.get(\"Month\", d),\n            b = this.get(\"FullYear\", d),\n            n = a.defaultOptions.lang,\n            z = n.weekdays,\n            l = n.shortWeekdays,\n            q = a.pad,\n            d = a.extend({ a: l ? l[x] : z[x].substr(0, 3), A: z[x], d: q(p), e: q(p, 2, \" \"), w: x, b: n.shortMonths[f],\n          B: n.months[f], m: q(f + 1), y: b.toString().substr(2, 2), Y: b, H: q(k), k: k, I: q(k % 12 || 12), l: k % 12 || 12, M: q(c.get(\"Minutes\", d)), p: 12 > k ? \"AM\" : \"PM\", P: 12 > k ? \"am\" : \"pm\", S: q(d.getSeconds()), L: q(Math.round(g % 1E3), 3) }, a.dateFormats);a.objectEach(d, function (a, b) {\n          for (; -1 !== e.indexOf(\"%\" + b);) e = e.replace(\"%\" + b, \"function\" === typeof a ? a.call(c, g) : a);\n        });return u ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;\n      }, getTimeTicks: function (a, l, u, c) {\n        var d = this,\n            k = [],\n            x = {},\n            p,\n            f = new d.Date(l),\n            b = a.unitRange,\n            n = a.count || 1,\n            z;if (C(l)) {\n          d.set(\"Milliseconds\", f, b >= e.second ? 0 : n * Math.floor(d.get(\"Milliseconds\", f) / n));b >= e.second && d.set(\"Seconds\", f, b >= e.minute ? 0 : n * Math.floor(d.get(\"Seconds\", f) / n));b >= e.minute && d.set(\"Minutes\", f, b >= e.hour ? 0 : n * Math.floor(d.get(\"Minutes\", f) / n));b >= e.hour && d.set(\"Hours\", f, b >= e.day ? 0 : n * Math.floor(d.get(\"Hours\", f) / n));b >= e.day && d.set(\"Date\", f, b >= e.month ? 1 : n * Math.floor(d.get(\"Date\", f) / n));b >= e.month && (d.set(\"Month\", f, b >= e.year ? 0 : n * Math.floor(d.get(\"Month\", f) / n)), p = d.get(\"FullYear\", f));b >= e.year && d.set(\"FullYear\", f, p - p % n);b === e.week && d.set(\"Date\", f, d.get(\"Date\", f) - d.get(\"Day\", f) + g(c, 1));p = d.get(\"FullYear\", f);c = d.get(\"Month\", f);var J = d.get(\"Date\", f),\n              q = d.get(\"Hours\", f);l = f.getTime();d.variableTimezone && (z = u - l > 4 * e.month || d.getTimezoneOffset(l) !== d.getTimezoneOffset(u));f = f.getTime();for (l = 1; f < u;) k.push(f), f = b === e.year ? d.makeTime(p + l * n, 0) : b === e.month ? d.makeTime(p, c + l * n) : !z || b !== e.day && b !== e.week ? z && b === e.hour && 1 < n ? d.makeTime(p, c, J, q + l * n) : f + b * n : d.makeTime(p, c, J + l * n * (b === e.day ? 1 : 7)), l++;k.push(f);b <= e.hour && 1E4 > k.length && F(k, function (a) {\n            0 === a % 18E5 && \"000000000\" === d.dateFormat(\"%H%M%S%L\", a) && (x[a] = \"day\");\n          });\n        }k.info = D(a, { higherRanks: x, totalRange: b * n });return k;\n      } };\n  })(K);(function (a) {\n    var C = a.color,\n        F = a.merge;a.defaultOptions = { colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"), symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"], lang: { loading: \"Loading...\", months: \"January February March April May June July August September October November December\".split(\" \"), shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), decimalPoint: \".\", numericSymbols: \"kMGTPE\".split(\"\"), resetZoom: \"Reset zoom\", resetZoomTitle: \"Reset zoom level 1:1\", thousandsSep: \" \" }, global: {}, time: a.Time.prototype.defaultOptions, chart: { borderRadius: 0, defaultSeriesType: \"line\", ignoreHiddenSeries: !0, spacing: [10, 10, 15, 10], resetZoomButton: { theme: { zIndex: 6 }, position: { align: \"right\", x: -10, y: 10 } }, width: null, height: null, borderColor: \"#335cad\", backgroundColor: \"#ffffff\", plotBorderColor: \"#cccccc\" },\n      title: { text: \"Chart title\", align: \"center\", margin: 15, widthAdjust: -44 }, subtitle: { text: \"\", align: \"center\", widthAdjust: -44 }, plotOptions: {}, labels: { style: { position: \"absolute\", color: \"#333333\" } }, legend: { enabled: !0, align: \"center\", alignColumns: !0, layout: \"horizontal\", labelFormatter: function () {\n          return this.name;\n        }, borderColor: \"#999999\", borderRadius: 0, navigation: { activeColor: \"#003399\", inactiveColor: \"#cccccc\" }, itemStyle: { color: \"#333333\", fontSize: \"12px\", fontWeight: \"bold\", textOverflow: \"ellipsis\" }, itemHoverStyle: { color: \"#000000\" },\n        itemHiddenStyle: { color: \"#cccccc\" }, shadow: !1, itemCheckboxStyle: { position: \"absolute\", width: \"13px\", height: \"13px\" }, squareSymbol: !0, symbolPadding: 5, verticalAlign: \"bottom\", x: 0, y: 0, title: { style: { fontWeight: \"bold\" } } }, loading: { labelStyle: { fontWeight: \"bold\", position: \"relative\", top: \"45%\" }, style: { position: \"absolute\", backgroundColor: \"#ffffff\", opacity: .5, textAlign: \"center\" } }, tooltip: { enabled: !0, animation: a.svg, borderRadius: 3, dateTimeLabelFormats: { millisecond: \"%A, %b %e, %H:%M:%S.%L\", second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\", hour: \"%A, %b %e, %H:%M\", day: \"%A, %b %e, %Y\", week: \"Week from %A, %b %e, %Y\", month: \"%B %Y\", year: \"%Y\" }, footerFormat: \"\", padding: 8, snap: a.isTouchDevice ? 25 : 10, backgroundColor: C(\"#f7f7f7\").setOpacity(.85).get(), borderWidth: 1, headerFormat: '\\x3cspan style\\x3d\"font-size: 10px\"\\x3e{point.key}\\x3c/span\\x3e\\x3cbr/\\x3e', pointFormat: '\\x3cspan style\\x3d\"color:{point.color}\"\\x3e\\u25cf\\x3c/span\\x3e {series.name}: \\x3cb\\x3e{point.y}\\x3c/b\\x3e\\x3cbr/\\x3e', shadow: !0, style: { color: \"#333333\", cursor: \"default\",\n          fontSize: \"12px\", pointerEvents: \"none\", whiteSpace: \"nowrap\" } }, credits: { enabled: !0, href: \"http://www.highcharts.com\", position: { align: \"right\", x: -10, verticalAlign: \"bottom\", y: -5 }, style: { cursor: \"pointer\", color: \"#999999\", fontSize: \"9px\" }, text: \"Highcharts.com\" } };a.setOptions = function (C) {\n      a.defaultOptions = F(!0, a.defaultOptions, C);a.time.update(F(a.defaultOptions.global, a.defaultOptions.time), !1);return a.defaultOptions;\n    };a.getOptions = function () {\n      return a.defaultOptions;\n    };a.defaultPlotOptions = a.defaultOptions.plotOptions;\n    a.time = new a.Time(F(a.defaultOptions.global, a.defaultOptions.time));a.dateFormat = function (C, r, g) {\n      return a.time.dateFormat(C, r, g);\n    };\n  })(K);(function (a) {\n    var C = a.correctFloat,\n        F = a.defined,\n        D = a.destroyObjectProperties,\n        r = a.fireEvent,\n        g = a.isNumber,\n        e = a.merge,\n        t = a.pick,\n        w = a.deg2rad;a.Tick = function (a, e, c, d) {\n      this.axis = a;this.pos = e;this.type = c || \"\";this.isNewLabel = this.isNew = !0;c || d || this.addLabel();\n    };a.Tick.prototype = { addLabel: function () {\n        var a = this.axis,\n            g = a.options,\n            c = a.chart,\n            d = a.categories,\n            k = a.names,\n            x = this.pos,\n            p = g.labels,\n            f = a.tickPositions,\n            b = x === f[0],\n            n = x === f[f.length - 1],\n            k = d ? t(d[x], k[x], x) : x,\n            d = this.label,\n            f = f.info,\n            z;a.isDatetimeAxis && f && (z = g.dateTimeLabelFormats[f.higherRanks[x] || f.unitName]);this.isFirst = b;this.isLast = n;g = a.labelFormatter.call({ axis: a, chart: c, isFirst: b, isLast: n, dateTimeLabelFormat: z, value: a.isLog ? C(a.lin2log(k)) : k, pos: x });if (F(d)) d && d.attr({ text: g });else {\n          if (this.label = d = F(g) && p.enabled ? c.renderer.text(g, 0, 0, p.useHTML).css(e(p.style)).add(a.labelGroup) : null) d.textPxLength = d.getBBox().width;this.rotation = 0;\n        }\n      }, getLabelSize: function () {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      }, handleOverflow: function (a) {\n        var e = this.axis,\n            c = e.options.labels,\n            d = a.x,\n            k = e.chart.chartWidth,\n            g = e.chart.spacing,\n            p = t(e.labelLeft, Math.min(e.pos, g[3])),\n            g = t(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, k - g[1])),\n            f = this.label,\n            b = this.rotation,\n            n = { left: 0, center: .5, right: 1 }[e.labelAlign || f.attr(\"align\")],\n            z = f.getBBox().width,\n            l = e.getSlotWidth(),\n            q = l,\n            L = 1,\n            B,\n            H = {};if (b || !1 === c.overflow) 0 > b && d - n * z < p ? B = Math.round(d / Math.cos(b * w) - p) : 0 < b && d + n * z > g && (B = Math.round((k - d) / Math.cos(b * w)));else if (k = d + (1 - n) * z, d - n * z < p ? q = a.x + q * (1 - n) - p : k > g && (q = g - a.x + q * n, L = -1), q = Math.min(l, q), q < l && \"center\" === e.labelAlign && (a.x += L * (l - q - n * (l - Math.min(z, q)))), z > q || e.autoRotation && (f.styles || {}).width) B = q;B && (H.width = B, (c.style || {}).textOverflow || (H.textOverflow = \"ellipsis\"), f.css(H));\n      }, getPosition: function (e, g, c, d) {\n        var k = this.axis,\n            x = k.chart,\n            p = d && x.oldChartHeight || x.chartHeight;e = { x: e ? a.correctFloat(k.translate(g + c, null, null, d) + k.transB) : k.left + k.offset + (k.opposite ? (d && x.oldChartWidth || x.chartWidth) - k.right - k.left : 0), y: e ? p - k.bottom + k.offset - (k.opposite ? k.height : 0) : a.correctFloat(p - k.translate(g + c, null, null, d) - k.transB) };r(this, \"afterGetPosition\", { pos: e });return e;\n      }, getLabelPosition: function (a, e, c, d, k, g, p, f) {\n        var b = this.axis,\n            n = b.transA,\n            z = b.reversed,\n            x = b.staggerLines,\n            q = b.tickRotCorr || { x: 0, y: 0 },\n            l = k.y,\n            B = d || b.reserveSpaceDefault ? 0 : -b.labelOffset * (\"center\" === b.labelAlign ? .5 : 1),\n            u = {};F(l) || (l = 0 === b.side ? c.rotation ? -8 : -c.getBBox().height : 2 === b.side ? q.y + 8 : Math.cos(c.rotation * w) * (q.y - c.getBBox(!1, 0).height / 2));a = a + k.x + B + q.x - (g && d ? g * n * (z ? -1 : 1) : 0);e = e + l - (g && !d ? g * n * (z ? 1 : -1) : 0);x && (c = p / (f || 1) % x, b.opposite && (c = x - c - 1), e += b.labelOffset / x * c);u.x = a;u.y = Math.round(e);r(this, \"afterGetLabelPosition\", { pos: u });return u;\n      }, getMarkPath: function (a, e, c, d, k, g) {\n        return g.crispLine([\"M\", a, e, \"L\", a + (k ? 0 : -c), e + (k ? c : 0)], d);\n      }, renderGridLine: function (a, e, c) {\n        var d = this.axis,\n            k = d.options,\n            g = this.gridLine,\n            p = {},\n            f = this.pos,\n            b = this.type,\n            n = d.tickmarkOffset,\n            z = d.chart.renderer,\n            l = b ? b + \"Grid\" : \"grid\",\n            q = k[l + \"LineWidth\"],\n            u = k[l + \"LineColor\"],\n            k = k[l + \"LineDashStyle\"];g || (p.stroke = u, p[\"stroke-width\"] = q, k && (p.dashstyle = k), b || (p.zIndex = 1), a && (p.opacity = 0), this.gridLine = g = z.path().attr(p).addClass(\"highcharts-\" + (b ? b + \"-\" : \"\") + \"grid-line\").add(d.gridGroup));if (!a && g && (a = d.getPlotLinePath(f + n, g.strokeWidth() * c, a, !0))) g[this.isNew ? \"attr\" : \"animate\"]({ d: a, opacity: e });\n      }, renderMark: function (a, e, c) {\n        var d = this.axis,\n            k = d.options,\n            g = d.chart.renderer,\n            p = this.type,\n            f = p ? p + \"Tick\" : \"tick\",\n            b = d.tickSize(f),\n            n = this.mark,\n            z = !n,\n            l = a.x;a = a.y;var q = t(k[f + \"Width\"], !p && d.isXAxis ? 1 : 0),\n            k = k[f + \"Color\"];b && (d.opposite && (b[0] = -b[0]), z && (this.mark = n = g.path().addClass(\"highcharts-\" + (p ? p + \"-\" : \"\") + \"tick\").add(d.axisGroup), n.attr({ stroke: k, \"stroke-width\": q })), n[z ? \"attr\" : \"animate\"]({ d: this.getMarkPath(l, a, b[0], n.strokeWidth() * c, d.horiz, g), opacity: e }));\n      }, renderLabel: function (a, e, c, d) {\n        var k = this.axis,\n            x = k.horiz,\n            p = k.options,\n            f = this.label,\n            b = p.labels,\n            n = b.step,\n            k = k.tickmarkOffset,\n            z = !0,\n            u = a.x;a = a.y;f && g(u) && (f.xy = a = this.getLabelPosition(u, a, f, x, b, k, d, n), this.isFirst && !this.isLast && !t(p.showFirstLabel, 1) || this.isLast && !this.isFirst && !t(p.showLastLabel, 1) ? z = !1 : !x || b.step || b.rotation || e || 0 === c || this.handleOverflow(a), n && d % n && (z = !1), z && g(a.y) ? (a.opacity = c, f[this.isNewLabel ? \"attr\" : \"animate\"](a), this.isNewLabel = !1) : (f.attr(\"y\", -9999), this.isNewLabel = !0));\n      }, render: function (e, g, c) {\n        var d = this.axis,\n            k = d.horiz,\n            x = this.getPosition(k, this.pos, d.tickmarkOffset, g),\n            p = x.x,\n            f = x.y,\n            d = k && p === d.pos + d.len || !k && f === d.pos ? -1 : 1;c = t(c, 1);this.isActive = !0;this.renderGridLine(g, c, d);this.renderMark(x, c, d);this.renderLabel(x, g, c, e);this.isNew = !1;a.fireEvent(this, \"afterRender\");\n      }, destroy: function () {\n        D(this, this.axis);\n      } };\n  })(K);var V = function (a) {\n    var C = a.addEvent,\n        F = a.animObject,\n        D = a.arrayMax,\n        r = a.arrayMin,\n        g = a.color,\n        e = a.correctFloat,\n        t = a.defaultOptions,\n        w = a.defined,\n        l = a.deg2rad,\n        u = a.destroyObjectProperties,\n        c = a.each,\n        d = a.extend,\n        k = a.fireEvent,\n        x = a.format,\n        p = a.getMagnitude,\n        f = a.grep,\n        b = a.inArray,\n        n = a.isArray,\n        z = a.isNumber,\n        J = a.isString,\n        q = a.merge,\n        L = a.normalizeTickInterval,\n        B = a.objectEach,\n        H = a.pick,\n        m = a.removeEvent,\n        E = a.splat,\n        A = a.syncTimeout,\n        M = a.Tick,\n        G = function () {\n      this.init.apply(this, arguments);\n    };a.extend(G.prototype, { defaultOptions: { dateTimeLabelFormats: { millisecond: \"%H:%M:%S.%L\", second: \"%H:%M:%S\", minute: \"%H:%M\", hour: \"%H:%M\", day: \"%e. %b\", week: \"%e. %b\", month: \"%b '%y\", year: \"%Y\" }, endOnTick: !1, labels: { enabled: !0, style: { color: \"#666666\", cursor: \"default\", fontSize: \"11px\" }, x: 0 }, maxPadding: .01, minorTickLength: 2, minorTickPosition: \"outside\", minPadding: .01, startOfWeek: 1, startOnTick: !1, tickLength: 10, tickmarkPlacement: \"between\",\n        tickPixelInterval: 100, tickPosition: \"outside\", title: { align: \"middle\", style: { color: \"#666666\" } }, type: \"linear\", minorGridLineColor: \"#f2f2f2\", minorGridLineWidth: 1, minorTickColor: \"#999999\", lineColor: \"#ccd6eb\", lineWidth: 1, gridLineColor: \"#e6e6e6\", tickColor: \"#ccd6eb\" }, defaultYAxisOptions: { endOnTick: !0, tickPixelInterval: 72, showLastLabel: !0, labels: { x: -8 }, maxPadding: .05, minPadding: .05, startOnTick: !0, title: { rotation: 270, text: \"Values\" }, stackLabels: { allowOverlap: !1, enabled: !1, formatter: function () {\n            return a.numberFormat(this.total, -1);\n          }, style: { fontSize: \"11px\", fontWeight: \"bold\", color: \"#000000\", textOutline: \"1px contrast\" } }, gridLineWidth: 1, lineWidth: 0 }, defaultLeftAxisOptions: { labels: { x: -15 }, title: { rotation: 270 } }, defaultRightAxisOptions: { labels: { x: 15 }, title: { rotation: 90 } }, defaultBottomAxisOptions: { labels: { autoRotation: [-45], x: 0 }, title: { rotation: 0 } }, defaultTopAxisOptions: { labels: { autoRotation: [-45], x: 0 }, title: { rotation: 0 } }, init: function (a, c) {\n        var h = c.isX,\n            v = this;v.chart = a;v.horiz = a.inverted && !v.isZAxis ? !h : h;v.isXAxis = h;v.coll = v.coll || (h ? \"xAxis\" : \"yAxis\");k(this, \"init\", { userOptions: c });v.opposite = c.opposite;v.side = c.side || (v.horiz ? v.opposite ? 0 : 2 : v.opposite ? 1 : 3);v.setOptions(c);var f = this.options,\n            d = f.type;v.labelFormatter = f.labels.formatter || v.defaultLabelFormatter;v.userOptions = c;v.minPixelPadding = 0;v.reversed = f.reversed;v.visible = !1 !== f.visible;v.zoomEnabled = !1 !== f.zoomEnabled;v.hasNames = \"category\" === d || !0 === f.categories;v.categories = f.categories || v.hasNames;v.names || (v.names = [], v.names.keys = {});v.plotLinesAndBandsGroups = {};v.isLog = \"logarithmic\" === d;v.isDatetimeAxis = \"datetime\" === d;v.positiveValuesOnly = v.isLog && !v.allowNegativeLog;v.isLinked = w(f.linkedTo);v.ticks = {};v.labelEdge = [];v.minorTicks = {};v.plotLinesAndBands = [];v.alternateBands = {};v.len = 0;v.minRange = v.userMinRange = f.minRange || f.maxZoom;v.range = f.range;v.offset = f.offset || 0;v.stacks = {};v.oldStacks = {};v.stacksTouched = 0;v.max = null;v.min = null;v.crosshair = H(f.crosshair, E(a.options.tooltip.crosshairs)[h ? 0 : 1], !1);c = v.options.events;-1 === b(v, a.axes) && (h ? a.axes.splice(a.xAxis.length, 0, v) : a.axes.push(v), a[v.coll].push(v));v.series = v.series || [];a.inverted && !v.isZAxis && h && void 0 === v.reversed && (v.reversed = !0);B(c, function (a, h) {\n          C(v, h, a);\n        });v.lin2log = f.linearToLogConverter || v.lin2log;v.isLog && (v.val2lin = v.log2lin, v.lin2val = v.lin2log);k(this, \"afterInit\");\n      }, setOptions: function (a) {\n        this.options = q(this.defaultOptions, \"yAxis\" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], q(t[this.coll], a));k(this, \"afterSetOptions\", { userOptions: a });\n      }, defaultLabelFormatter: function () {\n        var h = this.axis,\n            b = this.value,\n            c = h.chart.time,\n            f = h.categories,\n            d = this.dateTimeLabelFormat,\n            m = t.lang,\n            q = m.numericSymbols,\n            m = m.numericSymbolMagnitude || 1E3,\n            p = q && q.length,\n            n,\n            e = h.options.labels.format,\n            h = h.isLog ? Math.abs(b) : h.tickInterval;if (e) n = x(e, this, c);else if (f) n = b;else if (d) n = c.dateFormat(d, b);else if (p && 1E3 <= h) for (; p-- && void 0 === n;) c = Math.pow(m, p + 1), h >= c && 0 === 10 * b % c && null !== q[p] && 0 !== b && (n = a.numberFormat(b / c, -1) + q[p]);void 0 === n && (n = 1E4 <= Math.abs(b) ? a.numberFormat(b, -1) : a.numberFormat(b, -1, void 0, \"\"));return n;\n      }, getSeriesExtremes: function () {\n        var a = this,\n            b = a.chart;k(this, \"getSeriesExtremes\", null, function () {\n          a.hasVisibleSeries = !1;a.dataMin = a.dataMax = a.threshold = null;a.softThreshold = !a.isXAxis;a.buildStacks && a.buildStacks();c(a.series, function (h) {\n            if (h.visible || !b.options.chart.ignoreHiddenSeries) {\n              var v = h.options,\n                  c = v.threshold,\n                  d;a.hasVisibleSeries = !0;a.positiveValuesOnly && 0 >= c && (c = null);if (a.isXAxis) v = h.xData, v.length && (h = r(v), d = D(v), z(h) || h instanceof Date || (v = f(v, z), h = r(v), d = D(v)), v.length && (a.dataMin = Math.min(H(a.dataMin, v[0], h), h), a.dataMax = Math.max(H(a.dataMax, v[0], d), d)));else if (h.getExtremes(), d = h.dataMax, h = h.dataMin, w(h) && w(d) && (a.dataMin = Math.min(H(a.dataMin, h), h), a.dataMax = Math.max(H(a.dataMax, d), d)), w(c) && (a.threshold = c), !v.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;\n            }\n          });\n        });k(this, \"afterGetSeriesExtremes\");\n      }, translate: function (a, b, c, f, d, m) {\n        var h = this.linkedParent || this,\n            v = 1,\n            I = 0,\n            q = f ? h.oldTransA : h.transA;f = f ? h.oldMin : h.min;var p = h.minPixelPadding;d = (h.isOrdinal || h.isBroken || h.isLog && d) && h.lin2val;q || (q = h.transA);c && (v *= -1, I = h.len);h.reversed && (v *= -1, I -= v * (h.sector || h.len));b ? (a = (a * v + I - p) / q + f, d && (a = h.lin2val(a))) : (d && (a = h.val2lin(a)), a = z(f) ? v * (a - f) * q + I + v * p + (z(m) ? q * m : 0) : void 0);return a;\n      }, toPixels: function (a, b) {\n        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);\n      }, toValue: function (a, b) {\n        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);\n      }, getPlotLinePath: function (a, b, c, f, d) {\n        var h = this.chart,\n            v = this.left,\n            m = this.top,\n            I,\n            q,\n            p = c && h.oldChartHeight || h.chartHeight,\n            n = c && h.oldChartWidth || h.chartWidth,\n            e;I = this.transB;var A = function (a, h, b) {\n          if (a < h || a > b) f ? a = Math.min(Math.max(h, a), b) : e = !0;return a;\n        };d = H(d, this.translate(a, null, null, c));d = Math.min(Math.max(-1E5, d), 1E5);a = c = Math.round(d + I);I = q = Math.round(p - d - I);z(d) ? this.horiz ? (I = m, q = p - this.bottom, a = c = A(a, v, v + this.width)) : (a = v, c = n - this.right, I = q = A(I, m, m + this.height)) : (e = !0, f = !1);return e && !f ? null : h.renderer.crispLine([\"M\", a, I, \"L\", c, q], b || 1);\n      }, getLinearTickPositions: function (a, b, c) {\n        var h,\n            v = e(Math.floor(b / a) * a);c = e(Math.ceil(c / a) * a);var f = [],\n            d;e(v + a) === v && (d = 20);if (this.single) return [b];for (b = v; b <= c;) {\n          f.push(b);b = e(b + a, d);if (b === h) break;h = b;\n        }return f;\n      }, getMinorTickInterval: function () {\n        var a = this.options;return !0 === a.minorTicks ? H(a.minorTickInterval, \"auto\") : !1 === a.minorTicks ? null : a.minorTickInterval;\n      }, getMinorTickPositions: function () {\n        var a = this,\n            b = a.options,\n            f = a.tickPositions,\n            d = a.minorTickInterval,\n            m = [],\n            q = a.pointRangePadding || 0,\n            p = a.min - q,\n            q = a.max + q,\n            n = q - p;if (n && n / d < a.len / 3) if (a.isLog) c(this.paddedTicks, function (h, b, c) {\n          b && m.push.apply(m, a.getLogTickPositions(d, c[b - 1], c[b], !0));\n        });else if (a.isDatetimeAxis && \"auto\" === this.getMinorTickInterval()) m = m.concat(a.getTimeTicks(a.normalizeTimeTickInterval(d), p, q, b.startOfWeek));else for (b = p + (f[0] - p) % d; b <= q && b !== m[0]; b += d) m.push(b);0 !== m.length && a.trimTicks(m);return m;\n      }, adjustForMinRange: function () {\n        var a = this.options,\n            b = this.min,\n            f = this.max,\n            d,\n            m,\n            q,\n            p,\n            n,\n            e,\n            A,\n            k;this.isXAxis && void 0 === this.minRange && !this.isLog && (w(a.min) || w(a.max) ? this.minRange = null : (c(this.series, function (a) {\n          e = a.xData;for (p = A = a.xIncrement ? 1 : e.length - 1; 0 < p; p--) if (n = e[p] - e[p - 1], void 0 === q || n < q) q = n;\n        }), this.minRange = Math.min(5 * q, this.dataMax - this.dataMin)));f - b < this.minRange && (m = this.dataMax - this.dataMin >= this.minRange, k = this.minRange, d = (k - f + b) / 2, d = [b - d, H(a.min, b - d)], m && (d[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), b = D(d), f = [b + k, H(a.max, b + k)], m && (f[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), f = r(f), f - b < k && (d[0] = f - k, d[1] = H(a.min, f - k), b = D(d)));this.min = b;this.max = f;\n      }, getClosest: function () {\n        var a;this.categories ? a = 1 : c(this.series, function (h) {\n          var b = h.closestPointRange,\n              c = h.visible || !h.chart.options.chart.ignoreHiddenSeries;!h.noSharedTooltip && w(b) && c && (a = w(a) ? Math.min(a, b) : b);\n        });return a;\n      }, nameToX: function (a) {\n        var h = n(this.categories),\n            c = h ? this.categories : this.names,\n            f = a.options.x,\n            d;a.series.requireSorting = !1;w(f) || (f = !1 === this.options.uniqueNames ? a.series.autoIncrement() : h ? b(a.name, c) : H(c.keys[a.name], -1));-1 === f ? h || (d = c.length) : d = f;void 0 !== d && (this.names[d] = a.name, this.names.keys[a.name] = d);return d;\n      }, updateNames: function () {\n        var h = this,\n            b = this.names;0 < b.length && (c(a.keys(b.keys), function (a) {\n          delete b.keys[a];\n        }), b.length = 0, this.minRange = this.userMinRange, c(this.series || [], function (a) {\n          a.xIncrement = null;if (!a.points || a.isDirtyData) a.processData(), a.generatePoints();c(a.points, function (b, c) {\n            var f;b.options && (f = h.nameToX(b), void 0 !== f && f !== b.x && (b.x = f, a.xData[c] = f));\n          });\n        }));\n      }, setAxisTranslation: function (a) {\n        var h = this,\n            b = h.max - h.min,\n            f = h.axisPointRange || 0,\n            d,\n            m = 0,\n            q = 0,\n            p = h.linkedParent,\n            n = !!h.categories,\n            e = h.transA,\n            A = h.isXAxis;if (A || n || f) d = h.getClosest(), p ? (m = p.minPointOffset, q = p.pointRangePadding) : c(h.series, function (a) {\n          var b = n ? 1 : A ? H(a.options.pointRange, d, 0) : h.axisPointRange || 0;a = a.options.pointPlacement;f = Math.max(f, b);h.single || (m = Math.max(m, J(a) ? 0 : b / 2), q = Math.max(q, \"on\" === a ? 0 : b));\n        }), p = h.ordinalSlope && d ? h.ordinalSlope / d : 1, h.minPointOffset = m *= p, h.pointRangePadding = q *= p, h.pointRange = Math.min(f, b), A && (h.closestPointRange = d);a && (h.oldTransA = e);h.translationSlope = h.transA = e = h.options.staticScale || h.len / (b + q || 1);h.transB = h.horiz ? h.left : h.bottom;h.minPixelPadding = e * m;k(this, \"afterSetAxisTranslation\");\n      }, minFromRange: function () {\n        return this.max - this.range;\n      }, setTickInterval: function (h) {\n        var b = this,\n            f = b.chart,\n            d = b.options,\n            m = b.isLog,\n            q = b.isDatetimeAxis,\n            n = b.isXAxis,\n            A = b.isLinked,\n            E = d.maxPadding,\n            g = d.minPadding,\n            B = d.tickInterval,\n            x = d.tickPixelInterval,\n            G = b.categories,\n            u = z(b.threshold) ? b.threshold : null,\n            l = b.softThreshold,\n            t,\n            J,\n            M,\n            r;q || G || A || this.getTickAmount();\n        M = H(b.userMin, d.min);r = H(b.userMax, d.max);A ? (b.linkedParent = f[b.coll][d.linkedTo], f = b.linkedParent.getExtremes(), b.min = H(f.min, f.dataMin), b.max = H(f.max, f.dataMax), d.type !== b.linkedParent.options.type && a.error(11, 1)) : (!l && w(u) && (b.dataMin >= u ? (t = u, g = 0) : b.dataMax <= u && (J = u, E = 0)), b.min = H(M, t, b.dataMin), b.max = H(r, J, b.dataMax));m && (b.positiveValuesOnly && !h && 0 >= Math.min(b.min, H(b.dataMin, b.min)) && a.error(10, 1), b.min = e(b.log2lin(b.min), 15), b.max = e(b.log2lin(b.max), 15));b.range && w(b.max) && (b.userMin = b.min = M = Math.max(b.dataMin, b.minFromRange()), b.userMax = r = b.max, b.range = null);k(b, \"foundExtremes\");b.beforePadding && b.beforePadding();b.adjustForMinRange();!(G || b.axisPointRange || b.usePercentage || A) && w(b.min) && w(b.max) && (f = b.max - b.min) && (!w(M) && g && (b.min -= f * g), !w(r) && E && (b.max += f * E));z(d.softMin) && !z(b.userMin) && (b.min = Math.min(b.min, d.softMin));z(d.softMax) && !z(b.userMax) && (b.max = Math.max(b.max, d.softMax));z(d.floor) && (b.min = Math.max(b.min, d.floor));z(d.ceiling) && (b.max = Math.min(b.max, d.ceiling));l && w(b.dataMin) && (u = u || 0, !w(M) && b.min < u && b.dataMin >= u ? b.min = u : !w(r) && b.max > u && b.dataMax <= u && (b.max = u));b.tickInterval = b.min === b.max || void 0 === b.min || void 0 === b.max ? 1 : A && !B && x === b.linkedParent.options.tickPixelInterval ? B = b.linkedParent.tickInterval : H(B, this.tickAmount ? (b.max - b.min) / Math.max(this.tickAmount - 1, 1) : void 0, G ? 1 : (b.max - b.min) * x / Math.max(b.len, x));n && !h && c(b.series, function (a) {\n          a.processData(b.min !== b.oldMin || b.max !== b.oldMax);\n        });b.setAxisTranslation(!0);b.beforeSetTickPositions && b.beforeSetTickPositions();\n        b.postProcessTickInterval && (b.tickInterval = b.postProcessTickInterval(b.tickInterval));b.pointRange && !B && (b.tickInterval = Math.max(b.pointRange, b.tickInterval));h = H(d.minTickInterval, b.isDatetimeAxis && b.closestPointRange);!B && b.tickInterval < h && (b.tickInterval = h);q || m || B || (b.tickInterval = L(b.tickInterval, null, p(b.tickInterval), H(d.allowDecimals, !(.5 < b.tickInterval && 5 > b.tickInterval && 1E3 < b.max && 9999 > b.max)), !!this.tickAmount));this.tickAmount || (b.tickInterval = b.unsquish());this.setTickPositions();\n      }, setTickPositions: function () {\n        var a = this.options,\n            b,\n            c = a.tickPositions;b = this.getMinorTickInterval();var f = a.tickPositioner,\n            d = a.startOnTick,\n            m = a.endOnTick;this.tickmarkOffset = this.categories && \"between\" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;this.minorTickInterval = \"auto\" === b && this.tickInterval ? this.tickInterval / 5 : b;this.single = this.min === this.max && w(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);this.tickPositions = b = c && c.slice();!b && (b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b.length > this.len && (b = [b[0], b.pop()], b[0] === b[1] && (b.length = 1)), this.tickPositions = b, f && (f = f.apply(this, [this.min, this.max]))) && (this.tickPositions = b = f);this.paddedTicks = b.slice(0);this.trimTicks(b, d, m);this.isLinked || (this.single && 2 > b.length && (this.min -= .5, this.max += .5), c || f || this.adjustTickAmount());k(this, \"afterSetTickPositions\");\n      }, trimTicks: function (a, b, c) {\n        var h = a[0],\n            f = a[a.length - 1],\n            d = this.minPointOffset || 0;if (!this.isLinked) {\n          if (b && -Infinity !== h) this.min = h;else for (; this.min - d > a[0];) a.shift();if (c) this.max = f;else for (; this.max + d < a[a.length - 1];) a.pop();0 === a.length && w(h) && !this.options.tickPositions && a.push((f + h) / 2);\n        }\n      }, alignToOthers: function () {\n        var a = {},\n            b,\n            f = this.options;!1 === this.chart.options.chart.alignTicks || !1 === f.alignTicks || !1 === f.startOnTick || !1 === f.endOnTick || this.isLog || c(this.chart[this.coll], function (h) {\n          var c = h.options,\n              c = [h.horiz ? c.left : c.top, c.width, c.height, c.pane].join();h.series.length && (a[c] ? b = !0 : a[c] = 1);\n        });return b;\n      }, getTickAmount: function () {\n        var a = this.options,\n            b = a.tickAmount,\n            c = a.tickPixelInterval;!w(a.tickInterval) && this.len < c && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);!b && this.alignToOthers() && (b = Math.ceil(this.len / c) + 1);4 > b && (this.finalTickAmt = b, b = 5);this.tickAmount = b;\n      }, adjustTickAmount: function () {\n        var a = this.tickInterval,\n            b = this.tickPositions,\n            c = this.tickAmount,\n            f = this.finalTickAmt,\n            d = b && b.length,\n            m = H(this.threshold, this.softThreshold ? 0 : null);if (this.hasData()) {\n          if (d < c) {\n            for (; b.length < c;) b.length % 2 || this.min === m ? b.push(e(b[b.length - 1] + a)) : b.unshift(e(b[0] - a));this.transA *= (d - 1) / (c - 1);this.min = b[0];this.max = b[b.length - 1];\n          } else d > c && (this.tickInterval *= 2, this.setTickPositions());if (w(f)) {\n            for (a = c = b.length; a--;) (3 === f && 1 === a % 2 || 2 >= f && 0 < a && a < c - 1) && b.splice(a, 1);this.finalTickAmt = void 0;\n          }\n        }\n      }, setScale: function () {\n        var a, b;this.oldMin = this.min;this.oldMax = this.max;this.oldAxisLength = this.len;this.setAxisSize();b = this.len !== this.oldAxisLength;c(this.series, function (b) {\n          if (b.isDirtyData || b.isDirty || b.xAxis.isDirty) a = !0;\n        });b || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();k(this, \"afterSetScale\");\n      }, setExtremes: function (a, b, f, m, q) {\n        var h = this,\n            p = h.chart;f = H(f, !0);c(h.series, function (a) {\n          delete a.kdTree;\n        });q = d(q, { min: a, max: b });k(h, \"setExtremes\", q, function () {\n          h.userMin = a;h.userMax = b;h.eventArgs = q;f && p.redraw(m);\n        });\n      }, zoom: function (a, b) {\n        var h = this.dataMin,\n            c = this.dataMax,\n            f = this.options,\n            d = Math.min(h, H(f.min, h)),\n            f = Math.max(c, H(f.max, c));if (a !== this.min || b !== this.max) this.allowZoomOutside || (w(h) && (a < d && (a = d), a > f && (a = f)), w(c) && (b < d && (b = d), b > f && (b = f))), this.displayBtn = void 0 !== a || void 0 !== b, this.setExtremes(a, b, !1, void 0, { trigger: \"zoom\" });return !0;\n      }, setAxisSize: function () {\n        var b = this.chart,\n            c = this.options,\n            f = c.offsets || [0, 0, 0, 0],\n            d = this.horiz,\n            m = this.width = Math.round(a.relativeLength(H(c.width, b.plotWidth - f[3] + f[1]), b.plotWidth)),\n            q = this.height = Math.round(a.relativeLength(H(c.height, b.plotHeight - f[0] + f[2]), b.plotHeight)),\n            p = this.top = Math.round(a.relativeLength(H(c.top, b.plotTop + f[0]), b.plotHeight, b.plotTop)),\n            c = this.left = Math.round(a.relativeLength(H(c.left, b.plotLeft + f[3]), b.plotWidth, b.plotLeft));this.bottom = b.chartHeight - q - p;this.right = b.chartWidth - m - c;this.len = Math.max(d ? m : q, 0);this.pos = d ? c : p;\n      }, getExtremes: function () {\n        var a = this.isLog;return { min: a ? e(this.lin2log(this.min)) : this.min, max: a ? e(this.lin2log(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax };\n      }, getThreshold: function (a) {\n        var b = this.isLog,\n            h = b ? this.lin2log(this.min) : this.min,\n            b = b ? this.lin2log(this.max) : this.max;null === a || -Infinity === a ? a = h : Infinity === a ? a = b : h > a ? a = h : b < a && (a = b);return this.translate(a, 0, 1, 0, 1);\n      }, autoLabelAlign: function (a) {\n        a = (H(a, 0) - 90 * this.side + 720) % 360;return 15 < a && 165 > a ? \"right\" : 195 < a && 345 > a ? \"left\" : \"center\";\n      }, tickSize: function (a) {\n        var b = this.options,\n            h = b[a + \"Length\"],\n            c = H(b[a + \"Width\"], \"tick\" === a && this.isXAxis ? 1 : 0);if (c && h) return \"inside\" === b[a + \"Position\"] && (h = -h), [h, c];\n      }, labelMetrics: function () {\n        var a = this.tickPositions && this.tickPositions[0] || 0;return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);\n      }, unsquish: function () {\n        var a = this.options.labels,\n            b = this.horiz,\n            f = this.tickInterval,\n            d = f,\n            m = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / f),\n            q,\n            p = a.rotation,\n            n = this.labelMetrics(),\n            A,\n            k = Number.MAX_VALUE,\n            E,\n            z = function (a) {\n          a /= m || 1;a = 1 < a ? Math.ceil(a) : 1;return e(a * f);\n        };b ? (E = !a.staggerLines && !a.step && (w(p) ? [p] : m < H(a.autoRotationLimit, 80) && a.autoRotation)) && c(E, function (a) {\n          var b;if (a === p || a && -90 <= a && 90 >= a) A = z(Math.abs(n.h / Math.sin(l * a))), b = A + Math.abs(a / 360), b < k && (k = b, q = a, d = A);\n        }) : a.step || (d = z(n.h));this.autoRotation = E;this.labelRotation = H(q, p);return d;\n      }, getSlotWidth: function () {\n        var a = this.chart,\n            b = this.horiz,\n            c = this.options.labels,\n            f = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            d = a.margin[3];return b && 2 > (c.step || 0) && !c.rotation && (this.staggerLines || 1) * this.len / f || !b && (c.style && parseInt(c.style.width, 10) || d && d - a.spacing[3] || .33 * a.chartWidth);\n      }, renderUnsquish: function () {\n        var a = this.chart,\n            b = a.renderer,\n            f = this.tickPositions,\n            d = this.ticks,\n            m = this.options.labels,\n            q = this.horiz,\n            p = this.getSlotWidth(),\n            n = Math.max(1, Math.round(p - 2 * (m.padding || 5))),\n            e = {},\n            A = this.labelMetrics(),\n            k = m.style && m.style.textOverflow,\n            E,\n            z,\n            g = 0,\n            B;J(m.rotation) || (e.rotation = m.rotation || 0);c(f, function (a) {\n          (a = d[a]) && a.label && a.label.textPxLength > g && (g = a.label.textPxLength);\n        });this.maxLabelLength = g;if (this.autoRotation) g > n && g > A.h ? e.rotation = this.labelRotation : this.labelRotation = 0;else if (p && (E = n, !k)) for (z = \"clip\", n = f.length; !q && n--;) if (B = f[n], B = d[B].label) B.styles && \"ellipsis\" === B.styles.textOverflow ? B.css({ textOverflow: \"clip\" }) : B.textPxLength > p && B.css({ width: p + \"px\" }), B.getBBox().height > this.len / f.length - (A.h - A.f) && (B.specificTextOverflow = \"ellipsis\");e.rotation && (E = g > .5 * a.chartHeight ? .33 * a.chartHeight : a.chartHeight, k || (z = \"ellipsis\"));if (this.labelAlign = m.align || this.autoLabelAlign(this.labelRotation)) e.align = this.labelAlign;c(f, function (a) {\n          var b = (a = d[a]) && a.label,\n              h = {};b && (b.attr(e), !E || m.style && m.style.width || !(E < b.textPxLength || \"SPAN\" === b.element.tagName) || (h.width = E, k || (h.textOverflow = b.specificTextOverflow || z), b.css(h)), delete b.specificTextOverflow, a.rotation = e.rotation);\n        });this.tickRotCorr = b.rotCorr(A.b, this.labelRotation || 0, 0 !== this.side);\n      }, hasData: function () {\n        return this.hasVisibleSeries || w(this.min) && w(this.max) && this.tickPositions && 0 < this.tickPositions.length;\n      }, addTitle: function (a) {\n        var b = this.chart.renderer,\n            h = this.horiz,\n            c = this.opposite,\n            f = this.options.title,\n            d;this.axisTitle || ((d = f.textAlign) || (d = (h ? { low: \"left\", middle: \"center\", high: \"right\" } : { low: c ? \"right\" : \"left\",\n          middle: \"center\", high: c ? \"left\" : \"right\" })[f.align]), this.axisTitle = b.text(f.text, 0, 0, f.useHTML).attr({ zIndex: 7, rotation: f.rotation || 0, align: d }).addClass(\"highcharts-axis-title\").css(q(f.style)).add(this.axisGroup), this.axisTitle.isNew = !0);f.style.width || this.isRadial || this.axisTitle.css({ width: this.len });this.axisTitle[a ? \"show\" : \"hide\"](!0);\n      }, generateTick: function (a) {\n        var b = this.ticks;b[a] ? b[a].addLabel() : b[a] = new M(this, a);\n      }, getOffset: function () {\n        var a = this,\n            b = a.chart,\n            f = b.renderer,\n            d = a.options,\n            m = a.tickPositions,\n            q = a.ticks,\n            p = a.horiz,\n            n = a.side,\n            e = b.inverted && !a.isZAxis ? [1, 0, 3, 2][n] : n,\n            A,\n            k,\n            E = 0,\n            z,\n            g = 0,\n            x = d.title,\n            G = d.labels,\n            u = 0,\n            l = b.axisOffset,\n            b = b.clipOffset,\n            t = [-1, 1, 1, -1][n],\n            J = d.className,\n            M = a.axisParent,\n            r = this.tickSize(\"tick\");A = a.hasData();a.showAxis = k = A || H(d.showEmpty, !0);a.staggerLines = a.horiz && G.staggerLines;a.axisGroup || (a.gridGroup = f.g(\"grid\").attr({ zIndex: d.gridZIndex || 1 }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (J || \"\")).add(M), a.axisGroup = f.g(\"axis\").attr({ zIndex: d.zIndex || 2 }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (J || \"\")).add(M), a.labelGroup = f.g(\"axis-labels\").attr({ zIndex: G.zIndex || 7 }).addClass(\"highcharts-\" + a.coll.toLowerCase() + \"-labels \" + (J || \"\")).add(M));A || a.isLinked ? (c(m, function (b, f) {\n          a.generateTick(b, f);\n        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === n || 2 === n || { 1: \"left\", 3: \"right\" }[n] === a.labelAlign, H(G.reserveSpace, \"center\" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && c(m, function (a) {\n          u = Math.max(q[a].getLabelSize(), u);\n        }), a.staggerLines && (u *= a.staggerLines), a.labelOffset = u * (a.opposite ? -1 : 1)) : B(q, function (a, b) {\n          a.destroy();delete q[b];\n        });x && x.text && !1 !== x.enabled && (a.addTitle(k), k && !1 !== x.reserveSpace && (a.titleOffset = E = a.axisTitle.getBBox()[p ? \"height\" : \"width\"], z = x.offset, g = w(z) ? 0 : H(x.margin, p ? 5 : 10)));a.renderLine();a.offset = t * H(d.offset, l[n]);a.tickRotCorr = a.tickRotCorr || { x: 0, y: 0 };f = 0 === n ? -a.labelMetrics().h : 2 === n ? a.tickRotCorr.y : 0;g = Math.abs(u) + g;u && (g = g - f + t * (p ? H(G.y, a.tickRotCorr.y + 8 * t) : G.x));a.axisTitleMargin = H(z, g);l[n] = Math.max(l[n], a.axisTitleMargin + E + t * a.offset, g, A && m.length && r ? r[0] + t * a.offset : 0);d = d.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);b[e] = Math.max(b[e], d);\n      }, getLinePath: function (a) {\n        var b = this.chart,\n            f = this.opposite,\n            c = this.offset,\n            h = this.horiz,\n            d = this.left + (f ? this.width : 0) + c,\n            c = b.chartHeight - this.bottom - (f ? this.height : 0) + c;f && (a *= -1);return b.renderer.crispLine([\"M\", h ? this.left : d, h ? c : this.top, \"L\", h ? b.chartWidth - this.right : d, h ? c : b.chartHeight - this.bottom], a);\n      }, renderLine: function () {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.axisLine.attr({ stroke: this.options.lineColor, \"stroke-width\": this.options.lineWidth, zIndex: 7 }));\n      }, getTitlePosition: function () {\n        var a = this.horiz,\n            b = this.left,\n            f = this.top,\n            c = this.len,\n            d = this.options.title,\n            m = a ? b : f,\n            q = this.opposite,\n            p = this.offset,\n            n = d.x || 0,\n            e = d.y || 0,\n            A = this.axisTitle,\n            k = this.chart.renderer.fontMetrics(d.style && d.style.fontSize, A),\n            A = Math.max(A.getBBox(null, 0).height - k.h - 1, 0),\n            c = { low: m + (a ? 0 : c), middle: m + c / 2, high: m + (a ? c : 0) }[d.align],\n            b = (a ? f + this.height : b) + (a ? 1 : -1) * (q ? -1 : 1) * this.axisTitleMargin + [-A, A, k.f, -A][this.side];return { x: a ? c + n : b + (q ? this.width : 0) + p + n, y: a ? b + e - (q ? this.height : 0) + p : c + e };\n      }, renderMinorTick: function (a) {\n        var b = this.chart.hasRendered && z(this.oldMin),\n            f = this.minorTicks;f[a] || (f[a] = new M(this, a, \"minor\"));b && f[a].isNew && f[a].render(null, !0);f[a].render(null, !1, 1);\n      }, renderTick: function (a, b) {\n        var f = this.isLinked,\n            c = this.ticks,\n            d = this.chart.hasRendered && z(this.oldMin);if (!f || a >= this.min && a <= this.max) c[a] || (c[a] = new M(this, a)), d && c[a].isNew && c[a].render(b, !0, .1), c[a].render(b);\n      }, render: function () {\n        var b = this,\n            f = b.chart,\n            d = b.options,\n            m = b.isLog,\n            q = b.isLinked,\n            p = b.tickPositions,\n            n = b.axisTitle,\n            e = b.ticks,\n            E = b.minorTicks,\n            g = b.alternateBands,\n            x = d.stackLabels,\n            G = d.alternateGridColor,\n            u = b.tickmarkOffset,\n            l = b.axisLine,\n            H = b.showAxis,\n            t = F(f.renderer.globalAnimation),\n            J,\n            r;b.labelEdge.length = 0;b.overlap = !1;c([e, E, g], function (a) {\n          B(a, function (a) {\n            a.isActive = !1;\n          });\n        });if (b.hasData() || q) b.minorTickInterval && !b.categories && c(b.getMinorTickPositions(), function (a) {\n          b.renderMinorTick(a);\n        }), p.length && (c(p, function (a, f) {\n          b.renderTick(a, f);\n        }), u && (0 === b.min || b.single) && (e[-1] || (e[-1] = new M(b, -1, null, !0)), e[-1].render(-1))), G && c(p, function (c, d) {\n          r = void 0 !== p[d + 1] ? p[d + 1] + u : b.max - u;0 === d % 2 && c < b.max && r <= b.max + (f.polar ? -u : u) && (g[c] || (g[c] = new a.PlotLineOrBand(b)), J = c + u, g[c].options = { from: m ? b.lin2log(J) : J, to: m ? b.lin2log(r) : r, color: G }, g[c].render(), g[c].isActive = !0);\n        }), b._addedPlotLB || (c((d.plotLines || []).concat(d.plotBands || []), function (a) {\n          b.addPlotBandOrLine(a);\n        }), b._addedPlotLB = !0);c([e, E, g], function (a) {\n          var b,\n              c = [],\n              d = t.duration;B(a, function (a, b) {\n            a.isActive || (a.render(b, !1, 0), a.isActive = !1, c.push(b));\n          });A(function () {\n            for (b = c.length; b--;) a[c[b]] && !a[c[b]].isActive && (a[c[b]].destroy(), delete a[c[b]]);\n          }, a !== g && f.hasRendered && d ? d : 0);\n        });l && (l[l.isPlaced ? \"animate\" : \"attr\"]({ d: this.getLinePath(l.strokeWidth()) }), l.isPlaced = !0, l[H ? \"show\" : \"hide\"](!0));n && H && (d = b.getTitlePosition(), z(d.y) ? (n[n.isNew ? \"attr\" : \"animate\"](d), n.isNew = !1) : (n.attr(\"y\", -9999), n.isNew = !0));x && x.enabled && b.renderStackTotals();b.isDirty = !1;k(this, \"afterRender\");\n      }, redraw: function () {\n        this.visible && (this.render(), c(this.plotLinesAndBands, function (a) {\n          a.render();\n        }));c(this.series, function (a) {\n          a.isDirty = !0;\n        });\n      }, keepProps: \"extKey hcEvents names series userMax userMin\".split(\" \"), destroy: function (a) {\n        var f = this,\n            d = f.stacks,\n            h = f.plotLinesAndBands,\n            q;k(this, \"destroy\", { keepEvents: a });a || m(f);B(d, function (a, b) {\n          u(a);d[b] = null;\n        });c([f.ticks, f.minorTicks, f.alternateBands], function (a) {\n          u(a);\n        });if (h) for (a = h.length; a--;) h[a].destroy();c(\"stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross\".split(\" \"), function (a) {\n          f[a] && (f[a] = f[a].destroy());\n        });for (q in f.plotLinesAndBandsGroups) f.plotLinesAndBandsGroups[q] = f.plotLinesAndBandsGroups[q].destroy();B(f, function (a, c) {\n          -1 === b(c, f.keepProps) && delete f[c];\n        });\n      }, drawCrosshair: function (a, b) {\n        var f,\n            c = this.crosshair,\n            d = H(c.snap, !0),\n            h,\n            m = this.cross;k(this, \"drawCrosshair\", { e: a, point: b });a || (a = this.cross && this.cross.e);if (this.crosshair && !1 !== (w(b) || !d)) {\n          d ? w(b) && (h = H(b.crosshairPos, this.isXAxis ? b.plotX : this.len - b.plotY)) : h = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);w(h) && (f = this.getPlotLinePath(b && (this.isXAxis ? b.x : H(b.stackY, b.y)), null, null, null, h) || null);if (!w(f)) {\n            this.hideCrosshair();return;\n          }d = this.categories && !this.isRadial;m || (this.cross = m = this.chart.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (d ? \"category \" : \"thin \") + c.className).attr({ zIndex: H(c.zIndex, 2) }).add(), m.attr({ stroke: c.color || (d ? g(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"), \"stroke-width\": H(c.width, 1) }).css({ \"pointer-events\": \"none\" }), c.dashStyle && m.attr({ dashstyle: c.dashStyle }));\n          m.show().attr({ d: f });d && !c.width && m.attr({ \"stroke-width\": this.transA });this.cross.e = a;\n        } else this.hideCrosshair();k(this, \"afterDrawCrosshair\", { e: a, point: b });\n      }, hideCrosshair: function () {\n        this.cross && this.cross.hide();\n      } });return a.Axis = G;\n  }(K);(function (a) {\n    var C = a.Axis,\n        F = a.getMagnitude,\n        D = a.normalizeTickInterval,\n        r = a.timeUnits;C.prototype.getTimeTicks = function () {\n      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n    };C.prototype.normalizeTimeTickInterval = function (a, e) {\n      var g = e || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];e = g[g.length - 1];var w = r[e[0]],\n          l = e[1],\n          u;for (u = 0; u < g.length && !(e = g[u], w = r[e[0]], l = e[1], g[u + 1] && a <= (w * l[l.length - 1] + r[g[u + 1][0]]) / 2); u++);w === r.year && a < 5 * w && (l = [1, 2, 5]);a = D(a / w, l, \"year\" === e[0] ? Math.max(F(a / w), 1) : 1);return { unitRange: w, count: a, unitName: e[0] };\n    };\n  })(K);(function (a) {\n    var C = a.Axis,\n        F = a.getMagnitude,\n        D = a.map,\n        r = a.normalizeTickInterval,\n        g = a.pick;C.prototype.getLogTickPositions = function (a, t, w, l) {\n      var e = this.options,\n          c = this.len,\n          d = [];l || (this._minorAutoInterval = null);if (.5 <= a) a = Math.round(a), d = this.getLinearTickPositions(a, t, w);else if (.08 <= a) for (var c = Math.floor(t), k, x, p, f, b, e = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; c < w + 1 && !b; c++) for (x = e.length, k = 0; k < x && !b; k++) p = this.log2lin(this.lin2log(c) * e[k]), p > t && (!l || f <= w) && void 0 !== f && d.push(f), f > w && (b = !0), f = p;else t = this.lin2log(t), w = this.lin2log(w), a = l ? this.getMinorTickInterval() : e.tickInterval, a = g(\"auto\" === a ? null : a, this._minorAutoInterval, e.tickPixelInterval / (l ? 5 : 1) * (w - t) / ((l ? c / this.tickPositions.length : c) || 1)), a = r(a, null, F(a)), d = D(this.getLinearTickPositions(a, t, w), this.log2lin), l || (this._minorAutoInterval = a / 5);l || (this.tickInterval = a);return d;\n    };C.prototype.log2lin = function (a) {\n      return Math.log(a) / Math.LN10;\n    };C.prototype.lin2log = function (a) {\n      return Math.pow(10, a);\n    };\n  })(K);(function (a, C) {\n    var F = a.arrayMax,\n        D = a.arrayMin,\n        r = a.defined,\n        g = a.destroyObjectProperties,\n        e = a.each,\n        t = a.erase,\n        w = a.merge,\n        l = a.pick;a.PlotLineOrBand = function (a, c) {\n      this.axis = a;c && (this.options = c, this.id = c.id);\n    };a.PlotLineOrBand.prototype = { render: function () {\n        var e = this,\n            c = e.axis,\n            d = c.horiz,\n            k = e.options,\n            g = k.label,\n            p = e.label,\n            f = k.to,\n            b = k.from,\n            n = k.value,\n            z = r(b) && r(f),\n            J = r(n),\n            q = e.svgElem,\n            t = !q,\n            B = [],\n            H = k.color,\n            m = l(k.zIndex, 0),\n            E = k.events,\n            B = { \"class\": \"highcharts-plot-\" + (z ? \"band \" : \"line \") + (k.className || \"\") },\n            A = {},\n            M = c.chart.renderer,\n            G = z ? \"bands\" : \"lines\";c.isLog && (b = c.log2lin(b), f = c.log2lin(f), n = c.log2lin(n));J ? (B = { stroke: H, \"stroke-width\": k.width }, k.dashStyle && (B.dashstyle = k.dashStyle)) : z && (H && (B.fill = H), k.borderWidth && (B.stroke = k.borderColor, B[\"stroke-width\"] = k.borderWidth));A.zIndex = m;G += \"-\" + m;(H = c.plotLinesAndBandsGroups[G]) || (c.plotLinesAndBandsGroups[G] = H = M.g(\"plot-\" + G).attr(A).add());t && (e.svgElem = q = M.path().attr(B).add(H));if (J) B = c.getPlotLinePath(n, q.strokeWidth());else if (z) B = c.getPlotBandPath(b, f, k);else return;t && B && B.length ? (q.attr({ d: B }), E && a.objectEach(E, function (a, b) {\n          q.on(b, function (a) {\n            E[b].apply(e, [a]);\n          });\n        })) : q && (B ? (q.show(), q.animate({ d: B })) : (q.hide(), p && (e.label = p = p.destroy())));g && r(g.text) && B && B.length && 0 < c.width && 0 < c.height && !B.flat ? (g = w({ align: d && z && \"center\", x: d ? !z && 4 : 10, verticalAlign: !d && z && \"middle\", y: d ? z ? 16 : 10 : z ? 6 : -4, rotation: d && !z && 90 }, g), this.renderLabel(g, B, z, m)) : p && p.hide();return e;\n      }, renderLabel: function (a, c, d, e) {\n        var k = this.label,\n            p = this.axis.chart.renderer;k || (k = { align: a.textAlign || a.align, rotation: a.rotation, \"class\": \"highcharts-plot-\" + (d ? \"band\" : \"line\") + \"-label \" + (a.className || \"\") }, k.zIndex = e, this.label = k = p.text(a.text, 0, 0, a.useHTML).attr(k).add(), k.css(a.style));e = c.xBounds || [c[1], c[4], d ? c[6] : c[1]];c = c.yBounds || [c[2], c[5], d ? c[7] : c[2]];d = D(e);p = D(c);k.align(a, !1, { x: d, y: p, width: F(e) - d, height: F(c) - p });k.show();\n      }, destroy: function () {\n        t(this.axis.plotLinesAndBands, this);delete this.axis;g(this);\n      } };a.extend(C.prototype, { getPlotBandPath: function (a, c) {\n        var d = this.getPlotLinePath(c, null, null, !0),\n            e = this.getPlotLinePath(a, null, null, !0),\n            g = [],\n            p = this.horiz,\n            f = 1,\n            b;a = a < this.min && c < this.min || a > this.max && c > this.max;if (e && d) for (a && (b = e.toString() === d.toString(), f = 0), a = 0; a < e.length; a += 6) p && d[a + 1] === e[a + 1] ? (d[a + 1] += f, d[a + 4] += f) : p || d[a + 2] !== e[a + 2] || (d[a + 2] += f, d[a + 5] += f), g.push(\"M\", e[a + 1], e[a + 2], \"L\", e[a + 4], e[a + 5], d[a + 4], d[a + 5], d[a + 1], d[a + 2], \"z\"), g.flat = b;return g;\n      }, addPlotBand: function (a) {\n        return this.addPlotBandOrLine(a, \"plotBands\");\n      }, addPlotLine: function (a) {\n        return this.addPlotBandOrLine(a, \"plotLines\");\n      }, addPlotBandOrLine: function (e, c) {\n        var d = new a.PlotLineOrBand(this, e).render(),\n            k = this.userOptions;d && (c && (k[c] = k[c] || [], k[c].push(e)), this.plotLinesAndBands.push(d));return d;\n      }, removePlotBandOrLine: function (a) {\n        for (var c = this.plotLinesAndBands, d = this.options, k = this.userOptions, g = c.length; g--;) c[g].id === a && c[g].destroy();e([d.plotLines || [], k.plotLines || [], d.plotBands || [], k.plotBands || []], function (c) {\n          for (g = c.length; g--;) c[g].id === a && t(c, c[g]);\n        });\n      }, removePlotBand: function (a) {\n        this.removePlotBandOrLine(a);\n      }, removePlotLine: function (a) {\n        this.removePlotBandOrLine(a);\n      } });\n  })(K, V);(function (a) {\n    var C = a.each,\n        F = a.extend,\n        D = a.format,\n        r = a.isNumber,\n        g = a.map,\n        e = a.merge,\n        t = a.pick,\n        w = a.splat,\n        l = a.syncTimeout,\n        u = a.timeUnits;a.Tooltip = function () {\n      this.init.apply(this, arguments);\n    };a.Tooltip.prototype = { init: function (a, d) {\n        this.chart = a;this.options = d;this.crosshairs = [];this.now = { x: 0, y: 0 };this.isHidden = !0;this.split = d.split && !a.inverted;this.shared = d.shared || this.split;\n      }, cleanSplit: function (a) {\n        C(this.chart.series, function (c) {\n          var d = c && c.tt;d && (!d.isActive || a ? c.tt = d.destroy() : d.isActive = !1);\n        });\n      }, getLabel: function () {\n        var a = this.chart.renderer,\n            d = this.options;this.label || (this.split ? this.label = a.g(\"tooltip\") : (this.label = a.label(\"\", 0, 0, d.shape || \"callout\", null, null, d.useHTML, null, \"tooltip\").attr({ padding: d.padding, r: d.borderRadius }), this.label.attr({ fill: d.backgroundColor, \"stroke-width\": d.borderWidth }).css(d.style).shadow(d.shadow)), this.label.attr({ zIndex: 8 }).add());return this.label;\n      }, update: function (a) {\n        this.destroy();e(!0, this.chart.options.tooltip.userOptions, a);this.init(this.chart, e(!0, this.options, a));\n      }, destroy: function () {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());a.clearTimeout(this.hideTimer);a.clearTimeout(this.tooltipTimeout);\n      }, move: function (c, d, e, g) {\n        var p = this,\n            f = p.now,\n            b = !1 !== p.options.animation && !p.isHidden && (1 < Math.abs(c - f.x) || 1 < Math.abs(d - f.y)),\n            n = p.followPointer || 1 < p.len;F(f, { x: b ? (2 * f.x + c) / 3 : c, y: b ? (f.y + d) / 2 : d, anchorX: n ? void 0 : b ? (2 * f.anchorX + e) / 3 : e, anchorY: n ? void 0 : b ? (f.anchorY + g) / 2 : g });p.getLabel().attr(f);b && (a.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          p && p.move(c, d, e, g);\n        }, 32));\n      }, hide: function (c) {\n        var d = this;a.clearTimeout(this.hideTimer);c = t(c, this.options.hideDelay, 500);this.isHidden || (this.hideTimer = l(function () {\n          d.getLabel()[c ? \"fadeOut\" : \"hide\"]();d.isHidden = !0;\n        }, c));\n      }, getAnchor: function (a, d) {\n        var c,\n            e = this.chart,\n            p = e.inverted,\n            f = e.plotTop,\n            b = e.plotLeft,\n            n = 0,\n            z = 0,\n            l,\n            q;a = w(a);c = a[0].tooltipPos;this.followPointer && d && (void 0 === d.chartX && (d = e.pointer.normalize(d)), c = [d.chartX - e.plotLeft, d.chartY - f]);c || (C(a, function (a) {\n          l = a.series.yAxis;q = a.series.xAxis;n += a.plotX + (!p && q ? q.left - b : 0);z += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!p && l ? l.top - f : 0);\n        }), n /= a.length, z /= a.length, c = [p ? e.plotWidth - z : n, this.shared && !p && 1 < a.length && d ? d.chartY - f : p ? e.plotHeight - n : z]);return g(c, Math.round);\n      }, getPosition: function (a, d, e) {\n        var c = this.chart,\n            p = this.distance,\n            f = {},\n            b = c.inverted && e.h || 0,\n            n,\n            g = [\"y\", c.chartHeight, d, e.plotY + c.plotTop, c.plotTop, c.plotTop + c.plotHeight],\n            k = [\"x\", c.chartWidth, a, e.plotX + c.plotLeft, c.plotLeft, c.plotLeft + c.plotWidth],\n            q = !this.followPointer && t(e.ttBelow, !c.inverted === !!e.negative),\n            l = function (a, c, d, m, h, e) {\n          var n = d < m - p,\n              A = m + p + d < c,\n              g = m - p - d;m += p;if (q && A) f[a] = m;else if (!q && n) f[a] = g;else if (n) f[a] = Math.min(e - d, 0 > g - b ? g : g - b);else if (A) f[a] = Math.max(h, m + b + d > c ? m : m + b);else return !1;\n        },\n            B = function (a, b, c, d) {\n          var h;d < p || d > b - p ? h = !1 : f[a] = d < c / 2 ? 1 : d > b - c / 2 ? b - c - 2 : d - c / 2;return h;\n        },\n            H = function (a) {\n          var b = g;g = k;k = b;n = a;\n        },\n            m = function () {\n          !1 !== l.apply(0, g) ? !1 !== B.apply(0, k) || n || (H(!0), m()) : n ? f.x = f.y = 0 : (H(!0), m());\n        };(c.inverted || 1 < this.len) && H();m();return f;\n      }, defaultFormatter: function (a) {\n        var c = this.points || w(this),\n            e;e = [a.tooltipFooterHeaderFormatter(c[0])];e = e.concat(a.bodyFormatter(c));e.push(a.tooltipFooterHeaderFormatter(c[0], !0));return e;\n      }, refresh: function (c, d) {\n        var e,\n            g = this.options,\n            p,\n            f = c,\n            b,\n            n = {},\n            z = [];e = g.formatter || this.defaultFormatter;var n = this.shared,\n            l;g.enabled && (a.clearTimeout(this.hideTimer), this.followPointer = w(f)[0].series.tooltipOptions.followPointer, b = this.getAnchor(f, d), d = b[0], p = b[1], !n || f.series && f.series.noSharedTooltip ? n = f.getLabelConfig() : (C(f, function (a) {\n          a.setState(\"hover\");z.push(a.getLabelConfig());\n        }), n = { x: f[0].category, y: f[0].y }, n.points = z, f = f[0]), this.len = z.length, n = e.call(n, this), l = f.series, this.distance = t(l.tooltipOptions.distance, 16), !1 === n ? this.hide() : (e = this.getLabel(), this.isHidden && e.attr({ opacity: 1 }).show(), this.split ? this.renderSplit(n, w(c)) : (g.style.width || e.css({ width: this.chart.spacingBox.width }), e.attr({ text: n && n.join ? n.join(\"\") : n }), e.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + t(f.colorIndex, l.colorIndex)), e.attr({ stroke: g.borderColor || f.color || l.color || \"#666666\" }), this.updatePosition({ plotX: d, plotY: p, negative: f.negative, ttBelow: f.ttBelow, h: b[2] || 0 })), this.isHidden = !1));\n      }, renderSplit: function (c, d) {\n        var e = this,\n            g = [],\n            p = this.chart,\n            f = p.renderer,\n            b = !0,\n            n = this.options,\n            z = 0,\n            l = this.getLabel();a.isString(c) && (c = [!1, c]);C(c.slice(0, d.length + 1), function (a, c) {\n          if (!1 !== a) {\n            c = d[c - 1] || { isHeader: !0, plotX: d[0].plotX };var q = c.series || e,\n                k = q.tt,\n                m = c.series || {},\n                E = \"highcharts-color-\" + t(c.colorIndex, m.colorIndex, \"none\");k || (q.tt = k = f.label(null, null, null, \"callout\", null, null, n.useHTML).addClass(\"highcharts-tooltip-box \" + E).attr({ padding: n.padding, r: n.borderRadius, fill: n.backgroundColor, stroke: n.borderColor || c.color || m.color || \"#333333\", \"stroke-width\": n.borderWidth }).add(l));k.isActive = !0;k.attr({ text: a });k.css(n.style).shadow(n.shadow);a = k.getBBox();m = a.width + k.strokeWidth();c.isHeader ? (z = a.height, m = Math.max(0, Math.min(c.plotX + p.plotLeft - m / 2, p.chartWidth - m))) : m = c.plotX + p.plotLeft - t(n.distance, 16) - m;0 > m && (b = !1);a = (c.series && c.series.yAxis && c.series.yAxis.pos) + (c.plotY || 0);a -= p.plotTop;g.push({ target: c.isHeader ? p.plotHeight + z : a, rank: c.isHeader ? 1 : 0, size: q.tt.getBBox().height + 1, point: c, x: m, tt: k });\n          }\n        });this.cleanSplit();a.distribute(g, p.plotHeight + z);C(g, function (a) {\n          var c = a.point,\n              f = c.series;a.tt.attr({ visibility: void 0 === a.pos ? \"hidden\" : \"inherit\", x: b || c.isHeader ? a.x : c.plotX + p.plotLeft + t(n.distance, 16), y: a.pos + p.plotTop, anchorX: c.isHeader ? c.plotX + p.plotLeft : c.plotX + f.xAxis.pos, anchorY: c.isHeader ? a.pos + p.plotTop - 15 : c.plotY + f.yAxis.pos });\n        });\n      }, updatePosition: function (a) {\n        var c = this.chart,\n            e = this.getLabel(),\n            e = (this.options.positioner || this.getPosition).call(this, e.width, e.height, a);this.move(Math.round(e.x), Math.round(e.y || 0), a.plotX + c.plotLeft, a.plotY + c.plotTop);\n      }, getDateFormat: function (a, d, e, g) {\n        var c = this.chart.time,\n            f = c.dateFormat(\"%m-%d %H:%M:%S.%L\", d),\n            b,\n            n,\n            k = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 },\n            l = \"millisecond\";for (n in u) {\n          if (a === u.week && +c.dateFormat(\"%w\", d) === e && \"00:00:00.000\" === f.substr(6)) {\n            n = \"week\";break;\n          }if (u[n] > a) {\n            n = l;break;\n          }if (k[n] && f.substr(k[n]) !== \"01-01 00:00:00.000\".substr(k[n])) break;\"week\" !== n && (l = n);\n        }n && (b = g[n]);return b;\n      }, getXDateFormat: function (a, d, e) {\n        d = d.dateTimeLabelFormats;var c = e && e.closestPointRange;return (c ? this.getDateFormat(c, a.x, e.options.startOfWeek, d) : d.day) || d.year;\n      }, tooltipFooterHeaderFormatter: function (a, d) {\n        d = d ? \"footer\" : \"header\";var c = a.series,\n            e = c.tooltipOptions,\n            p = e.xDateFormat,\n            f = c.xAxis,\n            b = f && \"datetime\" === f.options.type && r(a.key),\n            n = e[d + \"Format\"];b && !p && (p = this.getXDateFormat(a, e, f));b && p && C(a.point && a.point.tooltipDateKeys || [\"key\"], function (a) {\n          n = n.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + p + \"}\");\n        });return D(n, { point: a, series: c }, this.chart.time);\n      }, bodyFormatter: function (a) {\n        return g(a, function (a) {\n          var c = a.series.tooltipOptions;return (c[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, c[(a.point.formatPrefix || \"point\") + \"Format\"]);\n        });\n      } };\n  })(K);(function (a) {\n    var C = a.addEvent,\n        F = a.attr,\n        D = a.charts,\n        r = a.color,\n        g = a.css,\n        e = a.defined,\n        t = a.each,\n        w = a.extend,\n        l = a.find,\n        u = a.fireEvent,\n        c = a.isNumber,\n        d = a.isObject,\n        k = a.offset,\n        x = a.pick,\n        p = a.splat,\n        f = a.Tooltip;a.Pointer = function (a, c) {\n      this.init(a, c);\n    };a.Pointer.prototype = { init: function (a, c) {\n        this.options = c;this.chart = a;this.runChartClick = c.chart.events && !!c.chart.events.click;this.pinchDown = [];this.lastValidTouch = {};f && (a.tooltip = new f(a, c.tooltip), this.followTouchMove = x(c.tooltip.followTouchMove, !0));this.setDOMEvents();\n      }, zoomOption: function (a) {\n        var b = this.chart,\n            c = b.options.chart,\n            f = c.zoomType || \"\",\n            b = b.inverted;/touch/.test(a.type) && (f = x(c.pinchType, f));this.zoomX = a = /x/.test(f);this.zoomY = f = /y/.test(f);this.zoomHor = a && !b || f && b;this.zoomVert = f && !b || a && b;this.hasZoom = a || f;\n      }, normalize: function (a, c) {\n        var b;b = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;c || (this.chartPosition = c = k(this.chart.container));return w(a, { chartX: Math.round(b.pageX - c.left), chartY: Math.round(b.pageY - c.top) });\n      }, getCoordinates: function (a) {\n        var b = { xAxis: [], yAxis: [] };t(this.chart.axes, function (c) {\n          b[c.isXAxis ? \"xAxis\" : \"yAxis\"].push({ axis: c, value: c.toValue(a[c.horiz ? \"chartX\" : \"chartY\"]) });\n        });return b;\n      }, findNearestKDPoint: function (a, c, f) {\n        var b;t(a, function (a) {\n          var e = !(a.noSharedTooltip && c) && 0 > a.options.findNearestPointBy.indexOf(\"y\");a = a.searchPoint(f, e);if ((e = d(a, !0)) && !(e = !d(b, !0))) var e = b.distX - a.distX,\n              p = b.dist - a.dist,\n              q = (a.series.group && a.series.group.zIndex) - (b.series.group && b.series.group.zIndex),\n              e = 0 < (0 !== e && c ? e : 0 !== p ? p : 0 !== q ? q : b.series.index > a.series.index ? -1 : 1);e && (b = a);\n        });return b;\n      }, getPointFromEvent: function (a) {\n        a = a.target;for (var b; a && !b;) b = a.point, a = a.parentNode;return b;\n      }, getChartCoordinatesFromPoint: function (a, c) {\n        var b = a.series,\n            f = b.xAxis,\n            b = b.yAxis,\n            d = x(a.clientX, a.plotX),\n            e = a.shapeArgs;if (f && b) return c ? { chartX: f.len + f.pos - d, chartY: b.len + b.pos - a.plotY } : { chartX: d + f.pos, chartY: a.plotY + b.pos };if (e && e.x && e.y) return { chartX: e.x, chartY: e.y };\n      }, getHoverData: function (b, c, f, e, p, g, k) {\n        var q,\n            m = [],\n            n = k && k.isBoosting;e = !(!e || !b);k = c && !c.stickyTracking ? [c] : a.grep(f, function (a) {\n          return a.visible && !(!p && a.directTouch) && x(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });c = (q = e ? b : this.findNearestKDPoint(k, p, g)) && q.series;q && (p && !c.noSharedTooltip ? (k = a.grep(f, function (a) {\n          return a.visible && !(!p && a.directTouch) && x(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), t(k, function (a) {\n          var b = l(a.points, function (a) {\n            return a.x === q.x && !a.isNull;\n          });d(b) && (n && (b = a.getPoint(b)), m.push(b));\n        })) : m.push(q));return { hoverPoint: q, hoverSeries: c, hoverPoints: m };\n      }, runPointActions: function (b, c) {\n        var f = this.chart,\n            d = f.tooltip && f.tooltip.options.enabled ? f.tooltip : void 0,\n            e = d ? d.shared : !1,\n            p = c || f.hoverPoint,\n            n = p && p.series || f.hoverSeries,\n            n = this.getHoverData(p, n, f.series, !!c || n && n.directTouch && this.isDirectTouch, e, b, { isBoosting: f.isBoosting }),\n            g,\n            p = n.hoverPoint;g = n.hoverPoints;c = (n = n.hoverSeries) && n.tooltipOptions.followPointer;e = e && n && !n.noSharedTooltip;if (p && (p !== f.hoverPoint || d && d.isHidden)) {\n          t(f.hoverPoints || [], function (b) {\n            -1 === a.inArray(b, g) && b.setState();\n          });t(g || [], function (a) {\n            a.setState(\"hover\");\n          });if (f.hoverSeries !== n) n.onMouseOver();f.hoverPoint && f.hoverPoint.firePointEvent(\"mouseOut\");if (!p.series) return;p.firePointEvent(\"mouseOver\");f.hoverPoints = g;f.hoverPoint = p;d && d.refresh(e ? g : p, b);\n        } else c && d && !d.isHidden && (p = d.getAnchor([{}], b), d.updatePosition({ plotX: p[0], plotY: p[1] }));this.unDocMouseMove || (this.unDocMouseMove = C(f.container.ownerDocument, \"mousemove\", function (b) {\n          var c = D[a.hoverChartIndex];if (c) c.pointer.onDocumentMouseMove(b);\n        }));t(f.axes, function (c) {\n          var f = x(c.crosshair.snap, !0),\n              d = f ? a.find(g, function (a) {\n            return a.series[c.coll] === c;\n          }) : void 0;d || !f ? c.drawCrosshair(b, d) : c.hideCrosshair();\n        });\n      }, reset: function (a, c) {\n        var b = this.chart,\n            f = b.hoverSeries,\n            d = b.hoverPoint,\n            e = b.hoverPoints,\n            n = b.tooltip,\n            g = n && n.shared ? e : d;\n        a && g && t(p(g), function (b) {\n          b.series.isCartesian && void 0 === b.plotX && (a = !1);\n        });if (a) n && g && (n.refresh(g), d && (d.setState(d.state, !0), t(b.axes, function (a) {\n          a.crosshair && a.drawCrosshair(null, d);\n        })));else {\n          if (d) d.onMouseOut();e && t(e, function (a) {\n            a.setState();\n          });if (f) f.onMouseOut();n && n.hide(c);this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());t(b.axes, function (a) {\n            a.hideCrosshair();\n          });this.hoverX = b.hoverPoints = b.hoverPoint = null;\n        }\n      }, scaleGroups: function (a, c) {\n        var b = this.chart,\n            f;t(b.series, function (d) {\n          f = a || d.getPlotBox();d.xAxis && d.xAxis.zoomEnabled && d.group && (d.group.attr(f), d.markerGroup && (d.markerGroup.attr(f), d.markerGroup.clip(c ? b.clipRect : null)), d.dataLabelsGroup && d.dataLabelsGroup.attr(f));\n        });b.clipRect.attr(c || b.clipBox);\n      }, dragStart: function (a) {\n        var b = this.chart;b.mouseIsDown = a.type;b.cancelClick = !1;b.mouseDownX = this.mouseDownX = a.chartX;b.mouseDownY = this.mouseDownY = a.chartY;\n      }, drag: function (a) {\n        var b = this.chart,\n            c = b.options.chart,\n            f = a.chartX,\n            d = a.chartY,\n            e = this.zoomHor,\n            p = this.zoomVert,\n            g = b.plotLeft,\n            m = b.plotTop,\n            k = b.plotWidth,\n            A = b.plotHeight,\n            l,\n            G = this.selectionMarker,\n            h = this.mouseDownX,\n            v = this.mouseDownY,\n            t = c.panKey && a[c.panKey + \"Key\"];G && G.touch || (f < g ? f = g : f > g + k && (f = g + k), d < m ? d = m : d > m + A && (d = m + A), this.hasDragged = Math.sqrt(Math.pow(h - f, 2) + Math.pow(v - d, 2)), 10 < this.hasDragged && (l = b.isInsidePlot(h - g, v - m), b.hasCartesianSeries && (this.zoomX || this.zoomY) && l && !t && !G && (this.selectionMarker = G = b.renderer.rect(g, m, e ? 1 : k, p ? 1 : A, 0).attr({ fill: c.selectionMarkerFill || r(\"#335cad\").setOpacity(.25).get(), \"class\": \"highcharts-selection-marker\",\n          zIndex: 7 }).add()), G && e && (f -= h, G.attr({ width: Math.abs(f), x: (0 < f ? 0 : f) + h })), G && p && (f = d - v, G.attr({ height: Math.abs(f), y: (0 < f ? 0 : f) + v })), l && !G && c.panning && b.pan(a, c.panning)));\n      }, drop: function (a) {\n        var b = this,\n            f = this.chart,\n            d = this.hasPinched;if (this.selectionMarker) {\n          var p = { originalEvent: a, xAxis: [], yAxis: [] },\n              k = this.selectionMarker,\n              B = k.attr ? k.attr(\"x\") : k.x,\n              l = k.attr ? k.attr(\"y\") : k.y,\n              m = k.attr ? k.attr(\"width\") : k.width,\n              E = k.attr ? k.attr(\"height\") : k.height,\n              A;if (this.hasDragged || d) t(f.axes, function (c) {\n            if (c.zoomEnabled && e(c.min) && (d || b[{ xAxis: \"zoomX\", yAxis: \"zoomY\" }[c.coll]])) {\n              var f = c.horiz,\n                  h = \"touchend\" === a.type ? c.minPixelPadding : 0,\n                  g = c.toValue((f ? B : l) + h),\n                  f = c.toValue((f ? B + m : l + E) - h);p[c.coll].push({ axis: c, min: Math.min(g, f), max: Math.max(g, f) });A = !0;\n            }\n          }), A && u(f, \"selection\", p, function (a) {\n            f.zoom(w(a, d ? { animation: !1 } : null));\n          });c(f.index) && (this.selectionMarker = this.selectionMarker.destroy());d && this.scaleGroups();\n        }f && c(f.index) && (g(f.container, { cursor: f._cursor }), f.cancelClick = 10 < this.hasDragged, f.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      }, onContainerMouseDown: function (a) {\n        a = this.normalize(a);2 !== a.button && (this.zoomOption(a), a.preventDefault && a.preventDefault(), this.dragStart(a));\n      }, onDocumentMouseUp: function (b) {\n        D[a.hoverChartIndex] && D[a.hoverChartIndex].pointer.drop(b);\n      }, onDocumentMouseMove: function (a) {\n        var b = this.chart,\n            c = this.chartPosition;a = this.normalize(a, c);!c || this.inClass(a.target, \"highcharts-tracker\") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset();\n      }, onContainerMouseLeave: function (b) {\n        var c = D[a.hoverChartIndex];c && (b.relatedTarget || b.toElement) && (c.pointer.reset(), c.pointer.chartPosition = null);\n      }, onContainerMouseMove: function (b) {\n        var c = this.chart;e(a.hoverChartIndex) && D[a.hoverChartIndex] && D[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = c.index);b = this.normalize(b);b.returnValue = !1;\"mousedown\" === c.mouseIsDown && this.drag(b);!this.inClass(b.target, \"highcharts-tracker\") && !c.isInsidePlot(b.chartX - c.plotLeft, b.chartY - c.plotTop) || c.openMenu || this.runPointActions(b);\n      }, inClass: function (a, c) {\n        for (var b; a;) {\n          if (b = F(a, \"class\")) {\n            if (-1 !== b.indexOf(c)) return !0;if (-1 !== b.indexOf(\"highcharts-container\")) return !1;\n          }a = a.parentNode;\n        }\n      }, onTrackerMouseOut: function (a) {\n        var b = this.chart.hoverSeries;a = a.relatedTarget || a.toElement;this.isDirectTouch = !1;if (!(!b || !a || b.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + b.index) && this.inClass(a, \"highcharts-tracker\"))) b.onMouseOut();\n      }, onContainerClick: function (a) {\n        var b = this.chart,\n            c = b.hoverPoint,\n            f = b.plotLeft,\n            d = b.plotTop;a = this.normalize(a);b.cancelClick || (c && this.inClass(a.target, \"highcharts-tracker\") ? (u(c.series, \"click\", w(a, { point: c })), b.hoverPoint && c.firePointEvent(\"click\", a)) : (w(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - f, a.chartY - d) && u(b, \"click\", a)));\n      }, setDOMEvents: function () {\n        var b = this,\n            c = b.chart.container,\n            f = c.ownerDocument;c.onmousedown = function (a) {\n          b.onContainerMouseDown(a);\n        };c.onmousemove = function (a) {\n          b.onContainerMouseMove(a);\n        };c.onclick = function (a) {\n          b.onContainerClick(a);\n        };this.unbindContainerMouseLeave = C(c, \"mouseleave\", b.onContainerMouseLeave);\n        a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = C(f, \"mouseup\", b.onDocumentMouseUp));a.hasTouch && (c.ontouchstart = function (a) {\n          b.onContainerTouchStart(a);\n        }, c.ontouchmove = function (a) {\n          b.onContainerTouchMove(a);\n        }, a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = C(f, \"touchend\", b.onDocumentTouchEnd)));\n      }, destroy: function () {\n        var b = this;b.unDocMouseMove && b.unDocMouseMove();this.unbindContainerMouseLeave();a.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));clearInterval(b.tooltipTimeout);a.objectEach(b, function (a, c) {\n          b[c] = null;\n        });\n      } };\n  })(K);(function (a) {\n    var C = a.charts,\n        F = a.each,\n        D = a.extend,\n        r = a.map,\n        g = a.noop,\n        e = a.pick;D(a.Pointer.prototype, { pinchTranslate: function (a, e, g, r, c, d) {\n        this.zoomHor && this.pinchTranslateDirection(!0, a, e, g, r, c, d);this.zoomVert && this.pinchTranslateDirection(!1, a, e, g, r, c, d);\n      }, pinchTranslateDirection: function (a, e, g, r, c, d, k, x) {\n        var p = this.chart,\n            f = a ? \"x\" : \"y\",\n            b = a ? \"X\" : \"Y\",\n            n = \"chart\" + b,\n            l = a ? \"width\" : \"height\",\n            t = p[\"plot\" + (a ? \"Left\" : \"Top\")],\n            q,\n            u,\n            B = x || 1,\n            H = p.inverted,\n            m = p.bounds[a ? \"h\" : \"v\"],\n            E = 1 === e.length,\n            A = e[0][n],\n            M = g[0][n],\n            G = !E && e[1][n],\n            h = !E && g[1][n],\n            v;g = function () {\n          !E && 20 < Math.abs(A - G) && (B = x || Math.abs(M - h) / Math.abs(A - G));u = (t - M) / B + A;q = p[\"plot\" + (a ? \"Width\" : \"Height\")] / B;\n        };g();e = u;e < m.min ? (e = m.min, v = !0) : e + q > m.max && (e = m.max - q, v = !0);v ? (M -= .8 * (M - k[f][0]), E || (h -= .8 * (h - k[f][1])), g()) : k[f] = [M, h];H || (d[f] = u - t, d[l] = q);d = H ? 1 / B : B;c[l] = q;c[f] = e;r[H ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + b] = B;r[\"translate\" + b] = d * t + (M - d * A);\n      }, pinch: function (a) {\n        var t = this,\n            l = t.chart,\n            u = t.pinchDown,\n            c = a.touches,\n            d = c.length,\n            k = t.lastValidTouch,\n            x = t.hasZoom,\n            p = t.selectionMarker,\n            f = {},\n            b = 1 === d && (t.inClass(a.target, \"highcharts-tracker\") && l.runTrackerClick || t.runChartClick),\n            n = {};1 < d && (t.initiated = !0);x && t.initiated && !b && a.preventDefault();r(c, function (a) {\n          return t.normalize(a);\n        });\"touchstart\" === a.type ? (F(c, function (a, b) {\n          u[b] = { chartX: a.chartX, chartY: a.chartY };\n        }), k.x = [u[0].chartX, u[1] && u[1].chartX], k.y = [u[0].chartY, u[1] && u[1].chartY], F(l.axes, function (a) {\n          if (a.zoomEnabled) {\n            var b = l.bounds[a.horiz ? \"h\" : \"v\"],\n                c = a.minPixelPadding,\n                f = a.toPixels(e(a.options.min, a.dataMin)),\n                d = a.toPixels(e(a.options.max, a.dataMax)),\n                p = Math.max(f, d);b.min = Math.min(a.pos, Math.min(f, d) - c);b.max = Math.max(a.pos + a.len, p + c);\n          }\n        }), t.res = !0) : t.followTouchMove && 1 === d ? this.runPointActions(t.normalize(a)) : u.length && (p || (t.selectionMarker = p = D({ destroy: g, touch: !0 }, l.plotBox)), t.pinchTranslate(u, c, f, p, n, k), t.hasPinched = x, t.scaleGroups(f, n), t.res && (t.res = !1, this.reset(!1, 0)));\n      }, touch: function (g, r) {\n        var l = this.chart,\n            t,\n            c;\n        if (l.index !== a.hoverChartIndex) this.onContainerMouseLeave({ relatedTarget: !0 });a.hoverChartIndex = l.index;1 === g.touches.length ? (g = this.normalize(g), (c = l.isInsidePlot(g.chartX - l.plotLeft, g.chartY - l.plotTop)) && !l.openMenu ? (r && this.runPointActions(g), \"touchmove\" === g.type && (r = this.pinchDown, t = r[0] ? 4 <= Math.sqrt(Math.pow(r[0].chartX - g.chartX, 2) + Math.pow(r[0].chartY - g.chartY, 2)) : !1), e(t, !0) && this.pinch(g)) : r && this.reset()) : 2 === g.touches.length && this.pinch(g);\n      }, onContainerTouchStart: function (a) {\n        this.zoomOption(a);\n        this.touch(a, !0);\n      }, onContainerTouchMove: function (a) {\n        this.touch(a);\n      }, onDocumentTouchEnd: function (e) {\n        C[a.hoverChartIndex] && C[a.hoverChartIndex].pointer.drop(e);\n      } });\n  })(K);(function (a) {\n    var C = a.addEvent,\n        F = a.charts,\n        D = a.css,\n        r = a.doc,\n        g = a.extend,\n        e = a.noop,\n        t = a.Pointer,\n        w = a.removeEvent,\n        l = a.win,\n        u = a.wrap;if (!a.hasTouch && (l.PointerEvent || l.MSPointerEvent)) {\n      var c = {},\n          d = !!l.PointerEvent,\n          k = function () {\n        var d = [];d.item = function (a) {\n          return this[a];\n        };a.objectEach(c, function (a) {\n          d.push({ pageX: a.pageX, pageY: a.pageY, target: a.target });\n        });\n        return d;\n      },\n          x = function (c, f, b, d) {\n        \"touch\" !== c.pointerType && c.pointerType !== c.MSPOINTER_TYPE_TOUCH || !F[a.hoverChartIndex] || (d(c), d = F[a.hoverChartIndex].pointer, d[f]({ type: b, target: c.currentTarget, preventDefault: e, touches: k() }));\n      };g(t.prototype, { onContainerPointerDown: function (a) {\n          x(a, \"onContainerTouchStart\", \"touchstart\", function (a) {\n            c[a.pointerId] = { pageX: a.pageX, pageY: a.pageY, target: a.currentTarget };\n          });\n        }, onContainerPointerMove: function (a) {\n          x(a, \"onContainerTouchMove\", \"touchmove\", function (a) {\n            c[a.pointerId] = { pageX: a.pageX,\n              pageY: a.pageY };c[a.pointerId].target || (c[a.pointerId].target = a.currentTarget);\n          });\n        }, onDocumentPointerUp: function (a) {\n          x(a, \"onDocumentTouchEnd\", \"touchend\", function (a) {\n            delete c[a.pointerId];\n          });\n        }, batchMSEvents: function (a) {\n          a(this.chart.container, d ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);a(this.chart.container, d ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);a(r, d ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n        } });u(t.prototype, \"init\", function (a, c, b) {\n        a.call(this, c, b);this.hasZoom && D(c.container, { \"-ms-touch-action\": \"none\", \"touch-action\": \"none\" });\n      });u(t.prototype, \"setDOMEvents\", function (a) {\n        a.apply(this);(this.hasZoom || this.followTouchMove) && this.batchMSEvents(C);\n      });u(t.prototype, \"destroy\", function (a) {\n        this.batchMSEvents(w);a.call(this);\n      });\n    }\n  })(K);(function (a) {\n    var C = a.addEvent,\n        F = a.css,\n        D = a.discardElement,\n        r = a.defined,\n        g = a.each,\n        e = a.fireEvent,\n        t = a.isFirefox,\n        w = a.marginNames,\n        l = a.merge,\n        u = a.pick,\n        c = a.setAnimation,\n        d = a.stableSort,\n        k = a.win,\n        x = a.wrap;a.Legend = function (a, c) {\n      this.init(a, c);\n    };a.Legend.prototype = { init: function (a, c) {\n        this.chart = a;this.setOptions(c);c.enabled && (this.render(), C(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }));\n      }, setOptions: function (a) {\n        var c = u(a.padding, 8);this.options = a;this.itemStyle = a.itemStyle;this.itemHiddenStyle = l(this.itemStyle, a.itemHiddenStyle);this.itemMarginTop = a.itemMarginTop || 0;this.padding = c;this.initialItemY = c - 5;this.symbolWidth = u(a.symbolWidth, 16);this.pages = [];\n      }, update: function (a, c) {\n        var b = this.chart;this.setOptions(l(!0, this.options, a));this.destroy();\n        b.isDirtyLegend = b.isDirtyBox = !0;u(c, !0) && b.redraw();e(this, \"afterUpdate\");\n      }, colorizeItem: function (a, c) {\n        a.legendGroup[c ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");var b = this.options,\n            f = a.legendItem,\n            d = a.legendLine,\n            g = a.legendSymbol,\n            p = this.itemHiddenStyle.color,\n            b = c ? b.itemStyle.color : p,\n            k = c ? a.color || p : p,\n            B = a.options && a.options.marker,\n            l = { fill: k };f && f.css({ fill: b, color: b });d && d.attr({ stroke: k });g && (B && g.isMarker && (l = a.pointAttribs(), c || (l.stroke = l.fill = p)), g.attr(l));e(this, \"afterColorizeItem\", { item: a, visible: c });\n      }, positionItem: function (a) {\n        var c = this.options,\n            b = c.symbolPadding,\n            c = !c.rtl,\n            d = a._legendItemPos,\n            e = d[0],\n            d = d[1],\n            g = a.checkbox;(a = a.legendGroup) && a.element && a.translate(c ? e : this.legendWidth - e - 2 * b - 4, d);g && (g.x = e, g.y = d);\n      }, destroyItem: function (a) {\n        var c = a.checkbox;g([\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"], function (b) {\n          a[b] && (a[b] = a[b].destroy());\n        });c && D(a.checkbox);\n      }, destroy: function () {\n        function a(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }g(this.getAllItems(), function (c) {\n          g([\"legendItem\", \"legendGroup\"], a, c);\n        });g(\"clipRect up down pager nav box title group\".split(\" \"), a, this);this.display = null;\n      }, positionCheckboxes: function () {\n        var a = this.group && this.group.alignAttr,\n            c,\n            b = this.clipHeight || this.legendHeight,\n            d = this.titleHeight;a && (c = a.translateY, g(this.allItems, function (f) {\n          var e = f.checkbox,\n              g;e && (g = c + d + e.y + (this.scrollOffset || 0) + 3, F(e, { left: a.translateX + f.checkboxOffset + e.x - 20 + \"px\", top: g + \"px\", display: g > c - 6 && g < c + b - 6 ? \"\" : \"none\" }));\n        }, this));\n      }, renderTitle: function () {\n        var a = this.options,\n            c = this.padding,\n            b = a.title,\n            d = 0;b.text && (this.title || (this.title = this.chart.renderer.label(b.text, c - 3, c - 4, null, null, null, a.useHTML, null, \"legend-title\").attr({ zIndex: 1 }).css(b.style).add(this.group)), a = this.title.getBBox(), d = a.height, this.offsetWidth = a.width, this.contentGroup.attr({ translateY: d }));this.titleHeight = d;\n      }, setText: function (c) {\n        var d = this.options;c.legendItem.attr({ text: d.labelFormat ? a.format(d.labelFormat, c, this.chart.time) : d.labelFormatter.call(c) });\n      }, renderItem: function (a) {\n        var c = this.chart,\n            b = c.renderer,\n            d = this.options,\n            e = this.symbolWidth,\n            g = d.symbolPadding,\n            q = this.itemStyle,\n            k = this.itemHiddenStyle,\n            p = \"horizontal\" === d.layout ? u(d.itemDistance, 20) : 0,\n            t = !d.rtl,\n            m = a.legendItem,\n            E = !a.series,\n            A = !E && a.series.drawLegendSymbol ? a.series : a,\n            x = A.options,\n            x = this.createCheckboxForItem && x && x.showCheckbox,\n            p = e + g + p + (x ? 20 : 0),\n            G = d.useHTML,\n            h = a.options.className;m || (a.legendGroup = b.g(\"legend-item\").addClass(\"highcharts-\" + A.type + \"-series highcharts-color-\" + a.colorIndex + (h ? \" \" + h : \"\") + (E ? \" highcharts-series-\" + a.index : \"\")).attr({ zIndex: 1 }).add(this.scrollGroup), a.legendItem = m = b.text(\"\", t ? e + g : -g, this.baseline || 0, G).css(l(a.visible ? q : k)).attr({ align: t ? \"left\" : \"right\", zIndex: 2 }).add(a.legendGroup), this.baseline || (e = q.fontSize, this.fontMetrics = b.fontMetrics(e, m), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, m.attr(\"y\", this.baseline)), this.symbolHeight = d.symbolHeight || this.fontMetrics.f, A.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, m, G), x && this.createCheckboxForItem(a));this.colorizeItem(a, a.visible);q.width || m.css({ width: (d.itemWidth || d.width || c.spacingBox.width) - p });this.setText(a);c = m.getBBox();a.itemWidth = a.checkboxOffset = d.itemWidth || a.legendItemWidth || c.width + p;this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);this.totalItemWidth += a.itemWidth;this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || c.height || this.symbolHeight);\n      }, layoutItem: function (a) {\n        var c = this.options,\n            b = this.padding,\n            d = \"horizontal\" === c.layout,\n            e = a.itemHeight,\n            g = c.itemMarginBottom || 0,\n            q = this.itemMarginTop,\n            k = d ? u(c.itemDistance, 20) : 0,\n            p = c.width,\n            l = p || this.chart.spacingBox.width - 2 * b - c.x,\n            c = c.alignColumns && this.totalItemWidth > l ? this.maxItemWidth : a.itemWidth;d && this.itemX - b + c > l && (this.itemX = b, this.itemY += q + this.lastLineHeight + g, this.lastLineHeight = 0);this.lastItemY = q + this.itemY + g;this.lastLineHeight = Math.max(e, this.lastLineHeight);a._legendItemPos = [this.itemX, this.itemY];d ? this.itemX += c : (this.itemY += q + e + g, this.lastLineHeight = e);this.offsetWidth = p || Math.max((d ? this.itemX - b - (a.checkbox ? 0 : k) : c) + b, this.offsetWidth);\n      }, getAllItems: function () {\n        var a = [];g(this.chart.series, function (c) {\n          var b = c && c.options;c && u(b.showInLegend, r(b.linkedTo) ? !1 : void 0, !0) && (a = a.concat(c.legendItems || (\"point\" === b.legendType ? c.data : c)));\n        });e(this, \"afterGetAllItems\", { allItems: a });return a;\n      }, getAlignment: function () {\n        var a = this.options;return a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      }, adjustMargins: function (a, c) {\n        var b = this.chart,\n            d = this.options,\n            f = this.getAlignment();f && g([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function (e, g) {\n          e.test(f) && !r(a[g]) && (b[w[g]] = Math.max(b[w[g]], b.legend[(g + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][g] * d[g % 2 ? \"x\" : \"y\"] + u(d.margin, 12) + c[g] + (0 === g && void 0 !== b.options.title.margin ? b.titleOffset + b.options.title.margin : 0)));\n        });\n      }, render: function () {\n        var a = this.chart,\n            c = a.renderer,\n            b = this.group,\n            e,\n            k,\n            x,\n            q,\n            t = this.box,\n            B = this.options,\n            r = this.padding;this.itemX = r;this.itemY = this.initialItemY;this.lastItemY = this.offsetWidth = 0;b || (this.group = b = c.g(\"legend\").attr({ zIndex: 7 }).add(), this.contentGroup = c.g().attr({ zIndex: 1 }).add(b), this.scrollGroup = c.g().add(this.contentGroup));\n        this.renderTitle();e = this.getAllItems();d(e, function (a, b) {\n          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);\n        });B.reversed && e.reverse();this.allItems = e;this.display = k = !!e.length;this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;g(e, this.renderItem, this);g(e, this.layoutItem, this);x = (B.width || this.offsetWidth) + r;q = this.lastItemY + this.lastLineHeight + this.titleHeight;q = this.handleOverflow(q);q += r;t || (this.box = t = c.rect().addClass(\"highcharts-legend-box\").attr({ r: B.borderRadius }).add(b), t.isNew = !0);t.attr({ stroke: B.borderColor, \"stroke-width\": B.borderWidth || 0, fill: B.backgroundColor || \"none\" }).shadow(B.shadow);0 < x && 0 < q && (t[t.isNew ? \"attr\" : \"animate\"](t.crisp.call({}, { x: 0, y: 0, width: x, height: q }, t.strokeWidth())), t.isNew = !1);t[k ? \"show\" : \"hide\"]();this.legendWidth = x;this.legendHeight = q;g(e, this.positionItem, this);k && (c = a.spacingBox, /(lth|ct|rth)/.test(this.getAlignment()) && (c = l(c, { y: c.y + a.titleOffset + a.options.title.margin })), b.align(l(B, { width: x, height: q }), !0, c));a.isResizing || this.positionCheckboxes();\n      },\n      handleOverflow: function (a) {\n        var c = this,\n            b = this.chart,\n            d = b.renderer,\n            e = this.options,\n            k = e.y,\n            q = this.padding,\n            b = b.spacingBox.height + (\"top\" === e.verticalAlign ? -k : k) - q,\n            k = e.maxHeight,\n            p,\n            l = this.clipRect,\n            t = e.navigation,\n            m = u(t.animation, !0),\n            E = t.arrowSize || 12,\n            A = this.nav,\n            x = this.pages,\n            G,\n            h = this.allItems,\n            v = function (a) {\n          \"number\" === typeof a ? l.attr({ height: a }) : l && (c.clipRect = l.destroy(), c.contentGroup.clip());c.contentGroup.div && (c.contentGroup.div.style.clip = a ? \"rect(\" + q + \"px,9999px,\" + (q + a) + \"px,0)\" : \"auto\");\n        };\"horizontal\" !== e.layout || \"middle\" === e.verticalAlign || e.floating || (b /= 2);k && (b = Math.min(b, k));x.length = 0;a > b && !1 !== t.enabled ? (this.clipHeight = p = Math.max(b - 20 - this.titleHeight - q, 0), this.currentPage = u(this.currentPage, 1), this.fullHeight = a, g(h, function (a, b) {\n          var c = a._legendItemPos[1],\n              d = Math.round(a.legendItem.getBBox().height),\n              f = x.length;if (!f || c - x[f - 1] > p && (G || c) !== x[f - 1]) x.push(G || c), f++;a.pageIx = f - 1;G && (h[b - 1].pageIx = f - 1);b === h.length - 1 && c + d - x[f - 1] > p && (x.push(c), a.pageIx = f);c !== G && (G = c);\n        }), l || (l = c.clipRect = d.clipRect(0, q, 9999, 0), c.contentGroup.clip(l)), v(p), A || (this.nav = A = d.g().attr({ zIndex: 1 }).add(this.group), this.up = d.symbol(\"triangle\", 0, 0, E, E).on(\"click\", function () {\n          c.scroll(-1, m);\n        }).add(A), this.pager = d.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\").css(t.style).add(A), this.down = d.symbol(\"triangle-down\", 0, 0, E, E).on(\"click\", function () {\n          c.scroll(1, m);\n        }).add(A)), c.scroll(0), a = b) : A && (v(), this.nav = A.destroy(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0);return a;\n      }, scroll: function (a, d) {\n        var b = this.pages,\n            f = b.length;a = this.currentPage + a;var e = this.clipHeight,\n            g = this.options.navigation,\n            k = this.pager,\n            p = this.padding;a > f && (a = f);0 < a && (void 0 !== d && c(d, this.chart), this.nav.attr({ translateX: p, translateY: e + this.padding + 7 + this.titleHeight, visibility: \"visible\" }), this.up.attr({ \"class\": 1 === a ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\" }), k.attr({ text: a + \"/\" + f }), this.down.attr({ x: 18 + this.pager.getBBox().width, \"class\": a === f ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\" }), this.up.attr({ fill: 1 === a ? g.inactiveColor : g.activeColor }).css({ cursor: 1 === a ? \"default\" : \"pointer\" }), this.down.attr({ fill: a === f ? g.inactiveColor : g.activeColor }).css({ cursor: a === f ? \"default\" : \"pointer\" }), this.scrollOffset = -b[a - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: this.scrollOffset }), this.currentPage = a, this.positionCheckboxes());\n      } };a.LegendSymbolMixin = { drawRectangle: function (a, c) {\n        var b = a.symbolHeight,\n            d = a.options.squareSymbol;c.legendSymbol = this.chart.renderer.rect(d ? (a.symbolWidth - b) / 2 : 0, a.baseline - b + 1, d ? b : a.symbolWidth, b, u(a.options.symbolRadius, b / 2)).addClass(\"highcharts-point\").attr({ zIndex: 3 }).add(c.legendGroup);\n      }, drawLineMarker: function (a) {\n        var c = this.options,\n            b = c.marker,\n            d = a.symbolWidth,\n            e = a.symbolHeight,\n            g = e / 2,\n            k = this.chart.renderer,\n            p = this.legendGroup;a = a.baseline - Math.round(.3 * a.fontMetrics.b);var B;B = { \"stroke-width\": c.lineWidth || 0 };c.dashStyle && (B.dashstyle = c.dashStyle);this.legendLine = k.path([\"M\", 0, a, \"L\", d, a]).addClass(\"highcharts-graph\").attr(B).add(p);b && !1 !== b.enabled && (c = Math.min(u(b.radius, g), g), 0 === this.symbol.indexOf(\"url\") && (b = l(b, { width: e, height: e }), c = 0), this.legendSymbol = b = k.symbol(this.symbol, d / 2 - c, a - c, 2 * c, 2 * c, b).addClass(\"highcharts-point\").add(p), b.isMarker = !0);\n      } };(/Trident\\/7\\.0/.test(k.navigator.userAgent) || t) && x(a.Legend.prototype, \"positionItem\", function (a, c) {\n      var b = this,\n          d = function () {\n        c._legendItemPos && a.call(b, c);\n      };d();setTimeout(d);\n    });\n  })(K);(function (a) {\n    var C = a.addEvent,\n        F = a.animate,\n        D = a.animObject,\n        r = a.attr,\n        g = a.doc,\n        e = a.Axis,\n        t = a.createElement,\n        w = a.defaultOptions,\n        l = a.discardElement,\n        u = a.charts,\n        c = a.css,\n        d = a.defined,\n        k = a.each,\n        x = a.extend,\n        p = a.find,\n        f = a.fireEvent,\n        b = a.grep,\n        n = a.isNumber,\n        z = a.isObject,\n        J = a.isString,\n        q = a.Legend,\n        L = a.marginNames,\n        B = a.merge,\n        H = a.objectEach,\n        m = a.Pointer,\n        E = a.pick,\n        A = a.pInt,\n        M = a.removeEvent,\n        G = a.seriesTypes,\n        h = a.splat,\n        v = a.syncTimeout,\n        Q = a.win,\n        P = a.Chart = function () {\n      this.getArgs.apply(this, arguments);\n    };a.chart = function (a, b, c) {\n      return new P(a, b, c);\n    };x(P.prototype, { callbacks: [], getArgs: function () {\n        var a = [].slice.call(arguments);if (J(a[0]) || a[0].nodeName) this.renderTo = a.shift();this.init(a[0], a[1]);\n      }, init: function (b, c) {\n        var d,\n            h,\n            m = b.series,\n            e = b.plotOptions || {};f(this, \"init\", { args: arguments }, function () {\n          b.series = null;d = B(w, b);for (h in d.plotOptions) d.plotOptions[h].tooltip = e[h] && B(e[h].tooltip) || void 0;d.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;d.series = b.series = m;this.userOptions = b;var g = d.chart,\n              k = g.events;this.margin = [];this.spacing = [];this.bounds = { h: {}, v: {} };this.labelCollectors = [];this.callback = c;this.isResizing = 0;this.options = d;this.axes = [];this.series = [];this.time = b.time && a.keys(b.time).length ? new a.Time(b.time) : a.time;this.hasCartesianSeries = g.showAxes;var A = this;A.index = u.length;u.push(A);a.chartCount++;k && H(k, function (a, b) {\n            C(A, b, a);\n          });A.xAxis = [];A.yAxis = [];A.pointCount = A.colorCounter = A.symbolCounter = 0;f(A, \"afterInit\");A.firstRender();\n        });\n      }, initSeries: function (b) {\n        var c = this.options.chart;(c = G[b.type || c.type || c.defaultSeriesType]) || a.error(17, !0);c = new c();c.init(this, b);return c;\n      }, orderSeries: function (a) {\n        var b = this.series;for (a = a || 0; a < b.length; a++) b[a] && (b[a].index = a, b[a].name = b[a].getName());\n      },\n      isInsidePlot: function (a, b, c) {\n        var d = c ? b : a;a = c ? a : b;return 0 <= d && d <= this.plotWidth && 0 <= a && a <= this.plotHeight;\n      }, redraw: function (b) {\n        f(this, \"beforeRedraw\");var c = this.axes,\n            d = this.series,\n            h = this.pointer,\n            m = this.legend,\n            e = this.isDirtyLegend,\n            g,\n            A,\n            q = this.hasCartesianSeries,\n            p = this.isDirtyBox,\n            E,\n            v = this.renderer,\n            n = v.isHidden(),\n            l = [];this.setResponsive && this.setResponsive(!1);a.setAnimation(b, this);n && this.temporaryDisplay();this.layOutTitles();for (b = d.length; b--;) if (E = d[b], E.options.stacking && (g = !0, E.isDirty)) {\n          A = !0;\n          break;\n        }if (A) for (b = d.length; b--;) E = d[b], E.options.stacking && (E.isDirty = !0);k(d, function (a) {\n          a.isDirty && \"point\" === a.options.legendType && (a.updateTotals && a.updateTotals(), e = !0);a.isDirtyData && f(a, \"updatedData\");\n        });e && m.options.enabled && (m.render(), this.isDirtyLegend = !1);g && this.getStacks();q && k(c, function (a) {\n          a.updateNames();a.setScale();\n        });this.getMargins();q && (k(c, function (a) {\n          a.isDirty && (p = !0);\n        }), k(c, function (a) {\n          var b = a.min + \",\" + a.max;a.extKey !== b && (a.extKey = b, l.push(function () {\n            f(a, \"afterSetExtremes\", x(a.eventArgs, a.getExtremes()));delete a.eventArgs;\n          }));(p || g) && a.redraw();\n        }));p && this.drawChartBox();f(this, \"predraw\");k(d, function (a) {\n          (p || a.isDirty) && a.visible && a.redraw();a.isDirtyData = !1;\n        });h && h.reset(!0);v.draw();f(this, \"redraw\");f(this, \"render\");n && this.temporaryDisplay(!0);k(l, function (a) {\n          a.call();\n        });\n      }, get: function (a) {\n        function b(b) {\n          return b.id === a || b.options && b.options.id === a;\n        }var c,\n            d = this.series,\n            f;c = p(this.axes, b) || p(this.series, b);for (f = 0; !c && f < d.length; f++) c = p(d[f].points || [], b);return c;\n      }, getAxes: function () {\n        var a = this,\n            b = this.options,\n            c = b.xAxis = h(b.xAxis || {}),\n            b = b.yAxis = h(b.yAxis || {});f(this, \"getAxes\");k(c, function (a, b) {\n          a.index = b;a.isX = !0;\n        });k(b, function (a, b) {\n          a.index = b;\n        });c = c.concat(b);k(c, function (b) {\n          new e(a, b);\n        });f(this, \"afterGetAxes\");\n      }, getSelectedPoints: function () {\n        var a = [];k(this.series, function (c) {\n          a = a.concat(b(c.data || [], function (a) {\n            return a.selected;\n          }));\n        });return a;\n      }, getSelectedSeries: function () {\n        return b(this.series, function (a) {\n          return a.selected;\n        });\n      }, setTitle: function (a, b, c) {\n        var d = this,\n            f = d.options,\n            h;h = f.title = B({ style: { color: \"#333333\",\n            fontSize: f.isStock ? \"16px\" : \"18px\" } }, f.title, a);f = f.subtitle = B({ style: { color: \"#666666\" } }, f.subtitle, b);k([[\"title\", a, h], [\"subtitle\", b, f]], function (a, b) {\n          var c = a[0],\n              f = d[c],\n              h = a[1];a = a[2];f && h && (d[c] = f = f.destroy());a && !f && (d[c] = d.renderer.text(a.text, 0, 0, a.useHTML).attr({ align: a.align, \"class\": \"highcharts-\" + c, zIndex: a.zIndex || 4 }).add(), d[c].update = function (a) {\n            d.setTitle(!b && a, b && a);\n          }, d[c].css(a.style));\n        });d.layOutTitles(c);\n      }, layOutTitles: function (a) {\n        var b = 0,\n            c,\n            d = this.renderer,\n            f = this.spacingBox;k([\"title\", \"subtitle\"], function (a) {\n          var c = this[a],\n              h = this.options[a];a = \"title\" === a ? -3 : h.verticalAlign ? 0 : b + 2;var m;c && (m = h.style.fontSize, m = d.fontMetrics(m, c).b, c.css({ width: (h.width || f.width + h.widthAdjust) + \"px\" }).align(x({ y: a + m }, h), !1, \"spacingBox\"), h.floating || h.verticalAlign || (b = Math.ceil(b + c.getBBox(h.useHTML).height)));\n        }, this);c = this.titleOffset !== b;this.titleOffset = b;!this.isDirtyBox && c && (this.isDirtyBox = this.isDirtyLegend = c, this.hasRendered && E(a, !0) && this.isDirtyBox && this.redraw());\n      }, getChartSize: function () {\n        var b = this.options.chart,\n            c = b.width,\n            b = b.height,\n            f = this.renderTo;d(c) || (this.containerWidth = a.getStyle(f, \"width\"));d(b) || (this.containerHeight = a.getStyle(f, \"height\"));this.chartWidth = Math.max(0, c || this.containerWidth || 600);this.chartHeight = Math.max(0, a.relativeLength(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      }, temporaryDisplay: function (b) {\n        var c = this.renderTo;if (b) for (; c && c.style;) c.hcOrigStyle && (a.css(c, c.hcOrigStyle), delete c.hcOrigStyle), c.hcOrigDetached && (g.body.removeChild(c), c.hcOrigDetached = !1), c = c.parentNode;else for (; c && c.style;) {\n          g.body.contains(c) || c.parentNode || (c.hcOrigDetached = !0, g.body.appendChild(c));if (\"none\" === a.getStyle(c, \"display\", !1) || c.hcOricDetached) c.hcOrigStyle = { display: c.style.display, height: c.style.height, overflow: c.style.overflow }, b = { display: \"block\", overflow: \"hidden\" }, c !== this.renderTo && (b.height = 0), a.css(c, b), c.offsetWidth || c.style.setProperty(\"display\", \"block\", \"important\");c = c.parentNode;if (c === g.body) break;\n        }\n      }, setClassName: function (a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      }, getContainer: function () {\n        var b,\n            c = this.options,\n            d = c.chart,\n            h,\n            m;b = this.renderTo;var e = a.uniqueKey(),\n            k;b || (this.renderTo = b = d.renderTo);J(b) && (this.renderTo = b = g.getElementById(b));b || a.error(13, !0);h = A(r(b, \"data-highcharts-chart\"));n(h) && u[h] && u[h].hasRendered && u[h].destroy();r(b, \"data-highcharts-chart\", this.index);b.innerHTML = \"\";d.skipClone || b.offsetWidth || this.temporaryDisplay();this.getChartSize();h = this.chartWidth;m = this.chartHeight;k = x({ position: \"relative\", overflow: \"hidden\", width: h + \"px\", height: m + \"px\", textAlign: \"left\", lineHeight: \"normal\", zIndex: 0, \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\" }, d.style);this.container = b = t(\"div\", { id: e }, k, b);this._cursor = b.style.cursor;this.renderer = new (a[d.renderer] || a.Renderer)(b, h, m, null, d.forExport, c.exporting && c.exporting.allowHTML);this.setClassName(d.className);this.renderer.setStyle(d.style);this.renderer.chartIndex = this.index;f(this, \"afterGetContainer\");\n      }, getMargins: function (a) {\n        var b = this.spacing,\n            c = this.margin,\n            f = this.titleOffset;this.resetMargins();f && !d(c[0]) && (this.plotTop = Math.max(this.plotTop, f + this.options.title.margin + b[0]));this.legend && this.legend.display && this.legend.adjustMargins(c, b);this.extraMargin && (this[this.extraMargin.type] = (this[this.extraMargin.type] || 0) + this.extraMargin.value);this.adjustPlotArea && this.adjustPlotArea();a || this.getAxisMargins();\n      }, getAxisMargins: function () {\n        var a = this,\n            b = a.axisOffset = [0, 0, 0, 0],\n            c = a.margin;a.hasCartesianSeries && k(a.axes, function (a) {\n          a.visible && a.getOffset();\n        });k(L, function (f, h) {\n          d(c[h]) || (a[f] += b[h]);\n        });\n        a.setChartSize();\n      }, reflow: function (b) {\n        var c = this,\n            f = c.options.chart,\n            h = c.renderTo,\n            m = d(f.width) && d(f.height),\n            e = f.width || a.getStyle(h, \"width\"),\n            f = f.height || a.getStyle(h, \"height\"),\n            h = b ? b.target : Q;if (!m && !c.isPrinting && e && f && (h === Q || h === g)) {\n          if (e !== c.containerWidth || f !== c.containerHeight) a.clearTimeout(c.reflowTimeout), c.reflowTimeout = v(function () {\n            c.container && c.setSize(void 0, void 0, !1);\n          }, b ? 100 : 0);c.containerWidth = e;c.containerHeight = f;\n        }\n      }, setReflow: function (a) {\n        var b = this;!1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = C(Q, \"resize\", function (a) {\n          b.reflow(a);\n        }), C(this, \"destroy\", this.unbindReflow));\n      }, setSize: function (b, d, h) {\n        var m = this,\n            e = m.renderer;m.isResizing += 1;a.setAnimation(h, m);m.oldChartHeight = m.chartHeight;m.oldChartWidth = m.chartWidth;void 0 !== b && (m.options.chart.width = b);void 0 !== d && (m.options.chart.height = d);m.getChartSize();b = e.globalAnimation;(b ? F : c)(m.container, { width: m.chartWidth + \"px\", height: m.chartHeight + \"px\" }, b);m.setChartSize(!0);e.setSize(m.chartWidth, m.chartHeight, h);k(m.axes, function (a) {\n          a.isDirty = !0;a.setScale();\n        });m.isDirtyLegend = !0;m.isDirtyBox = !0;m.layOutTitles();m.getMargins();m.redraw(h);m.oldChartHeight = null;f(m, \"resize\");v(function () {\n          m && f(m, \"endResize\", null, function () {\n            --m.isResizing;\n          });\n        }, D(b).duration);\n      }, setChartSize: function (a) {\n        var b = this.inverted,\n            c = this.renderer,\n            d = this.chartWidth,\n            h = this.chartHeight,\n            m = this.options.chart,\n            e = this.spacing,\n            g = this.clipOffset,\n            A,\n            q,\n            p,\n            E;this.plotLeft = A = Math.round(this.plotLeft);this.plotTop = q = Math.round(this.plotTop);\n        this.plotWidth = p = Math.max(0, Math.round(d - A - this.marginRight));this.plotHeight = E = Math.max(0, Math.round(h - q - this.marginBottom));this.plotSizeX = b ? E : p;this.plotSizeY = b ? p : E;this.plotBorderWidth = m.plotBorderWidth || 0;this.spacingBox = c.spacingBox = { x: e[3], y: e[0], width: d - e[3] - e[1], height: h - e[0] - e[2] };this.plotBox = c.plotBox = { x: A, y: q, width: p, height: E };d = 2 * Math.floor(this.plotBorderWidth / 2);b = Math.ceil(Math.max(d, g[3]) / 2);c = Math.ceil(Math.max(d, g[0]) / 2);this.clipBox = { x: b, y: c, width: Math.floor(this.plotSizeX - Math.max(d, g[1]) / 2 - b), height: Math.max(0, Math.floor(this.plotSizeY - Math.max(d, g[2]) / 2 - c)) };a || k(this.axes, function (a) {\n          a.setAxisSize();a.setAxisTranslation();\n        });f(this, \"afterSetChartSize\", { skipAxes: a });\n      }, resetMargins: function () {\n        var a = this,\n            b = a.options.chart;k([\"margin\", \"spacing\"], function (c) {\n          var d = b[c],\n              f = z(d) ? d : [d, d, d, d];k([\"Top\", \"Right\", \"Bottom\", \"Left\"], function (d, h) {\n            a[c][h] = E(b[c + d], f[h]);\n          });\n        });k(L, function (b, c) {\n          a[b] = E(a.margin[c], a.spacing[c]);\n        });a.axisOffset = [0, 0, 0, 0];a.clipOffset = [0, 0, 0, 0];\n      }, drawChartBox: function () {\n        var a = this.options.chart,\n            b = this.renderer,\n            c = this.chartWidth,\n            d = this.chartHeight,\n            h = this.chartBackground,\n            m = this.plotBackground,\n            e = this.plotBorder,\n            g,\n            A = this.plotBGImage,\n            k = a.backgroundColor,\n            q = a.plotBackgroundColor,\n            p = a.plotBackgroundImage,\n            E,\n            v = this.plotLeft,\n            n = this.plotTop,\n            l = this.plotWidth,\n            G = this.plotHeight,\n            B = this.plotBox,\n            x = this.clipRect,\n            t = this.clipBox,\n            r = \"animate\";h || (this.chartBackground = h = b.rect().addClass(\"highcharts-background\").add(), r = \"attr\");g = a.borderWidth || 0;E = g + (a.shadow ? 8 : 0);k = { fill: k || \"none\" };if (g || h[\"stroke-width\"]) k.stroke = a.borderColor, k[\"stroke-width\"] = g;h.attr(k).shadow(a.shadow);h[r]({ x: E / 2, y: E / 2, width: c - E - g % 2, height: d - E - g % 2, r: a.borderRadius });r = \"animate\";m || (r = \"attr\", this.plotBackground = m = b.rect().addClass(\"highcharts-plot-background\").add());m[r](B);m.attr({ fill: q || \"none\" }).shadow(a.plotShadow);p && (A ? A.animate(B) : this.plotBGImage = b.image(p, v, n, l, G).add());x ? x.animate({ width: t.width, height: t.height }) : this.clipRect = b.clipRect(t);r = \"animate\";e || (r = \"attr\", this.plotBorder = e = b.rect().addClass(\"highcharts-plot-border\").attr({ zIndex: 1 }).add());\n        e.attr({ stroke: a.plotBorderColor, \"stroke-width\": a.plotBorderWidth || 0, fill: \"none\" });e[r](e.crisp({ x: v, y: n, width: l, height: G }, -e.strokeWidth()));this.isDirtyBox = !1;f(this, \"afterDrawChartBox\");\n      }, propFromSeries: function () {\n        var a = this,\n            b = a.options.chart,\n            c,\n            d = a.options.series,\n            f,\n            h;k([\"inverted\", \"angular\", \"polar\"], function (m) {\n          c = G[b.type || b.defaultSeriesType];h = b[m] || c && c.prototype[m];for (f = d && d.length; !h && f--;) (c = G[d[f].type]) && c.prototype[m] && (h = !0);a[m] = h;\n        });\n      }, linkSeries: function () {\n        var a = this,\n            b = a.series;k(b, function (a) {\n          a.linkedSeries.length = 0;\n        });k(b, function (b) {\n          var c = b.options.linkedTo;J(c) && (c = \":previous\" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), b.linkedParent = c, b.visible = E(b.options.visible, c.options.visible, b.visible));\n        });f(this, \"afterLinkSeries\");\n      }, renderSeries: function () {\n        k(this.series, function (a) {\n          a.translate();a.render();\n        });\n      }, renderLabels: function () {\n        var a = this,\n            b = a.options.labels;b.items && k(b.items, function (c) {\n          var d = x(b.style, c.style),\n              f = A(d.left) + a.plotLeft,\n              h = A(d.top) + a.plotTop + 12;delete d.left;delete d.top;\n          a.renderer.text(c.html, f, h).attr({ zIndex: 2 }).css(d).add();\n        });\n      }, render: function () {\n        var a = this.axes,\n            b = this.renderer,\n            c = this.options,\n            d,\n            f,\n            h;this.setTitle();this.legend = new q(this, c.legend);this.getStacks && this.getStacks();this.getMargins(!0);this.setChartSize();c = this.plotWidth;d = this.plotHeight = Math.max(this.plotHeight - 21, 0);k(a, function (a) {\n          a.setScale();\n        });this.getAxisMargins();f = 1.1 < c / this.plotWidth;h = 1.05 < d / this.plotHeight;if (f || h) k(a, function (a) {\n          (a.horiz && f || !a.horiz && h) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();this.hasCartesianSeries && k(a, function (a) {\n          a.visible && a.render();\n        });this.seriesGroup || (this.seriesGroup = b.g(\"series-group\").attr({ zIndex: 3 }).add());this.renderSeries();this.renderLabels();this.addCredits();this.setResponsive && this.setResponsive();this.hasRendered = !0;\n      }, addCredits: function (a) {\n        var b = this;a = B(!0, this.options.credits, a);a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          a.href && (Q.location.href = a.href);\n        }).attr({ align: a.position.align, zIndex: 8 }).css(a.style).add().align(a.position), this.credits.update = function (a) {\n          b.credits = b.credits.destroy();b.addCredits(a);\n        });\n      }, destroy: function () {\n        var b = this,\n            c = b.axes,\n            d = b.series,\n            h = b.container,\n            m,\n            e = h && h.parentNode;f(b, \"destroy\");b.renderer.forExport ? a.erase(u, b) : u[b.index] = void 0;a.chartCount--;b.renderTo.removeAttribute(\"data-highcharts-chart\");M(b);for (m = c.length; m--;) c[m] = c[m].destroy();this.scroller && this.scroller.destroy && this.scroller.destroy();\n        for (m = d.length; m--;) d[m] = d[m].destroy();k(\"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \"), function (a) {\n          var c = b[a];c && c.destroy && (b[a] = c.destroy());\n        });h && (h.innerHTML = \"\", M(h), e && l(h));H(b, function (a, c) {\n          delete b[c];\n        });\n      }, firstRender: function () {\n        var a = this,\n            b = a.options;if (!a.isReadyToRender || a.isReadyToRender()) {\n          a.getContainer();a.resetMargins();a.setChartSize();a.propFromSeries();a.getAxes();\n          k(b.series || [], function (b) {\n            a.initSeries(b);\n          });a.linkSeries();f(a, \"beforeRender\");m && (a.pointer = new m(a, b));a.render();if (!a.renderer.imgCount && a.onload) a.onload();a.temporaryDisplay(!0);\n        }\n      }, onload: function () {\n        k([this.callback].concat(this.callbacks), function (a) {\n          a && void 0 !== this.index && a.apply(this, [this]);\n        }, this);f(this, \"load\");f(this, \"render\");d(this.index) && this.setReflow(this.options.chart.reflow);this.onload = null;\n      } });\n  })(K);(function (a) {\n    var C = a.addEvent,\n        F = a.Chart,\n        D = a.each;C(F, \"afterSetChartSize\", function (r) {\n      var g = this.options.chart.scrollablePlotArea;if (g = g && g.minWidth) if (this.scrollablePixels = g = Math.max(0, g - this.chartWidth)) this.plotWidth += g, this.clipBox.width += g, r.skipAxes || D(this.axes, function (e) {\n        1 === e.side ? e.getPlotLinePath = function () {\n          var g = this.right,\n              r;this.right = g - e.chart.scrollablePixels;r = a.Axis.prototype.getPlotLinePath.apply(this, arguments);this.right = g;return r;\n        } : (e.setAxisSize(), e.setAxisTranslation());\n      });\n    });C(F, \"render\", function () {\n      this.scrollablePixels ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });F.prototype.setUpScrolling = function () {\n      this.scrollingContainer = a.createElement(\"div\", { className: \"highcharts-scrolling\" }, { overflowX: \"auto\", WebkitOverflowScrolling: \"touch\" }, this.renderTo);this.innerContainer = a.createElement(\"div\", { className: \"highcharts-inner-container\" }, null, this.scrollingContainer);this.innerContainer.appendChild(this.container);this.setUpScrolling = null;\n    };F.prototype.applyFixed = function () {\n      var r = this.container,\n          g,\n          e;this.fixedDiv || (this.fixedDiv = a.createElement(\"div\", { className: \"highcharts-fixed\" }, { position: \"absolute\", overflow: \"hidden\", pointerEvents: \"none\", zIndex: 2 }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.fixedRenderer = g = new a.Renderer(this.fixedDiv, 0, 0), this.scrollableMask = g.path().attr({ fill: a.color(this.options.chart.backgroundColor || \"#fff\").setOpacity(.85).get(), zIndex: -1 }).addClass(\"highcharts-scrollable-mask\").add(), a.each([this.inverted ? \".highcharts-xaxis\" : \".highcharts-yaxis\", this.inverted ? \".highcharts-xaxis-labels\" : \".highcharts-yaxis-labels\", \".highcharts-contextbutton\", \".highcharts-credits\", \".highcharts-legend\", \".highcharts-subtitle\", \".highcharts-title\"], function (e) {\n        a.each(r.querySelectorAll(e), function (a) {\n          g.box.appendChild(a);a.style.pointerEvents = \"auto\";\n        });\n      }));this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);e = this.chartWidth + this.scrollablePixels;this.container.style.width = e + \"px\";this.renderer.boxWrapper.attr({ width: e, height: this.chartHeight, viewBox: [0, 0, e, this.chartHeight].join(\" \") });\n      e = this.options.chart.scrollablePlotArea;e.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixels * e.scrollPositionX);var t = this.axisOffset;e = this.plotTop - t[0] - 1;var t = this.plotTop + this.plotHeight + t[2],\n          w = this.plotLeft + this.plotWidth - this.scrollablePixels;this.scrollableMask.attr({ d: this.scrollablePixels ? [\"M\", 0, e, \"L\", this.plotLeft - 1, e, \"L\", this.plotLeft - 1, t, \"L\", 0, t, \"Z\", \"M\", w, e, \"L\", this.chartWidth, e, \"L\", this.chartWidth, t, \"L\", w, t, \"Z\"] : [\"M\", 0, 0] });\n    };\n  })(K);(function (a) {\n    var C,\n        F = a.each,\n        D = a.extend,\n        r = a.erase,\n        g = a.fireEvent,\n        e = a.format,\n        t = a.isArray,\n        w = a.isNumber,\n        l = a.pick,\n        u = a.removeEvent;a.Point = C = function () {};a.Point.prototype = { init: function (a, d, e) {\n        this.series = a;this.color = a.color;this.applyOptions(d, e);a.options.colorByPoint ? (d = a.options.colors || a.chart.options.colors, this.color = this.color || d[a.colorCounter], d = d.length, e = a.colorCounter, a.colorCounter++, a.colorCounter === d && (a.colorCounter = 0)) : e = a.colorIndex;this.colorIndex = l(this.colorIndex, e);a.chart.pointCount++;g(this, \"afterInit\");return this;\n      },\n      applyOptions: function (a, d) {\n        var c = this.series,\n            e = c.options.pointValKey || c.pointValKey;a = C.prototype.optionsToObject.call(this, a);D(this, a);this.options = this.options ? D(this.options, a) : a;a.group && delete this.group;e && (this.y = this[e]);this.isNull = l(this.isValid && !this.isValid(), null === this.x || !w(this.y, !0));this.selected && (this.state = \"select\");\"name\" in this && void 0 === d && c.xAxis && c.xAxis.hasNames && (this.x = c.xAxis.nameToX(this));void 0 === this.x && c && (this.x = void 0 === d ? c.autoIncrement(this) : d);return this;\n      },\n      setNestedProperty: function (c, d, e) {\n        e = e.split(\".\");a.reduce(e, function (c, e, f, b) {\n          c[e] = b.length - 1 === f ? d : a.isObject(c[e], !0) ? c[e] : {};return c[e];\n        }, c);return c;\n      }, optionsToObject: function (c) {\n        var d = {},\n            e = this.series,\n            g = e.options.keys,\n            p = g || e.pointArrayMap || [\"y\"],\n            f = p.length,\n            b = 0,\n            n = 0;if (w(c) || null === c) d[p[0]] = c;else if (t(c)) for (!g && c.length > f && (e = typeof c[0], \"string\" === e ? d.name = c[0] : \"number\" === e && (d.x = c[0]), b++); n < f;) g && void 0 === c[b] || (0 < p[n].indexOf(\".\") ? a.Point.prototype.setNestedProperty(d, c[b], p[n]) : d[p[n]] = c[b]), b++, n++;else \"object\" === typeof c && (d = c, c.dataLabels && (e._hasPointLabels = !0), c.marker && (e._hasPointMarkers = !0));return d;\n      }, getClassName: function () {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      }, getZone: function () {\n        var a = this.series,\n            d = a.zones,\n            a = a.zoneAxis || \"y\",\n            e = 0,\n            g;for (g = d[e]; this[a] >= g.value;) g = d[++e];this.nonZonedColor || (this.nonZonedColor = this.color);this.color = g && g.color && !this.options.color ? g.color : this.nonZonedColor;return g;\n      }, destroy: function () {\n        var a = this.series.chart,\n            d = a.hoverPoints,\n            e;a.pointCount--;d && (this.setState(), r(d, this), d.length || (a.hoverPoints = null));if (this === a.hoverPoint) this.onMouseOut();if (this.graphic || this.dataLabel) u(this), this.destroyElements();this.legendItem && a.legend.destroyItem(this);for (e in this) this[e] = null;\n      }, destroyElements: function () {\n        for (var a = [\"graphic\", \"dataLabel\", \"dataLabelUpper\", \"connector\", \"shadowGroup\"], d, e = 6; e--;) d = a[e], this[d] && (this[d] = this[d].destroy());\n      }, getLabelConfig: function () {\n        return { x: this.category, y: this.y, color: this.color, colorIndex: this.colorIndex, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal };\n      }, tooltipFormatter: function (a) {\n        var c = this.series,\n            g = c.tooltipOptions,\n            t = l(g.valueDecimals, \"\"),\n            p = g.valuePrefix || \"\",\n            f = g.valueSuffix || \"\";F(c.pointArrayMap || [\"y\"], function (b) {\n          b = \"{point.\" + b;if (p || f) a = a.replace(RegExp(b + \"}\", \"g\"), p + b + \"}\" + f);a = a.replace(RegExp(b + \"}\", \"g\"), b + \":,.\" + t + \"f}\");\n        });return e(a, { point: this, series: this.series }, c.chart.time);\n      }, firePointEvent: function (a, d, e) {\n        var c = this,\n            k = this.series.options;(k.point.events[a] || c.options && c.options.events && c.options.events[a]) && this.importEvents();\"click\" === a && k.allowPointSelect && (e = function (a) {\n          c.select && c.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });g(this, a, d, e);\n      }, visible: !0 };\n  })(K);(function (a) {\n    var C = a.addEvent,\n        F = a.animObject,\n        D = a.arrayMax,\n        r = a.arrayMin,\n        g = a.correctFloat,\n        e = a.defaultOptions,\n        t = a.defaultPlotOptions,\n        w = a.defined,\n        l = a.each,\n        u = a.erase,\n        c = a.extend,\n        d = a.fireEvent,\n        k = a.grep,\n        x = a.isArray,\n        p = a.isNumber,\n        f = a.isString,\n        b = a.merge,\n        n = a.objectEach,\n        z = a.pick,\n        J = a.removeEvent,\n        q = a.splat,\n        L = a.SVGElement,\n        B = a.syncTimeout,\n        H = a.win;a.Series = a.seriesType(\"line\", null, { lineWidth: 2, allowPointSelect: !1, showCheckbox: !1, animation: { duration: 1E3 }, events: {},\n      marker: { lineWidth: 0, lineColor: \"#ffffff\", enabledThreshold: 2, radius: 4, states: { normal: { animation: !0 }, hover: { animation: { duration: 50 }, enabled: !0, radiusPlus: 2, lineWidthPlus: 1 }, select: { fillColor: \"#cccccc\", lineColor: \"#000000\", lineWidth: 2 } } }, point: { events: {} }, dataLabels: { align: \"center\", formatter: function () {\n          return null === this.y ? \"\" : a.numberFormat(this.y, -1);\n        }, style: { fontSize: \"11px\", fontWeight: \"bold\", color: \"contrast\", textOutline: \"1px contrast\" }, verticalAlign: \"bottom\", x: 0, y: 0, padding: 5 }, cropThreshold: 300, pointRange: 0,\n      softThreshold: !0, states: { normal: { animation: !0 }, hover: { animation: { duration: 50 }, lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: .25 } }, select: { marker: {} } }, stickyTracking: !0, turboThreshold: 1E3, findNearestPointBy: \"x\" }, { isCartesian: !0, pointClass: a.Point, sorted: !0, requireSorting: !0, directTouch: !1, axisTypes: [\"xAxis\", \"yAxis\"], colorCounter: 0, parallelArrays: [\"x\", \"y\"], coll: \"series\", init: function (a, b) {\n        var f = this,\n            e,\n            m = a.series,\n            h;f.chart = a;f.options = b = f.setOptions(b);f.linkedSeries = [];f.bindAxes();c(f, { name: b.name,\n          state: \"\", visible: !1 !== b.visible, selected: !0 === b.selected });e = b.events;n(e, function (a, b) {\n          C(f, b, a);\n        });if (e && e.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;f.getColor();f.getSymbol();l(f.parallelArrays, function (a) {\n          f[a + \"Data\"] = [];\n        });f.setData(b.data, !1);f.isCartesian && (a.hasCartesianSeries = !0);m.length && (h = m[m.length - 1]);f._i = z(h && h._i, -1) + 1;a.orderSeries(this.insert(m));d(this, \"afterInit\");\n      }, insert: function (a) {\n        var b = this.options.index,\n            c;if (p(b)) {\n          for (c = a.length; c--;) if (b >= z(a[c].options.index, a[c]._i)) {\n            a.splice(c + 1, 0, this);break;\n          }-1 === c && a.unshift(this);c += 1;\n        } else a.push(this);return z(c, a.length - 1);\n      }, bindAxes: function () {\n        var b = this,\n            c = b.options,\n            d = b.chart,\n            f;l(b.axisTypes || [], function (e) {\n          l(d[e], function (a) {\n            f = a.options;if (c[e] === f.index || void 0 !== c[e] && c[e] === f.id || void 0 === c[e] && 0 === f.index) b.insert(a.series), b[e] = a, a.isDirty = !0;\n          });b[e] || b.optionalAxis === e || a.error(18, !0);\n        });\n      }, updateParallelArrays: function (a, b) {\n        var c = a.series,\n            d = arguments,\n            f = p(b) ? function (d) {\n          var f = \"y\" === d && c.toYData ? c.toYData(a) : a[d];c[d + \"Data\"][b] = f;\n        } : function (a) {\n          Array.prototype[b].apply(c[a + \"Data\"], Array.prototype.slice.call(d, 2));\n        };l(c.parallelArrays, f);\n      }, autoIncrement: function () {\n        var a = this.options,\n            b = this.xIncrement,\n            c,\n            d = a.pointIntervalUnit,\n            f = this.chart.time,\n            b = z(b, a.pointStart, 0);this.pointInterval = c = z(this.pointInterval, a.pointInterval, 1);d && (a = new f.Date(b), \"day\" === d ? f.set(\"Date\", a, f.get(\"Date\", a) + c) : \"month\" === d ? f.set(\"Month\", a, f.get(\"Month\", a) + c) : \"year\" === d && f.set(\"FullYear\", a, f.get(\"FullYear\", a) + c), c = a.getTime() - b);this.xIncrement = b + c;return b;\n      }, setOptions: function (a) {\n        var c = this.chart,\n            f = c.options,\n            m = f.plotOptions,\n            g = (c.userOptions || {}).plotOptions || {},\n            h = m[this.type];this.userOptions = a;c = b(h, m.series, a);this.tooltipOptions = b(e.tooltip, e.plotOptions.series && e.plotOptions.series.tooltip, e.plotOptions[this.type].tooltip, f.tooltip.userOptions, m.series && m.series.tooltip, m[this.type].tooltip, a.tooltip);this.stickyTracking = z(a.stickyTracking, g[this.type] && g[this.type].stickyTracking, g.series && g.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : c.stickyTracking);null === h.marker && delete c.marker;this.zoneAxis = c.zoneAxis;a = this.zones = (c.zones || []).slice();!c.negativeColor && !c.negativeFillColor || c.zones || a.push({ value: c[this.zoneAxis + \"Threshold\"] || c.threshold || 0, className: \"highcharts-negative\", color: c.negativeColor, fillColor: c.negativeFillColor });a.length && w(a[a.length - 1].value) && a.push({ color: this.color, fillColor: this.fillColor });d(this, \"afterSetOptions\", { options: c });return c;\n      }, getName: function () {\n        return this.name || \"Series \" + (this.index + 1);\n      }, getCyclic: function (a, b, c) {\n        var d,\n            f = this.chart,\n            h = this.userOptions,\n            e = a + \"Index\",\n            m = a + \"Counter\",\n            g = c ? c.length : z(f.options.chart[a + \"Count\"], f[a + \"Count\"]);b || (d = z(h[e], h[\"_\" + e]), w(d) || (f.series.length || (f[m] = 0), h[\"_\" + e] = d = f[m] % g, f[m] += 1), c && (b = c[d]));void 0 !== d && (this[e] = d);this[a] = b;\n      }, getColor: function () {\n        this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || t[this.type].color, this.chart.options.colors);\n      }, getSymbol: function () {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      }, drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker, updateData: function (b) {\n        var c = this.options,\n            d = this.points,\n            f = [],\n            e,\n            h,\n            m,\n            g = this.requireSorting;l(b, function (b) {\n          var h;h = a.defined(b) && this.pointClass.prototype.optionsToObject.call({ series: this }, b).x;p(h) && (h = a.inArray(h, this.xData, m), -1 === h ? f.push(b) : b !== c.data[h] ? (d[h].update(b, !1, null, !1), d[h].touched = !0, g && (m = h)) : d[h] && (d[h].touched = !0), e = !0);\n        }, this);if (e) for (b = d.length; b--;) h = d[b], h.touched || h.remove(!1), h.touched = !1;else if (b.length === d.length) l(b, function (a, b) {\n          d[b].update && a !== c.data[b] && d[b].update(a, !1, null, !1);\n        });else return !1;l(f, function (a) {\n          this.addPoint(a, !1);\n        }, this);return !0;\n      }, setData: function (b, c, d, e) {\n        var m = this,\n            h = m.points,\n            g = h && h.length || 0,\n            q,\n            k = m.options,\n            A = m.chart,\n            n = null,\n            E = m.xAxis,\n            B = k.turboThreshold,\n            t = this.xData,\n            r = this.yData,\n            u = (q = m.pointArrayMap) && q.length,\n            H;b = b || [];q = b.length;c = z(c, !0);!1 !== e && q && g && !m.cropped && !m.hasGroupedData && m.visible && (H = this.updateData(b));if (!H) {\n          m.xIncrement = null;m.colorCounter = 0;l(this.parallelArrays, function (a) {\n            m[a + \"Data\"].length = 0;\n          });if (B && q > B) {\n            for (d = 0; null === n && d < q;) n = b[d], d++;if (p(n)) for (d = 0; d < q; d++) t[d] = this.autoIncrement(), r[d] = b[d];else if (x(n)) {\n              if (u) for (d = 0; d < q; d++) n = b[d], t[d] = n[0], r[d] = n.slice(1, u + 1);else for (d = 0; d < q; d++) n = b[d], t[d] = n[0], r[d] = n[1];\n            } else a.error(12);\n          } else for (d = 0; d < q; d++) void 0 !== b[d] && (n = { series: m }, m.pointClass.prototype.applyOptions.apply(n, [b[d]]), m.updateParallelArrays(n, d));r && f(r[0]) && a.error(14, !0);m.data = [];m.options.data = m.userOptions.data = b;for (d = g; d--;) h[d] && h[d].destroy && h[d].destroy();E && (E.minRange = E.userMinRange);m.isDirty = A.isDirtyBox = !0;m.isDirtyData = !!h;d = !1;\n        }\"point\" === k.legendType && (this.processData(), this.generatePoints());c && A.redraw(d);\n      }, processData: function (b) {\n        var c = this.xData,\n            d = this.yData,\n            f = c.length,\n            e;e = 0;var h,\n            m,\n            g = this.xAxis,\n            q,\n            k = this.options;q = k.cropThreshold;var p = this.getExtremesFromAll || k.getExtremesFromAll,\n            n = this.isCartesian,\n            k = g && g.val2lin,\n            l = g && g.isLog,\n            B = this.requireSorting,\n            t,\n            r;if (n && !this.isDirty && !g.isDirty && !this.yAxis.isDirty && !b) return !1;g && (b = g.getExtremes(), t = b.min, r = b.max);if (n && this.sorted && !p && (!q || f > q || this.forceCrop)) if (c[f - 1] < t || c[0] > r) c = [], d = [];else if (c[0] < t || c[f - 1] > r) e = this.cropData(this.xData, this.yData, t, r), c = e.xData, d = e.yData, e = e.start, h = !0;for (q = c.length || 1; --q;) f = l ? k(c[q]) - k(c[q - 1]) : c[q] - c[q - 1], 0 < f && (void 0 === m || f < m) ? m = f : 0 > f && B && (a.error(15), B = !1);this.cropped = h;this.cropStart = e;this.processedXData = c;this.processedYData = d;this.closestPointRange = m;\n      }, cropData: function (a, b, c, d, f) {\n        var h = a.length,\n            e = 0,\n            m = h,\n            g;f = z(f, this.cropShoulder, 1);for (g = 0; g < h; g++) if (a[g] >= c) {\n          e = Math.max(0, g - f);break;\n        }for (c = g; c < h; c++) if (a[c] > d) {\n          m = c + f;break;\n        }return { xData: a.slice(e, m), yData: b.slice(e, m), start: e, end: m };\n      }, generatePoints: function () {\n        var a = this.options,\n            b = a.data,\n            c = this.data,\n            d,\n            f = this.processedXData,\n            h = this.processedYData,\n            e = this.pointClass,\n            g = f.length,\n            k = this.cropStart || 0,\n            p,\n            n = this.hasGroupedData,\n            a = a.keys,\n            l,\n            B = [],\n            t;c || n || (c = [], c.length = b.length, c = this.data = c);a && n && (this.options.keys = !1);for (t = 0; t < g; t++) p = k + t, n ? (l = new e().init(this, [f[t]].concat(q(h[t]))), l.dataGroup = this.groupMap[t]) : (l = c[p]) || void 0 === b[p] || (c[p] = l = new e().init(this, b[p], f[t])), l && (l.index = p, B[t] = l);this.options.keys = a;if (c && (g !== (d = c.length) || n)) for (t = 0; t < d; t++) t !== k || n || (t += g), c[t] && (c[t].destroyElements(), c[t].plotX = void 0);this.data = c;this.points = B;\n      }, getExtremes: function (a) {\n        var b = this.yAxis,\n            c = this.processedXData,\n            d,\n            f = [],\n            h = 0;d = this.xAxis.getExtremes();var e = d.min,\n            m = d.max,\n            g,\n            q,\n            k = this.requireSorting ? 1 : 0,\n            n,\n            l;a = a || this.stackedYData || this.processedYData || [];d = a.length;for (l = 0; l < d; l++) if (q = c[l], n = a[l], g = (p(n, !0) || x(n)) && (!b.positiveValuesOnly || n.length || 0 < n), q = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (c[l + k] || q) >= e && (c[l - k] || q) <= m, g && q) if (g = n.length) for (; g--;) \"number\" === typeof n[g] && (f[h++] = n[g]);else f[h++] = n;this.dataMin = r(f);this.dataMax = D(f);\n      }, translate: function () {\n        this.processedXData || this.processData();this.generatePoints();var a = this.options,\n            b = a.stacking,\n            c = this.xAxis,\n            f = c.categories,\n            e = this.yAxis,\n            h = this.points,\n            q = h.length,\n            k = !!this.modifyValue,\n            n = a.pointPlacement,\n            l = \"between\" === n || p(n),\n            t = a.threshold,\n            B = a.startFromThreshold ? t : 0,\n            r,\n            x,\n            u,\n            H,\n            J = Number.MAX_VALUE;\"between\" === n && (n = .5);p(n) && (n *= z(a.pointRange || c.pointRange));for (a = 0; a < q; a++) {\n          var L = h[a],\n              C = L.x,\n              D = L.y;x = L.low;var F = b && e.stacks[(this.negStacks && D < (B ? 0 : t) ? \"-\" : \"\") + this.stackKey],\n              K;e.positiveValuesOnly && null !== D && 0 >= D && (L.isNull = !0);L.plotX = r = g(Math.min(Math.max(-1E5, c.translate(C, 0, 0, 0, 1, n, \"flags\" === this.type)), 1E5));b && this.visible && !L.isNull && F && F[C] && (H = this.getStackIndicator(H, C, this.index), K = F[C], D = K.points[H.key], x = D[0], D = D[1], x === B && H.key === F[C].base && (x = z(p(t) && t, e.min)), e.positiveValuesOnly && 0 >= x && (x = null), L.total = L.stackTotal = K.total, L.percentage = K.total && L.y / K.total * 100, L.stackY = D, K.setOffset(this.pointXOffset || 0, this.barW || 0));L.yBottom = w(x) ? Math.min(Math.max(-1E5, e.translate(x, 0, 1, 0, 1)), 1E5) : null;k && (D = this.modifyValue(D, L));L.plotY = x = \"number\" === typeof D && Infinity !== D ? Math.min(Math.max(-1E5, e.translate(D, 0, 1, 0, 1)), 1E5) : void 0;L.isInside = void 0 !== x && 0 <= x && x <= e.len && 0 <= r && r <= c.len;L.clientX = l ? g(c.translate(C, 0, 0, 0, 1, n)) : r;L.negative = L.y < (t || 0);L.category = f && void 0 !== f[L.x] ? f[L.x] : L.x;L.isNull || (void 0 !== u && (J = Math.min(J, Math.abs(r - u))), u = r);L.zone = this.zones.length && L.getZone();\n        }this.closestPointRangePx = J;d(this, \"afterTranslate\");\n      }, getValidPoints: function (a, b) {\n        var c = this.chart;return k(a || this.points || [], function (a) {\n          return b && !c.isInsidePlot(a.plotX, a.plotY, c.inverted) ? !1 : !a.isNull;\n        });\n      }, setClip: function (a) {\n        var b = this.chart,\n            c = this.options,\n            d = b.renderer,\n            f = b.inverted,\n            h = this.clipBox,\n            e = h || b.clipBox,\n            m = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, e.height, c.xAxis, c.yAxis].join(),\n            g = b[m],\n            q = b[m + \"m\"];g || (a && (e.width = 0, f && (e.x = b.plotSizeX), b[m + \"m\"] = q = d.clipRect(f ? b.plotSizeX + 99 : -99, f ? -b.plotLeft : -b.plotTop, 99, f ? b.chartWidth : b.chartHeight)), b[m] = g = d.clipRect(e), g.count = { length: 0 });a && !g.count[this.index] && (g.count[this.index] = !0, g.count.length += 1);!1 !== c.clip && (this.group.clip(a || h ? g : b.clipRect), this.markerGroup.clip(q), this.sharedClipKey = m);a || (g.count[this.index] && (delete g.count[this.index], --g.count.length), 0 === g.count.length && m && b[m] && (h || (b[m] = b[m].destroy()), b[m + \"m\"] && (b[m + \"m\"] = b[m + \"m\"].destroy())));\n      }, animate: function (a) {\n        var b = this.chart,\n            c = F(this.options.animation),\n            d;a ? this.setClip(c) : (d = this.sharedClipKey, (a = b[d]) && a.animate({ width: b.plotSizeX, x: 0 }, c), b[d + \"m\"] && b[d + \"m\"].animate({ width: b.plotSizeX + 99, x: 0 }, c), this.animate = null);\n      }, afterAnimate: function () {\n        this.setClip();d(this, \"afterAnimate\");this.finishedAnimating = !0;\n      }, drawPoints: function () {\n        var a = this.points,\n            b = this.chart,\n            c,\n            d,\n            f,\n            h,\n            e = this.options.marker,\n            g,\n            q,\n            k,\n            p = this[this.specialGroup] || this.markerGroup,\n            n,\n            l = z(e.enabled, this.xAxis.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius);if (!1 !== e.enabled || this._hasPointMarkers) for (c = 0; c < a.length; c++) d = a[c], h = d.graphic, g = d.marker || {}, q = !!d.marker, f = l && void 0 === g.enabled || g.enabled, k = d.isInside, f && !d.isNull ? (f = z(g.symbol, this.symbol), n = this.markerAttribs(d, d.selected && \"select\"), h ? h[k ? \"show\" : \"hide\"](!0).animate(n) : k && (0 < n.width || d.hasImage) && (d.graphic = h = b.renderer.symbol(f, n.x, n.y, n.width, n.height, q ? g : e).add(p)), h && h.attr(this.pointAttribs(d, d.selected && \"select\")), h && h.addClass(d.getClassName(), !0)) : h && (d.graphic = h.destroy());\n      }, markerAttribs: function (a, b) {\n        var c = this.options.marker,\n            d = a.marker || {},\n            f = d.symbol || c.symbol,\n            h = z(d.radius, c.radius);b && (c = c.states[b], b = d.states && d.states[b], h = z(b && b.radius, c && c.radius, h + (c && c.radiusPlus || 0)));a.hasImage = f && 0 === f.indexOf(\"url\");a.hasImage && (h = 0);a = { x: Math.floor(a.plotX) - h, y: a.plotY - h };h && (a.width = a.height = 2 * h);return a;\n      }, pointAttribs: function (a, b) {\n        var c = this.options.marker,\n            d = a && a.options,\n            f = d && d.marker || {},\n            h = this.color,\n            e = d && d.color,\n            g = a && a.color,\n            d = z(f.lineWidth, c.lineWidth);a = a && a.zone && a.zone.color;h = e || a || g || h;a = f.fillColor || c.fillColor || h;h = f.lineColor || c.lineColor || h;b && (c = c.states[b], b = f.states && f.states[b] || {}, d = z(b.lineWidth, c.lineWidth, d + z(b.lineWidthPlus, c.lineWidthPlus, 0)), a = b.fillColor || c.fillColor || a, h = b.lineColor || c.lineColor || h);return { stroke: h, \"stroke-width\": d, fill: a };\n      }, destroy: function () {\n        var b = this,\n            c = b.chart,\n            f = /AppleWebKit\\/533/.test(H.navigator.userAgent),\n            e,\n            g,\n            h = b.data || [],\n            q,\n            k;d(b, \"destroy\");J(b);l(b.axisTypes || [], function (a) {\n          (k = b[a]) && k.series && (u(k.series, b), k.isDirty = k.forceRedraw = !0);\n        });b.legendItem && b.chart.legend.destroyItem(b);for (g = h.length; g--;) (q = h[g]) && q.destroy && q.destroy();b.points = null;a.clearTimeout(b.animationTimeout);n(b, function (a, b) {\n          a instanceof L && !a.survive && (e = f && \"group\" === b ? \"hide\" : \"destroy\", a[e]());\n        });c.hoverSeries === b && (c.hoverSeries = null);u(c.series, b);c.orderSeries();n(b, function (a, c) {\n          delete b[c];\n        });\n      }, getGraphPath: function (a, b, c) {\n        var d = this,\n            f = d.options,\n            h = f.step,\n            e,\n            g = [],\n            m = [],\n            q;a = a || d.points;(e = a.reversed) && a.reverse();(h = { right: 1, center: 2 }[h] || h && 3) && e && (h = 4 - h);!f.connectNulls || b || c || (a = this.getValidPoints(a));l(a, function (e, k) {\n          var n = e.plotX,\n              p = e.plotY,\n              l = a[k - 1];(e.leftCliff || l && l.rightCliff) && !c && (q = !0);e.isNull && !w(b) && 0 < k ? q = !f.connectNulls : e.isNull && !b ? q = !0 : (0 === k || q ? k = [\"M\", e.plotX, e.plotY] : d.getPointSpline ? k = d.getPointSpline(a, e, k) : h ? (k = 1 === h ? [\"L\", l.plotX, p] : 2 === h ? [\"L\", (l.plotX + n) / 2, l.plotY, \"L\", (l.plotX + n) / 2, p] : [\"L\", n, l.plotY], k.push(\"L\", n, p)) : k = [\"L\", n, p], m.push(e.x), h && (m.push(e.x), 2 === h && m.push(e.x)), g.push.apply(g, k), q = !1);\n        });g.xMap = m;return d.graphPath = g;\n      }, drawGraph: function () {\n        var a = this,\n            b = this.options,\n            c = (this.gappedPath || this.getGraphPath).call(this),\n            d = [[\"graph\", \"highcharts-graph\", b.lineColor || this.color, b.dashStyle]],\n            d = a.getZonesGraphs(d);l(d, function (d, f) {\n          var e = d[0],\n              h = a[e];h ? (h.endX = a.preventGraphAnimation ? null : c.xMap, h.animate({ d: c })) : c.length && (a[e] = a.chart.renderer.path(c).addClass(d[1]).attr({ zIndex: 1 }).add(a.group), h = { stroke: d[2], \"stroke-width\": b.lineWidth, fill: a.fillGraph && a.color || \"none\" }, d[3] ? h.dashstyle = d[3] : \"square\" !== b.linecap && (h[\"stroke-linecap\"] = h[\"stroke-linejoin\"] = \"round\"), h = a[e].attr(h).shadow(2 > f && b.shadow));h && (h.startX = c.xMap, h.isArea = c.isArea);\n        });\n      }, getZonesGraphs: function (a) {\n        l(this.zones, function (b, c) {\n          a.push([\"zone-graph-\" + c, \"highcharts-graph highcharts-zone-graph-\" + c + \" \" + (b.className || \"\"), b.color || this.color, b.dashStyle || this.options.dashStyle]);\n        }, this);return a;\n      }, applyZones: function () {\n        var a = this,\n            b = this.chart,\n            c = b.renderer,\n            d = this.zones,\n            f,\n            e,\n            g = this.clips || [],\n            q,\n            k = this.graph,\n            n = this.area,\n            p = Math.max(b.chartWidth, b.chartHeight),\n            t = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            B,\n            r,\n            x = b.inverted,\n            u,\n            H,\n            w,\n            L,\n            J = !1;d.length && (k || n) && t && void 0 !== t.min && (r = t.reversed, u = t.horiz, k && !this.showLine && k.hide(), n && n.hide(), B = t.getExtremes(), l(d, function (d, h) {\n          f = r ? u ? b.plotWidth : 0 : u ? 0 : t.toPixels(B.min);f = Math.min(Math.max(z(e, f), 0), p);e = Math.min(Math.max(Math.round(t.toPixels(z(d.value, B.max), !0)), 0), p);J && (f = e = t.toPixels(B.max));\n          H = Math.abs(f - e);w = Math.min(f, e);L = Math.max(f, e);t.isXAxis ? (q = { x: x ? L : w, y: 0, width: H, height: p }, u || (q.x = b.plotHeight - q.x)) : (q = { x: 0, y: x ? L : w, width: p, height: H }, u && (q.y = b.plotWidth - q.y));x && c.isVML && (q = t.isXAxis ? { x: 0, y: r ? w : L, height: q.width, width: b.chartWidth } : { x: q.y - b.plotLeft - b.spacingBox.x, y: 0, width: q.height, height: b.chartHeight });g[h] ? g[h].animate(q) : (g[h] = c.clipRect(q), k && a[\"zone-graph-\" + h].clip(g[h]), n && a[\"zone-area-\" + h].clip(g[h]));J = d.value > B.max;a.resetZones && 0 === e && (e = void 0);\n        }), this.clips = g);\n      }, invertGroups: function (a) {\n        function b() {\n          l([\"group\", \"markerGroup\"], function (b) {\n            c[b] && (d.renderer.isVML && c[b].attr({ width: c.yAxis.len, height: c.xAxis.len }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(a));\n          });\n        }var c = this,\n            d = c.chart,\n            f;c.xAxis && (f = C(d, \"resize\", b), C(c, \"destroy\", f), b(a), c.invertGroups = b);\n      }, plotGroup: function (a, b, c, d, f) {\n        var e = this[a],\n            g = !e;g && (this[a] = e = this.chart.renderer.g().attr({ zIndex: d || .1 }).add(f));e.addClass(\"highcharts-\" + b + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (w(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (e.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);e.attr({ visibility: c })[g ? \"attr\" : \"animate\"](this.getPlotBox());return e;\n      }, getPlotBox: function () {\n        var a = this.chart,\n            b = this.xAxis,\n            c = this.yAxis;a.inverted && (b = c, c = this.xAxis);return { translateX: b ? b.left : a.plotLeft, translateY: c ? c.top : a.plotTop, scaleX: 1, scaleY: 1 };\n      }, render: function () {\n        var a = this,\n            b = a.chart,\n            c,\n            f = a.options,\n            e = !!a.animate && b.renderer.isSVG && F(f.animation).duration,\n            h = a.visible ? \"inherit\" : \"hidden\",\n            g = f.zIndex,\n            q = a.hasRendered,\n            k = b.seriesGroup,\n            n = b.inverted;c = a.plotGroup(\"group\", \"series\", h, g, k);a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", h, g, k);e && a.animate(!0);c.inverted = a.isCartesian ? n : !1;a.drawGraph && (a.drawGraph(), a.applyZones());a.drawDataLabels && a.drawDataLabels();a.visible && a.drawPoints();a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();a.invertGroups(n);!1 === f.clip || a.sharedClipKey || q || c.clip(b.clipRect);e && a.animate();q || (a.animationTimeout = B(function () {\n          a.afterAnimate();\n        }, e));a.isDirty = !1;a.hasRendered = !0;d(a, \"afterRender\");\n      }, redraw: function () {\n        var a = this.chart,\n            b = this.isDirty || this.isDirtyData,\n            c = this.group,\n            d = this.xAxis,\n            f = this.yAxis;c && (a.inverted && c.attr({ width: a.plotWidth, height: a.plotHeight }), c.animate({ translateX: z(d && d.left, a.plotLeft), translateY: z(f && f.top, a.plotTop) }));this.translate();this.render();b && delete this.kdTree;\n      }, kdAxisArray: [\"clientX\", \"plotY\"], searchPoint: function (a, b) {\n        var c = this.xAxis,\n            d = this.yAxis,\n            f = this.chart.inverted;return this.searchKDTree({ clientX: f ? c.len - a.chartY + c.pos : a.chartX - c.pos, plotY: f ? d.len - a.chartX + d.pos : a.chartY - d.pos }, b);\n      }, buildKDTree: function () {\n        function a(c, d, f) {\n          var e, h;if (h = c && c.length) return e = b.kdAxisArray[d % f], c.sort(function (a, b) {\n            return a[e] - b[e];\n          }), h = Math.floor(h / 2), { point: c[h], left: a(c.slice(0, h), d + 1, f), right: a(c.slice(h + 1), d + 1, f) };\n        }this.buildingKdTree = !0;var b = this,\n            c = -1 < b.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;delete b.kdTree;B(function () {\n          b.kdTree = a(b.getValidPoints(null, !b.directTouch), c, c);b.buildingKdTree = !1;\n        }, b.options.kdNow ? 0 : 1);\n      }, searchKDTree: function (a, b) {\n        function c(a, b, h, m) {\n          var q = b.point,\n              k = d.kdAxisArray[h % m],\n              n,\n              p,\n              l = q;p = w(a[f]) && w(q[f]) ? Math.pow(a[f] - q[f], 2) : null;n = w(a[e]) && w(q[e]) ? Math.pow(a[e] - q[e], 2) : null;n = (p || 0) + (n || 0);q.dist = w(n) ? Math.sqrt(n) : Number.MAX_VALUE;q.distX = w(p) ? Math.sqrt(p) : Number.MAX_VALUE;k = a[k] - q[k];n = 0 > k ? \"left\" : \"right\";p = 0 > k ? \"right\" : \"left\";b[n] && (n = c(a, b[n], h + 1, m), l = n[g] < l[g] ? n : q);b[p] && Math.sqrt(k * k) < l[g] && (a = c(a, b[p], h + 1, m), l = a[g] < l[g] ? a : l);return l;\n        }var d = this,\n            f = this.kdAxisArray[0],\n            e = this.kdAxisArray[1],\n            g = b ? \"distX\" : \"dist\";b = -1 < d.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;this.kdTree || this.buildingKdTree || this.buildKDTree();if (this.kdTree) return c(a, this.kdTree, b, b);\n      } });\n  })(K);(function (a) {\n    var C = a.Axis,\n        F = a.Chart,\n        D = a.correctFloat,\n        r = a.defined,\n        g = a.destroyObjectProperties,\n        e = a.each,\n        t = a.format,\n        w = a.objectEach,\n        l = a.pick,\n        u = a.Series;a.StackItem = function (a, d, e, g, p) {\n      var c = a.chart.inverted;this.axis = a;this.isNegative = e;this.options = d;this.x = g;this.total = null;this.points = {};this.stack = p;this.rightCliff = this.leftCliff = 0;this.alignOptions = { align: d.align || (c ? e ? \"left\" : \"right\" : \"center\"), verticalAlign: d.verticalAlign || (c ? \"middle\" : e ? \"bottom\" : \"top\"), y: l(d.y, c ? 4 : e ? 14 : -6), x: l(d.x, c ? e ? -6 : 6 : 0) };this.textAlign = d.textAlign || (c ? e ? \"right\" : \"left\" : \"center\");\n    };a.StackItem.prototype = { destroy: function () {\n        g(this, this.axis);\n      }, render: function (a) {\n        var c = this.axis.chart,\n            e = this.options,\n            g = e.format,\n            g = g ? t(g, this, c.time) : e.formatter.call(this);this.label ? this.label.attr({ text: g, visibility: \"hidden\" }) : this.label = c.renderer.text(g, null, null, e.useHTML).css(e.style).attr({ align: this.textAlign,\n          rotation: e.rotation, visibility: \"hidden\" }).add(a);\n      }, setOffset: function (a, d) {\n        var c = this.axis,\n            e = c.chart,\n            g = c.translate(c.usePercentage ? 100 : this.total, 0, 0, 0, 1),\n            f = c.translate(0),\n            f = Math.abs(g - f);a = e.xAxis[0].translate(this.x) + a;c = this.getStackBox(e, this, a, g, d, f, c);if (d = this.label) d.align(this.alignOptions, null, c), c = d.alignAttr, d[!1 === this.options.crop || e.isInsidePlot(c.x, c.y) ? \"show\" : \"hide\"](!0);\n      }, getStackBox: function (a, d, e, g, p, f, b) {\n        var c = d.axis.reversed,\n            k = a.inverted;a = b.height + b.pos - a.plotTop;d = d.isNegative && !c || !d.isNegative && c;return { x: k ? d ? g : g - f : e, y: k ? a - e - p : d ? a - g - f : a - g, width: k ? f : p, height: k ? p : f };\n      } };F.prototype.getStacks = function () {\n      var a = this;e(a.yAxis, function (a) {\n        a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks);\n      });e(a.series, function (c) {\n        !c.options.stacking || !0 !== c.visible && !1 !== a.options.chart.ignoreHiddenSeries || (c.stackKey = c.type + l(c.options.stack, \"\"));\n      });\n    };C.prototype.buildStacks = function () {\n      var a = this.series,\n          d = l(this.options.reversedStacks, !0),\n          e = a.length,\n          g;if (!this.isXAxis) {\n        this.usePercentage = !1;\n        for (g = e; g--;) a[d ? g : e - g - 1].setStackedPoints();for (g = 0; g < e; g++) a[g].modifyStacks();\n      }\n    };C.prototype.renderStackTotals = function () {\n      var a = this.chart,\n          d = a.renderer,\n          e = this.stacks,\n          g = this.stackTotalGroup;g || (this.stackTotalGroup = g = d.g(\"stack-labels\").attr({ visibility: \"visible\", zIndex: 6 }).add());g.translate(a.plotLeft, a.plotTop);w(e, function (a) {\n        w(a, function (a) {\n          a.render(g);\n        });\n      });\n    };C.prototype.resetStacks = function () {\n      var a = this,\n          d = a.stacks;a.isXAxis || w(d, function (c) {\n        w(c, function (d, e) {\n          d.touched < a.stacksTouched ? (d.destroy(), delete c[e]) : (d.total = null, d.cumulative = null);\n        });\n      });\n    };C.prototype.cleanStacks = function () {\n      var a;this.isXAxis || (this.oldStacks && (a = this.stacks = this.oldStacks), w(a, function (a) {\n        w(a, function (a) {\n          a.cumulative = a.total;\n        });\n      }));\n    };u.prototype.setStackedPoints = function () {\n      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var c = this.processedXData,\n            d = this.processedYData,\n            e = [],\n            g = d.length,\n            p = this.options,\n            f = p.threshold,\n            b = l(p.startFromThreshold && f, 0),\n            n = p.stack,\n            p = p.stacking,\n            t = this.stackKey,\n            u = \"-\" + t,\n            q = this.negStacks,\n            w = this.yAxis,\n            B = w.stacks,\n            H = w.oldStacks,\n            m,\n            E,\n            A,\n            M,\n            G,\n            h,\n            v;w.stacksTouched += 1;for (G = 0; G < g; G++) h = c[G], v = d[G], m = this.getStackIndicator(m, h, this.index), M = m.key, A = (E = q && v < (b ? 0 : f)) ? u : t, B[A] || (B[A] = {}), B[A][h] || (H[A] && H[A][h] ? (B[A][h] = H[A][h], B[A][h].total = null) : B[A][h] = new a.StackItem(w, w.options.stackLabels, E, h, n)), A = B[A][h], null !== v ? (A.points[M] = A.points[this.index] = [l(A.cumulative, b)], r(A.cumulative) || (A.base = M), A.touched = w.stacksTouched, 0 < m.index && !1 === this.singleStacks && (A.points[M][0] = A.points[this.index + \",\" + h + \",0\"][0])) : A.points[M] = A.points[this.index] = null, \"percent\" === p ? (E = E ? t : u, q && B[E] && B[E][h] ? (E = B[E][h], A.total = E.total = Math.max(E.total, A.total) + Math.abs(v) || 0) : A.total = D(A.total + (Math.abs(v) || 0))) : A.total = D(A.total + (v || 0)), A.cumulative = l(A.cumulative, b) + (v || 0), null !== v && (A.points[M].push(A.cumulative), e[G] = A.cumulative);\"percent\" === p && (w.usePercentage = !0);this.stackedYData = e;w.oldStacks = {};\n      }\n    };u.prototype.modifyStacks = function () {\n      var a = this,\n          d = a.stackKey,\n          g = a.yAxis.stacks,\n          l = a.processedXData,\n          p,\n          f = a.options.stacking;a[f + \"Stacker\"] && e([d, \"-\" + d], function (b) {\n        for (var c = l.length, d, e; c--;) if (d = l[c], p = a.getStackIndicator(p, d, a.index, b), e = (d = g[b] && g[b][d]) && d.points[p.key]) a[f + \"Stacker\"](e, d, c);\n      });\n    };u.prototype.percentStacker = function (a, d, e) {\n      d = d.total ? 100 / d.total : 0;a[0] = D(a[0] * d);a[1] = D(a[1] * d);this.stackedYData[e] = a[1];\n    };u.prototype.getStackIndicator = function (a, d, e, g) {\n      !r(a) || a.x !== d || g && a.key !== g ? a = { x: d, index: 0, key: g } : a.index++;a.key = [e, d, a.index].join();return a;\n    };\n  })(K);(function (a) {\n    var C = a.addEvent,\n        F = a.animate,\n        D = a.Axis,\n        r = a.createElement,\n        g = a.css,\n        e = a.defined,\n        t = a.each,\n        w = a.erase,\n        l = a.extend,\n        u = a.fireEvent,\n        c = a.inArray,\n        d = a.isNumber,\n        k = a.isObject,\n        x = a.isArray,\n        p = a.merge,\n        f = a.objectEach,\n        b = a.pick,\n        n = a.Point,\n        z = a.Series,\n        J = a.seriesTypes,\n        q = a.setAnimation,\n        L = a.splat;l(a.Chart.prototype, { addSeries: function (a, c, d) {\n        var f,\n            e = this;a && (c = b(c, !0), u(e, \"addSeries\", { options: a }, function () {\n          f = e.initSeries(a);e.isDirtyLegend = !0;e.linkSeries();u(e, \"afterAddSeries\");c && e.redraw(d);\n        }));return f;\n      }, addAxis: function (a, c, d, f) {\n        var e = c ? \"xAxis\" : \"yAxis\",\n            g = this.options;a = p(a, { index: this[e].length, isX: c });c = new D(this, a);g[e] = L(g[e] || {});g[e].push(a);b(d, !0) && this.redraw(f);return c;\n      }, showLoading: function (a) {\n        var b = this,\n            c = b.options,\n            d = b.loadingDiv,\n            f = c.loading,\n            e = function () {\n          d && g(d, { left: b.plotLeft + \"px\", top: b.plotTop + \"px\", width: b.plotWidth + \"px\", height: b.plotHeight + \"px\" });\n        };d || (b.loadingDiv = d = r(\"div\", { className: \"highcharts-loading highcharts-loading-hidden\" }, null, b.container), b.loadingSpan = r(\"span\", { className: \"highcharts-loading-inner\" }, null, d), C(b, \"redraw\", e));d.className = \"highcharts-loading\";b.loadingSpan.innerHTML = a || c.lang.loading;g(d, l(f.style, { zIndex: 10 }));g(b.loadingSpan, f.labelStyle);b.loadingShown || (g(d, { opacity: 0, display: \"\" }), F(d, { opacity: f.style.opacity || .5 }, { duration: f.showDuration || 0 }));b.loadingShown = !0;e();\n      }, hideLoading: function () {\n        var a = this.options,\n            b = this.loadingDiv;b && (b.className = \"highcharts-loading highcharts-loading-hidden\", F(b, { opacity: 0 }, { duration: a.loading.hideDuration || 100, complete: function () {\n            g(b, { display: \"none\" });\n          } }));\n        this.loadingShown = !1;\n      }, propsRequireDirtyBox: \"backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"), propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \"), update: function (a, g, m, q) {\n        var k = this,\n            n = { credits: \"addCredits\",\n          title: \"setTitle\", subtitle: \"setSubtitle\" },\n            l = a.chart,\n            h,\n            v,\n            r = [];u(k, \"update\", { options: a });if (l) {\n          p(!0, k.options.chart, l);\"className\" in l && k.setClassName(l.className);\"reflow\" in l && k.setReflow(l.reflow);if (\"inverted\" in l || \"polar\" in l) k.propFromSeries(), h = !0;\"alignTicks\" in l && (h = !0);f(l, function (a, b) {\n            -1 !== c(\"chart.\" + b, k.propsRequireUpdateSeries) && (v = !0);-1 !== c(b, k.propsRequireDirtyBox) && (k.isDirtyBox = !0);\n          });\"style\" in l && k.renderer.setStyle(l.style);\n        }a.colors && (this.options.colors = a.colors);a.plotOptions && p(!0, this.options.plotOptions, a.plotOptions);f(a, function (a, b) {\n          if (k[b] && \"function\" === typeof k[b].update) k[b].update(a, !1);else if (\"function\" === typeof k[n[b]]) k[n[b]](a);\"chart\" !== b && -1 !== c(b, k.propsRequireUpdateSeries) && (v = !0);\n        });t(\"xAxis yAxis zAxis series colorAxis pane\".split(\" \"), function (b) {\n          a[b] && (t(L(a[b]), function (a, c) {\n            (c = e(a.id) && k.get(a.id) || k[b][c]) && c.coll === b && (c.update(a, !1), m && (c.touched = !0));if (!c && m) if (\"series\" === b) k.addSeries(a, !1).touched = !0;else if (\"xAxis\" === b || \"yAxis\" === b) k.addAxis(a, \"xAxis\" === b, !1).touched = !0;\n          }), m && t(k[b], function (a) {\n            a.touched ? delete a.touched : r.push(a);\n          }));\n        });t(r, function (a) {\n          a.remove(!1);\n        });h && t(k.axes, function (a) {\n          a.update({}, !1);\n        });v && t(k.series, function (a) {\n          a.update({}, !1);\n        });a.loading && p(!0, k.options.loading, a.loading);h = l && l.width;l = l && l.height;d(h) && h !== k.chartWidth || d(l) && l !== k.chartHeight ? k.setSize(h, l, q) : b(g, !0) && k.redraw(q);\n      }, setSubtitle: function (a) {\n        this.setTitle(void 0, a);\n      } });l(n.prototype, { update: function (a, c, d, f) {\n        function e() {\n          g.applyOptions(a);null === g.y && h && (g.graphic = h.destroy());k(a, !0) && (h && h.element && a && a.marker && void 0 !== a.marker.symbol && (g.graphic = h.destroy()), a && a.dataLabels && g.dataLabel && (g.dataLabel = g.dataLabel.destroy()), g.connector && (g.connector = g.connector.destroy()));m = g.index;q.updateParallelArrays(g, m);p.data[m] = k(p.data[m], !0) || k(a, !0) ? g.options : b(a, p.data[m]);q.isDirty = q.isDirtyData = !0;!q.fixedBox && q.hasCartesianSeries && (n.isDirtyBox = !0);\"point\" === p.legendType && (n.isDirtyLegend = !0);c && n.redraw(d);\n        }var g = this,\n            q = g.series,\n            h = g.graphic,\n            m,\n            n = q.chart,\n            p = q.options;c = b(c, !0);!1 === f ? e() : g.firePointEvent(\"update\", { options: a }, e);\n      }, remove: function (a, b) {\n        this.series.removePoint(c(this, this.series.data), a, b);\n      } });l(z.prototype, { addPoint: function (a, c, d, f) {\n        var e = this.options,\n            g = this.data,\n            q = this.chart,\n            h = this.xAxis,\n            h = h && h.hasNames && h.names,\n            m = e.data,\n            k,\n            n,\n            p = this.xData,\n            l,\n            t;c = b(c, !0);k = { series: this };this.pointClass.prototype.applyOptions.apply(k, [a]);t = k.x;l = p.length;if (this.requireSorting && t < p[l - 1]) for (n = !0; l && p[l - 1] > t;) l--;this.updateParallelArrays(k, \"splice\", l, 0, 0);this.updateParallelArrays(k, l);h && k.name && (h[t] = k.name);m.splice(l, 0, a);n && (this.data.splice(l, 0, null), this.processData());\"point\" === e.legendType && this.generatePoints();d && (g[0] && g[0].remove ? g[0].remove(!1) : (g.shift(), this.updateParallelArrays(k, \"shift\"), m.shift()));this.isDirtyData = this.isDirty = !0;c && q.redraw(f);\n      }, removePoint: function (a, c, d) {\n        var f = this,\n            e = f.data,\n            g = e[a],\n            m = f.points,\n            h = f.chart,\n            k = function () {\n          m && m.length === e.length && m.splice(a, 1);e.splice(a, 1);f.options.data.splice(a, 1);f.updateParallelArrays(g || { series: f }, \"splice\", a, 1);g && g.destroy();f.isDirty = !0;f.isDirtyData = !0;c && h.redraw();\n        };q(d, h);c = b(c, !0);g ? g.firePointEvent(\"remove\", null, k) : k();\n      }, remove: function (a, c, d) {\n        function f() {\n          e.destroy();g.isDirtyLegend = g.isDirtyBox = !0;g.linkSeries();b(a, !0) && g.redraw(c);\n        }var e = this,\n            g = e.chart;!1 !== d ? u(e, \"remove\", null, f) : f();\n      }, update: function (d, f) {\n        var e = this,\n            g = e.chart,\n            q = e.userOptions,\n            k = e.oldType || e.type,\n            n = d.type || q.type || g.options.chart.type,\n            h = J[k].prototype,\n            r,\n            B = [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n            x = [\"navigatorSeries\", \"baseSeries\"],\n            z = e.finishedAnimating && { animation: !1 },\n            w = [\"data\", \"name\", \"turboThreshold\"],\n            H = a.keys(d),\n            y = 0 < H.length;t(H, function (a) {\n          -1 === c(a, w) && (y = !1);\n        });if (y) d.data && this.setData(d.data, !1), d.name && this.setName(d.name, !1);else {\n          x = B.concat(x);t(x, function (a) {\n            x[a] = e[a];delete e[a];\n          });d = p(q, z, { index: e.index, pointStart: b(q.pointStart, e.xData[0]) }, { data: e.options.data }, d);e.remove(!1, null, !1);for (r in h) e[r] = void 0;J[n || k] ? l(e, J[n || k].prototype) : a.error(17, !0);t(x, function (a) {\n            e[a] = x[a];\n          });e.init(g, d);d.zIndex !== q.zIndex && t(B, function (a) {\n            e[a] && e[a].attr({ zIndex: d.zIndex });\n          });e.oldType = k;g.linkSeries();\n        }u(this, \"afterUpdate\");b(f, !0) && g.redraw(!1);\n      }, setName: function (a) {\n        this.name = this.options.name = this.userOptions.name = a;this.chart.isDirtyLegend = !0;\n      } });l(D.prototype, { update: function (a, c) {\n        var d = this.chart;a = p(this.userOptions, a);d.options[this.coll].indexOf && (d.options[this.coll][d.options[this.coll].indexOf(this.userOptions)] = a);this.destroy(!0);this.init(d, l(a, { events: void 0 }));d.isDirtyBox = !0;b(c, !0) && d.redraw();\n      },\n      remove: function (a) {\n        for (var c = this.chart, d = this.coll, f = this.series, e = f.length; e--;) f[e] && f[e].remove(!1);w(c.axes, this);w(c[d], this);x(c.options[d]) ? c.options[d].splice(this.options.index, 1) : delete c.options[d];t(c[d], function (a, b) {\n          a.options.index = a.userOptions.index = b;\n        });this.destroy();c.isDirtyBox = !0;b(a, !0) && c.redraw();\n      }, setTitle: function (a, b) {\n        this.update({ title: a }, b);\n      }, setCategories: function (a, b) {\n        this.update({ categories: a }, b);\n      } });\n  })(K);(function (a) {\n    var C = a.color,\n        F = a.each,\n        D = a.map,\n        r = a.pick,\n        g = a.Series,\n        e = a.seriesType;e(\"area\", \"line\", { softThreshold: !1, threshold: 0 }, { singleStacks: !1, getStackPoints: function (e) {\n        var g = [],\n            l = [],\n            t = this.xAxis,\n            c = this.yAxis,\n            d = c.stacks[this.stackKey],\n            k = {},\n            x = this.index,\n            p = c.series,\n            f = p.length,\n            b,\n            n = r(c.options.reversedStacks, !0) ? 1 : -1,\n            z;e = e || this.points;if (this.options.stacking) {\n          for (z = 0; z < e.length; z++) e[z].leftNull = e[z].rightNull = null, k[e[z].x] = e[z];a.objectEach(d, function (a, b) {\n            null !== a.total && l.push(b);\n          });l.sort(function (a, b) {\n            return a - b;\n          });b = D(p, function () {\n            return this.visible;\n          });F(l, function (a, e) {\n            var q = 0,\n                p,\n                r;if (k[a] && !k[a].isNull) g.push(k[a]), F([-1, 1], function (c) {\n              var g = 1 === c ? \"rightNull\" : \"leftNull\",\n                  q = 0,\n                  m = d[l[e + c]];if (m) for (z = x; 0 <= z && z < f;) p = m.points[z], p || (z === x ? k[a][g] = !0 : b[z] && (r = d[a].points[z]) && (q -= r[1] - r[0])), z += n;k[a][1 === c ? \"rightCliff\" : \"leftCliff\"] = q;\n            });else {\n              for (z = x; 0 <= z && z < f;) {\n                if (p = d[a].points[z]) {\n                  q = p[1];break;\n                }z += n;\n              }q = c.translate(q, 0, 1, 0, 1);g.push({ isNull: !0, plotX: t.translate(a, 0, 0, 0, 1), x: a, plotY: q, yBottom: q });\n            }\n          });\n        }return g;\n      }, getGraphPath: function (a) {\n        var e = g.prototype.getGraphPath,\n            l = this.options,\n            t = l.stacking,\n            c = this.yAxis,\n            d,\n            k,\n            x = [],\n            p = [],\n            f = this.index,\n            b,\n            n = c.stacks[this.stackKey],\n            z = l.threshold,\n            J = c.getThreshold(l.threshold),\n            q,\n            l = l.connectNulls || \"percent\" === t,\n            L = function (d, e, g) {\n          var q = a[d];d = t && n[q.x].points[f];var k = q[g + \"Null\"] || 0;g = q[g + \"Cliff\"] || 0;var m,\n              l,\n              q = !0;g || k ? (m = (k ? d[0] : d[1]) + g, l = d[0] + g, q = !!k) : !t && a[e] && a[e].isNull && (m = l = z);void 0 !== m && (p.push({ plotX: b, plotY: null === m ? J : c.getThreshold(m), isNull: q, isCliff: !0 }), x.push({ plotX: b, plotY: null === l ? J : c.getThreshold(l), doCurve: !1 }));\n        };a = a || this.points;t && (a = this.getStackPoints(a));for (d = 0; d < a.length; d++) if (k = a[d].isNull, b = r(a[d].rectPlotX, a[d].plotX), q = r(a[d].yBottom, J), !k || l) l || L(d, d - 1, \"left\"), k && !t && l || (p.push(a[d]), x.push({ x: d, plotX: b, plotY: q })), l || L(d, d + 1, \"right\");d = e.call(this, p, !0, !0);x.reversed = !0;k = e.call(this, x, !0, !0);k.length && (k[0] = \"L\");k = d.concat(k);e = e.call(this, p, !1, l);k.xMap = d.xMap;this.areaPath = k;return e;\n      }, drawGraph: function () {\n        this.areaPath = [];g.prototype.drawGraph.apply(this);var a = this,\n            e = this.areaPath,\n            l = this.options,\n            u = [[\"area\", \"highcharts-area\", this.color, l.fillColor]];F(this.zones, function (c, d) {\n          u.push([\"zone-area-\" + d, \"highcharts-area highcharts-zone-area-\" + d + \" \" + c.className, c.color || a.color, c.fillColor || l.fillColor]);\n        });F(u, function (c) {\n          var d = c[0],\n              g = a[d];g ? (g.endX = a.preventGraphAnimation ? null : e.xMap, g.animate({ d: e })) : (g = a[d] = a.chart.renderer.path(e).addClass(c[1]).attr({ fill: r(c[3], C(c[2]).setOpacity(r(l.fillOpacity, .75)).get()), zIndex: 0 }).add(a.group), g.isArea = !0);g.startX = e.xMap;g.shiftUnit = l.step ? 2 : 1;\n        });\n      }, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle });\n  })(K);\n  (function (a) {\n    var C = a.pick;a = a.seriesType;a(\"spline\", \"line\", {}, { getPointSpline: function (a, D, r) {\n        var g = D.plotX,\n            e = D.plotY,\n            t = a[r - 1];r = a[r + 1];var w, l, u, c;if (t && !t.isNull && !1 !== t.doCurve && !D.isCliff && r && !r.isNull && !1 !== r.doCurve && !D.isCliff) {\n          a = t.plotY;u = r.plotX;r = r.plotY;var d = 0;w = (1.5 * g + t.plotX) / 2.5;l = (1.5 * e + a) / 2.5;u = (1.5 * g + u) / 2.5;c = (1.5 * e + r) / 2.5;u !== w && (d = (c - l) * (u - g) / (u - w) + e - c);l += d;c += d;l > a && l > e ? (l = Math.max(a, e), c = 2 * e - l) : l < a && l < e && (l = Math.min(a, e), c = 2 * e - l);c > r && c > e ? (c = Math.max(r, e), l = 2 * e - c) : c < r && c < e && (c = Math.min(r, e), l = 2 * e - c);D.rightContX = u;D.rightContY = c;\n        }D = [\"C\", C(t.rightContX, t.plotX), C(t.rightContY, t.plotY), C(w, g), C(l, e), g, e];t.rightContX = t.rightContY = null;return D;\n      } });\n  })(K);(function (a) {\n    var C = a.seriesTypes.area.prototype,\n        F = a.seriesType;F(\"areaspline\", \"spline\", a.defaultPlotOptions.area, { getStackPoints: C.getStackPoints, getGraphPath: C.getGraphPath, drawGraph: C.drawGraph, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle });\n  })(K);(function (a) {\n    var C = a.animObject,\n        F = a.color,\n        D = a.each,\n        r = a.extend,\n        g = a.isNumber,\n        e = a.merge,\n        t = a.pick,\n        w = a.Series,\n        l = a.seriesType,\n        u = a.svg;l(\"column\", \"line\", { borderRadius: 0, crisp: !0, groupPadding: .2, marker: null, pointPadding: .1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: { hover: { halo: !1, brightness: .1 }, select: { color: \"#cccccc\", borderColor: \"#000000\" } }, dataLabels: { align: null, verticalAlign: null, y: null }, softThreshold: !1, startFromThreshold: !0, stickyTracking: !1, tooltip: { distance: 6 }, threshold: 0, borderColor: \"#ffffff\" }, { cropShoulder: 0, directTouch: !0, trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      negStacks: !0, init: function () {\n        w.prototype.init.apply(this, arguments);var a = this,\n            d = a.chart;d.hasRendered && D(d.series, function (c) {\n          c.type === a.type && (c.isDirty = !0);\n        });\n      }, getColumnMetrics: function () {\n        var a = this,\n            d = a.options,\n            e = a.xAxis,\n            g = a.yAxis,\n            p = e.reversed,\n            f,\n            b = {},\n            n = 0;!1 === d.grouping ? n = 1 : D(a.chart.series, function (c) {\n          var d = c.options,\n              e = c.yAxis,\n              q;c.type !== a.type || !c.visible && a.chart.options.chart.ignoreHiddenSeries || g.len !== e.len || g.pos !== e.pos || (d.stacking ? (f = c.stackKey, void 0 === b[f] && (b[f] = n++), q = b[f]) : !1 !== d.grouping && (q = n++), c.columnIndex = q);\n        });var l = Math.min(Math.abs(e.transA) * (e.ordinalSlope || d.pointRange || e.closestPointRange || e.tickInterval || 1), e.len),\n            r = l * d.groupPadding,\n            q = (l - 2 * r) / (n || 1),\n            d = Math.min(d.maxPointWidth || e.len, t(d.pointWidth, q * (1 - 2 * d.pointPadding)));a.columnMetrics = { width: d, offset: (q - d) / 2 + (r + ((a.columnIndex || 0) + (p ? 1 : 0)) * q - l / 2) * (p ? -1 : 1) };return a.columnMetrics;\n      }, crispCol: function (a, d, e, g) {\n        var c = this.chart,\n            f = this.borderWidth,\n            b = -(f % 2 ? .5 : 0),\n            f = f % 2 ? .5 : 1;c.inverted && c.renderer.isVML && (f += 1);this.options.crisp && (e = Math.round(a + e) + b, a = Math.round(a) + b, e -= a);g = Math.round(d + g) + f;b = .5 >= Math.abs(d) && .5 < g;d = Math.round(d) + f;g -= d;b && g && (--d, g += 1);return { x: a, y: d, width: e, height: g };\n      }, translate: function () {\n        var a = this,\n            d = a.chart,\n            e = a.options,\n            g = a.dense = 2 > a.closestPointRange * a.xAxis.transA,\n            g = a.borderWidth = t(e.borderWidth, g ? 0 : 1),\n            p = a.yAxis,\n            f = e.threshold,\n            b = a.translatedThreshold = p.getThreshold(f),\n            n = t(e.minPointLength, 5),\n            l = a.getColumnMetrics(),\n            r = l.width,\n            q = a.barW = Math.max(r, 1 + 2 * g),\n            u = a.pointXOffset = l.offset;d.inverted && (b -= .5);e.pointPadding && (q = Math.ceil(q));w.prototype.translate.apply(a);D(a.points, function (c) {\n          var e = t(c.yBottom, b),\n              g = 999 + Math.abs(e),\n              g = Math.min(Math.max(-g, c.plotY), p.len + g),\n              k = c.plotX + u,\n              l = q,\n              x = Math.min(g, e),\n              B,\n              h = Math.max(g, e) - x;n && Math.abs(h) < n && (h = n, B = !p.reversed && !c.negative || p.reversed && c.negative, c.y === f && a.dataMax <= f && p.min < f && (B = !B), x = Math.abs(x - b) > n ? e - n : b - (B ? n : 0));c.barX = k;c.pointWidth = r;c.tooltipPos = d.inverted ? [p.len + p.pos - d.plotLeft - g, a.xAxis.len - k - l / 2, h] : [k + l / 2, g + p.pos - d.plotTop, h];c.shapeType = \"rect\";c.shapeArgs = a.crispCol.apply(a, c.isNull ? [k, b, l, 0] : [k, x, l, h]);\n        });\n      }, getSymbol: a.noop, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle, drawGraph: function () {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      }, pointAttribs: function (a, d) {\n        var c = this.options,\n            g,\n            p = this.pointAttrToOptions || {};g = p.stroke || \"borderColor\";var f = p[\"stroke-width\"] || \"borderWidth\",\n            b = a && a.color || this.color,\n            n = a && a[g] || c[g] || this.color || b,\n            l = a && a[f] || c[f] || this[f] || 0,\n            p = c.dashStyle;a && this.zones.length && (b = a.getZone(), b = a.options.color || b && b.color || this.color);d && (a = e(c.states[d], a.options.states && a.options.states[d] || {}), d = a.brightness, b = a.color || void 0 !== d && F(b).brighten(a.brightness).get() || b, n = a[g] || n, l = a[f] || l, p = a.dashStyle || p);g = { fill: b, stroke: n, \"stroke-width\": l };p && (g.dashstyle = p);return g;\n      }, drawPoints: function () {\n        var a = this,\n            d = this.chart,\n            k = a.options,\n            l = d.renderer,\n            p = k.animationLimit || 250,\n            f;D(a.points, function (b) {\n          var c = b.graphic,\n              t = c && d.pointCount < p ? \"animate\" : \"attr\";if (g(b.plotY) && null !== b.y) {\n            f = b.shapeArgs;if (c) c[t](e(f));else b.graphic = c = l[b.shapeType](f).add(b.group || a.group);k.borderRadius && c.attr({ r: k.borderRadius });c[t](a.pointAttribs(b, b.selected && \"select\")).shadow(k.shadow, null, k.stacking && !k.borderRadius);c.addClass(b.getClassName(), !0);\n          } else c && (b.graphic = c.destroy());\n        });\n      }, animate: function (a) {\n        var c = this,\n            e = this.yAxis,\n            g = c.options,\n            p = this.chart.inverted,\n            f = {},\n            b = p ? \"translateX\" : \"translateY\",\n            n;u && (a ? (f.scaleY = .001, a = Math.min(e.pos + e.len, Math.max(e.pos, e.toPixels(g.threshold))), p ? f.translateX = a - e.len : f.translateY = a, c.group.attr(f)) : (n = c.group.attr(b), c.group.animate({ scaleY: 1 }, r(C(c.options.animation), { step: function (a, d) {\n            f[b] = n + d.pos * (e.pos - n);c.group.attr(f);\n          } })), c.animate = null));\n      }, remove: function () {\n        var a = this,\n            d = a.chart;d.hasRendered && D(d.series, function (c) {\n          c.type === a.type && (c.isDirty = !0);\n        });w.prototype.remove.apply(a, arguments);\n      } });\n  })(K);(function (a) {\n    a = a.seriesType;a(\"bar\", \"column\", null, { inverted: !0 });\n  })(K);(function (a) {\n    var C = a.Series;a = a.seriesType;a(\"scatter\", \"line\", { lineWidth: 0, findNearestPointBy: \"xy\", marker: { enabled: !0 }, tooltip: { headerFormat: '\\x3cspan style\\x3d\"color:{point.color}\"\\x3e\\u25cf\\x3c/span\\x3e \\x3cspan style\\x3d\"font-size: 0.85em\"\\x3e {series.name}\\x3c/span\\x3e\\x3cbr/\\x3e',\n        pointFormat: \"x: \\x3cb\\x3e{point.x}\\x3c/b\\x3e\\x3cbr/\\x3ey: \\x3cb\\x3e{point.y}\\x3c/b\\x3e\\x3cbr/\\x3e\" } }, { sorted: !1, requireSorting: !1, noSharedTooltip: !0, trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"], takeOrdinalPosition: !1, drawGraph: function () {\n        this.options.lineWidth && C.prototype.drawGraph.call(this);\n      } });\n  })(K);(function (a) {\n    var C = a.deg2rad,\n        F = a.isNumber,\n        D = a.pick,\n        r = a.relativeLength;a.CenteredSeriesMixin = { getCenter: function () {\n        var a = this.options,\n            e = this.chart,\n            t = 2 * (a.slicedOffset || 0),\n            w = e.plotWidth - 2 * t,\n            e = e.plotHeight - 2 * t,\n            l = a.center,\n            l = [D(l[0], \"50%\"), D(l[1], \"50%\"), a.size || \"100%\", a.innerSize || 0],\n            u = Math.min(w, e),\n            c,\n            d;for (c = 0; 4 > c; ++c) d = l[c], a = 2 > c || 2 === c && /%$/.test(d), l[c] = r(d, [w, e, u, l[2]][c]) + (a ? t : 0);l[3] > l[2] && (l[3] = l[2]);return l;\n      }, getStartAndEndRadians: function (a, e) {\n        a = F(a) ? a : 0;e = F(e) && e > a && 360 > e - a ? e : a + 360;return { start: C * (a + -90), end: C * (e + -90) };\n      } };\n  })(K);(function (a) {\n    var C = a.addEvent,\n        F = a.CenteredSeriesMixin,\n        D = a.defined,\n        r = a.each,\n        g = a.extend,\n        e = F.getStartAndEndRadians,\n        t = a.inArray,\n        w = a.noop,\n        l = a.pick,\n        u = a.Point,\n        c = a.Series,\n        d = a.seriesType,\n        k = a.setAnimation;d(\"pie\", \"line\", { center: [null, null], clip: !1, colorByPoint: !0, dataLabels: { distance: 30, enabled: !0, formatter: function () {\n          return this.point.isNull ? void 0 : this.point.name;\n        }, x: 0 }, ignoreHiddenPoint: !0, legendType: \"point\", marker: null, size: null, showInLegend: !1, slicedOffset: 10, stickyTracking: !1, tooltip: { followPointer: !0 }, borderColor: \"#ffffff\", borderWidth: 1, states: { hover: { brightness: .1 } } }, { isCartesian: !1, requireSorting: !1, directTouch: !0, noSharedTooltip: !0, trackerGroups: [\"group\", \"dataLabelsGroup\"], axisTypes: [], pointAttribs: a.seriesTypes.column.prototype.pointAttribs, animate: function (a) {\n        var c = this,\n            d = c.points,\n            b = c.startAngleRad;a || (r(d, function (a) {\n          var d = a.graphic,\n              f = a.shapeArgs;d && (d.attr({ r: a.startR || c.center[3] / 2, start: b, end: b }), d.animate({ r: f.r, start: f.start, end: f.end }, c.options.animation));\n        }), c.animate = null);\n      }, updateTotals: function () {\n        var a,\n            c = 0,\n            d = this.points,\n            b = d.length,\n            e,\n            g = this.options.ignoreHiddenPoint;for (a = 0; a < b; a++) e = d[a], c += g && !e.visible ? 0 : e.isNull ? 0 : e.y;this.total = c;for (a = 0; a < b; a++) e = d[a], e.percentage = 0 < c && (e.visible || !g) ? e.y / c * 100 : 0, e.total = c;\n      }, generatePoints: function () {\n        c.prototype.generatePoints.call(this);this.updateTotals();\n      }, translate: function (a) {\n        this.generatePoints();var c = 0,\n            d = this.options,\n            b = d.slicedOffset,\n            g = b + (d.borderWidth || 0),\n            k,\n            t,\n            q,\n            r = e(d.startAngle, d.endAngle),\n            u = this.startAngleRad = r.start,\n            r = (this.endAngleRad = r.end) - u,\n            w = this.points,\n            m,\n            x = d.dataLabels.distance,\n            d = d.ignoreHiddenPoint,\n            A,\n            C = w.length,\n            G;a || (this.center = a = this.getCenter());this.getX = function (b, c, d) {\n          q = Math.asin(Math.min((b - a[1]) / (a[2] / 2 + d.labelDistance), 1));return a[0] + (c ? -1 : 1) * Math.cos(q) * (a[2] / 2 + d.labelDistance);\n        };for (A = 0; A < C; A++) {\n          G = w[A];G.labelDistance = l(G.options.dataLabels && G.options.dataLabels.distance, x);this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, G.labelDistance);k = u + c * r;if (!d || G.visible) c += G.percentage / 100;t = u + c * r;G.shapeType = \"arc\";G.shapeArgs = { x: a[0], y: a[1], r: a[2] / 2, innerR: a[3] / 2, start: Math.round(1E3 * k) / 1E3, end: Math.round(1E3 * t) / 1E3 };q = (t + k) / 2;q > 1.5 * Math.PI ? q -= 2 * Math.PI : q < -Math.PI / 2 && (q += 2 * Math.PI);\n          G.slicedTranslation = { translateX: Math.round(Math.cos(q) * b), translateY: Math.round(Math.sin(q) * b) };t = Math.cos(q) * a[2] / 2;m = Math.sin(q) * a[2] / 2;G.tooltipPos = [a[0] + .7 * t, a[1] + .7 * m];G.half = q < -Math.PI / 2 || q > Math.PI / 2 ? 1 : 0;G.angle = q;k = Math.min(g, G.labelDistance / 5);G.labelPos = [a[0] + t + Math.cos(q) * G.labelDistance, a[1] + m + Math.sin(q) * G.labelDistance, a[0] + t + Math.cos(q) * k, a[1] + m + Math.sin(q) * k, a[0] + t, a[1] + m, 0 > G.labelDistance ? \"center\" : G.half ? \"right\" : \"left\", q];\n        }\n      }, drawGraph: null, drawPoints: function () {\n        var a = this,\n            c = a.chart.renderer,\n            d,\n            b,\n            e,\n            k,\n            l = a.options.shadow;l && !a.shadowGroup && (a.shadowGroup = c.g(\"shadow\").add(a.group));r(a.points, function (f) {\n          b = f.graphic;if (f.isNull) b && (f.graphic = b.destroy());else {\n            k = f.shapeArgs;d = f.getTranslate();var q = f.shadowGroup;l && !q && (q = f.shadowGroup = c.g(\"shadow\").add(a.shadowGroup));q && q.attr(d);e = a.pointAttribs(f, f.selected && \"select\");b ? b.setRadialReference(a.center).attr(e).animate(g(k, d)) : (f.graphic = b = c[f.shapeType](k).setRadialReference(a.center).attr(d).add(a.group), f.visible || b.attr({ visibility: \"hidden\" }), b.attr(e).attr({ \"stroke-linejoin\": \"round\" }).shadow(l, q));b.addClass(f.getClassName());\n          }\n        });\n      }, searchPoint: w, sortByAngle: function (a, c) {\n        a.sort(function (a, b) {\n          return void 0 !== a.angle && (b.angle - a.angle) * c;\n        });\n      }, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle, getCenter: F.getCenter, getSymbol: w }, { init: function () {\n        u.prototype.init.apply(this, arguments);var a = this,\n            c;a.name = l(a.name, \"Slice\");c = function (c) {\n          a.slice(\"select\" === c.type);\n        };C(a, \"select\", c);C(a, \"unselect\", c);return a;\n      }, isValid: function () {\n        return a.isNumber(this.y, !0) && 0 <= this.y;\n      }, setVisible: function (a, c) {\n        var d = this,\n            b = d.series,\n            e = b.chart,\n            g = b.options.ignoreHiddenPoint;c = l(c, g);a !== d.visible && (d.visible = d.options.visible = a = void 0 === a ? !d.visible : a, b.options.data[t(d, b.data)] = d.options, r([\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"], function (b) {\n          if (d[b]) d[b][a ? \"show\" : \"hide\"](!0);\n        }), d.legendItem && e.legend.colorizeItem(d, a), a || \"hover\" !== d.state || d.setState(\"\"), g && (b.isDirty = !0), c && e.redraw());\n      }, slice: function (a, c, d) {\n        var b = this.series;k(d, b.chart);l(c, !0);this.sliced = this.options.sliced = D(a) ? a : !this.sliced;b.options.data[t(this, b.data)] = this.options;this.graphic.animate(this.getTranslate());this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      }, getTranslate: function () {\n        return this.sliced ? this.slicedTranslation : { translateX: 0, translateY: 0 };\n      }, haloPath: function (a) {\n        var c = this.shapeArgs;return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a, c.r + a, { innerR: this.shapeArgs.r - 1, start: c.start, end: c.end });\n      } });\n  })(K);(function (a) {\n    var C = a.addEvent,\n        F = a.arrayMax,\n        D = a.defined,\n        r = a.each,\n        g = a.extend,\n        e = a.format,\n        t = a.map,\n        w = a.merge,\n        l = a.noop,\n        u = a.pick,\n        c = a.relativeLength,\n        d = a.Series,\n        k = a.seriesTypes,\n        x = a.some,\n        p = a.stableSort;a.distribute = function (c, b, d) {\n      function e(a, b) {\n        return a.target - b.target;\n      }var f,\n          g = !0,\n          k = c,\n          l = [],\n          n;n = 0;var m = k.reducedLen || b;for (f = c.length; f--;) n += c[f].size;if (n > m) {\n        p(c, function (a, b) {\n          return (b.rank || 0) - (a.rank || 0);\n        });for (n = f = 0; n <= m;) n += c[f].size, f++;l = c.splice(f - 1, c.length);\n      }p(c, e);for (c = t(c, function (a) {\n        return { size: a.size, targets: [a.target],\n          align: u(a.align, .5) };\n      }); g;) {\n        for (f = c.length; f--;) g = c[f], n = (Math.min.apply(0, g.targets) + Math.max.apply(0, g.targets)) / 2, g.pos = Math.min(Math.max(0, n - g.size * g.align), b - g.size);f = c.length;for (g = !1; f--;) 0 < f && c[f - 1].pos + c[f - 1].size > c[f].pos && (c[f - 1].size += c[f].size, c[f - 1].targets = c[f - 1].targets.concat(c[f].targets), c[f - 1].align = .5, c[f - 1].pos + c[f - 1].size > b && (c[f - 1].pos = b - c[f - 1].size), c.splice(f, 1), g = !0);\n      }k.push.apply(k, l);f = 0;x(c, function (c) {\n        var e = 0;if (x(c.targets, function () {\n          k[f].pos = c.pos + e;if (Math.abs(k[f].pos - k[f].target) > d) return r(k.slice(0, f + 1), function (a) {\n            delete a.pos;\n          }), k.reducedLen = (k.reducedLen || b) - .1 * b, k.reducedLen > .1 * b && a.distribute(k, b, d), !0;e += k[f].size;f++;\n        })) return !0;\n      });p(k, e);\n    };d.prototype.drawDataLabels = function () {\n      function c(a, b) {\n        var c = b.filter;return c ? (b = c.operator, a = a[c.property], c = c.value, \"\\x3e\" === b && a > c || \"\\x3c\" === b && a < c || \"\\x3e\\x3d\" === b && a >= c || \"\\x3c\\x3d\" === b && a <= c || \"\\x3d\\x3d\" === b && a == c || \"\\x3d\\x3d\\x3d\" === b && a === c ? !0 : !1) : !0;\n      }var b = this,\n          d = b.chart,\n          g = b.options,\n          k = g.dataLabels,\n          q = b.points,\n          l,\n          p,\n          t = b.hasRendered || 0,\n          m,\n          x,\n          A = u(k.defer, !!g.animation),\n          F = d.renderer;if (k.enabled || b._hasPointLabels) b.dlProcessOptions && b.dlProcessOptions(k), x = b.plotGroup(\"dataLabelsGroup\", \"data-labels\", A && !t ? \"hidden\" : \"visible\", k.zIndex || 6), A && (x.attr({ opacity: +t }), t || C(b, \"afterAnimate\", function () {\n        b.visible && x.show(!0);x[g.animation ? \"animate\" : \"attr\"]({ opacity: 1 }, { duration: 200 });\n      })), p = k, r(q, function (f) {\n        var h,\n            q = f.dataLabel,\n            n,\n            t,\n            r = f.connector,\n            B = !q,\n            z;l = f.dlOptions || f.options && f.options.dataLabels;(h = u(l && l.enabled, p.enabled) && !f.isNull) && (h = !0 === c(f, l || k));h && (k = w(p, l), n = f.getLabelConfig(), z = k[f.formatPrefix + \"Format\"] || k.format, m = D(z) ? e(z, n, d.time) : (k[f.formatPrefix + \"Formatter\"] || k.formatter).call(n, k), z = k.style, n = k.rotation, z.color = u(k.color, z.color, b.color, \"#000000\"), \"contrast\" === z.color && (f.contrastColor = F.getContrast(f.color || b.color), z.color = k.inside || 0 > u(f.labelDistance, k.distance) || g.stacking ? f.contrastColor : \"#000000\"), g.cursor && (z.cursor = g.cursor), t = { fill: k.backgroundColor, stroke: k.borderColor, \"stroke-width\": k.borderWidth,\n          r: k.borderRadius || 0, rotation: n, padding: k.padding, zIndex: 1 }, a.objectEach(t, function (a, b) {\n          void 0 === a && delete t[b];\n        }));!q || h && D(m) ? h && D(m) && (q ? t.text = m : (q = f.dataLabel = n ? F.text(m, 0, -9999).addClass(\"highcharts-data-label\") : F.label(m, 0, -9999, k.shape, null, null, k.useHTML, null, \"data-label\"), q.addClass(\" highcharts-data-label-color-\" + f.colorIndex + \" \" + (k.className || \"\") + (k.useHTML ? \"highcharts-tracker\" : \"\"))), q.attr(t), q.css(z).shadow(k.shadow), q.added || q.add(x), b.alignDataLabel(f, q, k, null, B)) : (f.dataLabel = q = q.destroy(), r && (f.connector = r.destroy()));\n      });a.fireEvent(this, \"afterDrawDataLabels\");\n    };d.prototype.alignDataLabel = function (a, b, c, d, e) {\n      var f = this.chart,\n          k = f.inverted,\n          l = u(a.dlBox && a.dlBox.centerX, a.plotX, -9999),\n          n = u(a.plotY, -9999),\n          m = b.getBBox(),\n          p,\n          t = c.rotation,\n          r = c.align,\n          w = this.visible && (a.series.forceDL || f.isInsidePlot(l, Math.round(n), k) || d && f.isInsidePlot(l, k ? d.x + 1 : d.y + d.height - 1, k)),\n          h = \"justify\" === u(c.overflow, \"justify\");if (w && (p = c.style.fontSize, p = f.renderer.fontMetrics(p, b).b, d = g({ x: k ? this.yAxis.len - n : l, y: Math.round(k ? this.xAxis.len - l : n), width: 0, height: 0 }, d), g(c, { width: m.width, height: m.height }), t ? (h = !1, l = f.renderer.rotCorr(p, t), l = { x: d.x + c.x + d.width / 2 + l.x, y: d.y + c.y + { top: 0, middle: .5, bottom: 1 }[c.verticalAlign] * d.height }, b[e ? \"attr\" : \"animate\"](l).attr({ align: r }), n = (t + 720) % 360, n = 180 < n && 360 > n, \"left\" === r ? l.y -= n ? m.height : 0 : \"center\" === r ? (l.x -= m.width / 2, l.y -= m.height / 2) : \"right\" === r && (l.x -= m.width, l.y -= n ? 0 : m.height), b.placed = !0, b.alignAttr = l) : (b.align(c, null, d), l = b.alignAttr), h ? a.isLabelJustified = this.justifyDataLabel(b, c, l, m, d, e) : u(c.crop, !0) && (w = f.isInsidePlot(l.x, l.y) && f.isInsidePlot(l.x + m.width, l.y + m.height)), c.shape && !t)) b[e ? \"attr\" : \"animate\"]({ anchorX: k ? f.plotWidth - a.plotY : a.plotX, anchorY: k ? f.plotHeight - a.plotX : a.plotY });w || (b.attr({ y: -9999 }), b.placed = !1);\n    };d.prototype.justifyDataLabel = function (a, b, c, d, e, g) {\n      var f = this.chart,\n          q = b.align,\n          k = b.verticalAlign,\n          m,\n          l,\n          n = a.box ? 0 : a.padding || 0;m = c.x + n;0 > m && (\"right\" === q ? b.align = \"left\" : b.x = -m, l = !0);m = c.x + d.width - n;m > f.plotWidth && (\"left\" === q ? b.align = \"right\" : b.x = f.plotWidth - m, l = !0);\n      m = c.y + n;0 > m && (\"bottom\" === k ? b.verticalAlign = \"top\" : b.y = -m, l = !0);m = c.y + d.height - n;m > f.plotHeight && (\"top\" === k ? b.verticalAlign = \"bottom\" : b.y = f.plotHeight - m, l = !0);l && (a.placed = !g, a.align(b, null, e));return l;\n    };k.pie && (k.pie.prototype.drawDataLabels = function () {\n      var c = this,\n          b = c.data,\n          e,\n          g = c.chart,\n          k = c.options.dataLabels,\n          q = u(k.connectorPadding, 10),\n          l = u(k.connectorWidth, 1),\n          p = g.plotWidth,\n          t = g.plotHeight,\n          m = Math.round(g.chartWidth / 3),\n          w,\n          x = c.center,\n          C = x[2] / 2,\n          G = x[1],\n          h,\n          v,\n          K,\n          P,\n          I = [[], []],\n          O,\n          N,\n          y,\n          R,\n          S = [0, 0, 0, 0];c.visible && (k.enabled || c._hasPointLabels) && (r(b, function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({ width: \"auto\" }).css({ width: \"auto\", textOverflow: \"clip\" }), a.dataLabel.shortened = !1);\n      }), d.prototype.drawDataLabels.apply(c), r(b, function (a) {\n        a.dataLabel && a.visible && (I[a.half].push(a), a.dataLabel._pos = null, !D(k.style.width) && !D(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > m && (a.dataLabel.css({ width: .7 * m }), a.dataLabel.shortened = !0));\n      }), r(I, function (b, d) {\n        var f,\n            m,\n            l = b.length,\n            n = [],\n            w;if (l) for (c.sortByAngle(b, d - .5), 0 < c.maxLabelDistance && (f = Math.max(0, G - C - c.maxLabelDistance), m = Math.min(G + C + c.maxLabelDistance, g.plotHeight), r(b, function (a) {\n          0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, G - C - a.labelDistance), a.bottom = Math.min(G + C + a.labelDistance, g.plotHeight), w = a.dataLabel.getBBox().height || 21, a.positionsIndex = n.push({ target: a.labelPos[1] - a.top + w / 2, size: w, rank: a.y }) - 1);\n        }), f = m + w - f, a.distribute(n, f, f / 5)), R = 0; R < l; R++) e = b[R], m = e.positionsIndex, K = e.labelPos, h = e.dataLabel, y = !1 === e.visible ? \"hidden\" : \"inherit\", N = f = K[1], n && D(n[m]) && (void 0 === n[m].pos ? y = \"hidden\" : (P = n[m].size, N = e.top + n[m].pos)), delete e.positionIndex, O = k.justify ? x[0] + (d ? -1 : 1) * (C + e.labelDistance) : c.getX(N < e.top + 2 || N > e.bottom - 2 ? f : N, d, e), h._attr = { visibility: y, align: K[6] }, h._pos = { x: O + k.x + ({ left: q, right: -q }[K[6]] || 0), y: N + k.y - 10 }, K.x = O, K.y = N, u(k.crop, !0) && (v = h.getBBox().width, f = null, O - v < q && 1 === d ? (f = Math.round(v - O + q), S[3] = Math.max(f, S[3])) : O + v > p - q && 0 === d && (f = Math.round(O + v - p + q), S[1] = Math.max(f, S[1])), 0 > N - P / 2 ? S[0] = Math.max(Math.round(-N + P / 2), S[0]) : N + P / 2 > t && (S[2] = Math.max(Math.round(N + P / 2 - t), S[2])), h.sideOverflow = f);\n      }), 0 === F(S) || this.verifyDataLabelOverflow(S)) && (this.placeDataLabels(), l && r(this.points, function (a) {\n        var b;w = a.connector;if ((h = a.dataLabel) && h._pos && a.visible && 0 < a.labelDistance) {\n          y = h._attr.visibility;if (b = !w) a.connector = w = g.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + a.colorIndex + (a.className ? \" \" + a.className : \"\")).add(c.dataLabelsGroup), w.attr({ \"stroke-width\": l, stroke: k.connectorColor || a.color || \"#666666\" });w[b ? \"attr\" : \"animate\"]({ d: c.connectorPath(a.labelPos) });w.attr(\"visibility\", y);\n        } else w && (a.connector = w.destroy());\n      }));\n    }, k.pie.prototype.connectorPath = function (a) {\n      var b = a.x,\n          c = a.y;return u(this.options.dataLabels.softConnector, !0) ? [\"M\", b + (\"left\" === a[6] ? 5 : -5), c, \"C\", b, c, 2 * a[2] - a[4], 2 * a[3] - a[5], a[2], a[3], \"L\", a[4], a[5]] : [\"M\", b + (\"left\" === a[6] ? 5 : -5), c, \"L\", a[2], a[3], \"L\", a[4], a[5]];\n    }, k.pie.prototype.placeDataLabels = function () {\n      r(this.points, function (a) {\n        var b = a.dataLabel;b && a.visible && ((a = b._pos) ? (b.sideOverflow && (b._attr.width = b.getBBox().width - b.sideOverflow, b.css({ width: b._attr.width + \"px\", textOverflow: this.options.dataLabels.style.textOverflow || \"ellipsis\" }), b.shortened = !0), b.attr(b._attr), b[b.moved ? \"animate\" : \"attr\"](a), b.moved = !0) : b && b.attr({ y: -9999 }));\n      }, this);\n    }, k.pie.prototype.alignDataLabel = l, k.pie.prototype.verifyDataLabelOverflow = function (a) {\n      var b = this.center,\n          d = this.options,\n          e = d.center,\n          f = d.minSize || 80,\n          g,\n          k = null !== d.size;k || (null !== e[0] ? g = Math.max(b[2] - Math.max(a[1], a[3]), f) : (g = Math.max(b[2] - a[1] - a[3], f), b[0] += (a[3] - a[1]) / 2), null !== e[1] ? g = Math.max(Math.min(g, b[2] - Math.max(a[0], a[2])), f) : (g = Math.max(Math.min(g, b[2] - a[0] - a[2]), f), b[1] += (a[0] - a[2]) / 2), g < b[2] ? (b[2] = g, b[3] = Math.min(c(d.innerSize || 0, g), g), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : k = !0);return k;\n    });k.column && (k.column.prototype.alignDataLabel = function (a, b, c, e, g) {\n      var f = this.chart.inverted,\n          k = a.series,\n          l = a.dlBox || a.shapeArgs,\n          p = u(a.below, a.plotY > u(this.translatedThreshold, k.yAxis.len)),\n          m = u(c.inside, !!this.options.stacking);l && (e = w(l), 0 > e.y && (e.height += e.y, e.y = 0), l = e.y + e.height - k.yAxis.len, 0 < l && (e.height -= l), f && (e = { x: k.yAxis.len - e.y - e.height, y: k.xAxis.len - e.x - e.width, width: e.height, height: e.width }), m || (f ? (e.x += p ? 0 : e.width, e.width = 0) : (e.y += p ? e.height : 0, e.height = 0)));c.align = u(c.align, !f || m ? \"center\" : p ? \"right\" : \"left\");c.verticalAlign = u(c.verticalAlign, f || m ? \"middle\" : p ? \"top\" : \"bottom\");d.prototype.alignDataLabel.call(this, a, b, c, e, g);a.isLabelJustified && a.contrastColor && a.dataLabel.css({ color: a.contrastColor });\n    });\n  })(K);\n  (function (a) {\n    var C = a.Chart,\n        F = a.each,\n        D = a.objectEach,\n        r = a.pick;a = a.addEvent;a(C, \"render\", function () {\n      var a = [];F(this.labelCollectors || [], function (e) {\n        a = a.concat(e());\n      });F(this.yAxis || [], function (e) {\n        e.options.stackLabels && !e.options.stackLabels.allowOverlap && D(e.stacks, function (e) {\n          D(e, function (e) {\n            a.push(e.label);\n          });\n        });\n      });F(this.series || [], function (e) {\n        var g = e.options.dataLabels,\n            w = e.dataLabelCollections || [\"dataLabel\"];(g.enabled || e._hasPointLabels) && !g.allowOverlap && e.visible && F(w, function (g) {\n          F(e.points, function (e) {\n            e[g] && (e[g].labelrank = r(e.labelrank, e.shapeArgs && e.shapeArgs.height), a.push(e[g]));\n          });\n        });\n      });this.hideOverlappingLabels(a);\n    });C.prototype.hideOverlappingLabels = function (a) {\n      var e = a.length,\n          g,\n          r,\n          l,\n          u,\n          c,\n          d,\n          k,\n          x,\n          p,\n          f = function (a, c, d, e, f, g, k, l) {\n        return !(f > a + d || f + k < a || g > c + e || g + l < c);\n      };for (r = 0; r < e; r++) if (g = a[r]) g.oldOpacity = g.opacity, g.newOpacity = 1, g.width || (l = g.getBBox(), g.width = l.width, g.height = l.height);a.sort(function (a, c) {\n        return (c.labelrank || 0) - (a.labelrank || 0);\n      });for (r = 0; r < e; r++) for (l = a[r], g = r + 1; g < e; ++g) if (u = a[g], l && u && l !== u && l.placed && u.placed && 0 !== l.newOpacity && 0 !== u.newOpacity && (c = l.alignAttr, d = u.alignAttr, k = l.parentGroup, x = u.parentGroup, p = 2 * (l.box ? 0 : l.padding || 0), c = f(c.x + k.translateX, c.y + k.translateY, l.width - p, l.height - p, d.x + x.translateX, d.y + x.translateY, u.width - p, u.height - p))) (l.labelrank < u.labelrank ? l : u).newOpacity = 0;F(a, function (a) {\n        var b, c;a && (c = a.newOpacity, a.oldOpacity !== c && a.placed && (c ? a.show(!0) : b = function () {\n          a.hide();\n        }, a.alignAttr.opacity = c, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, b)), a.isOld = !0);\n      });\n    };\n  })(K);\n  (function (a) {\n    var C = a.addEvent,\n        F = a.Chart,\n        D = a.createElement,\n        r = a.css,\n        g = a.defaultOptions,\n        e = a.defaultPlotOptions,\n        t = a.each,\n        w = a.extend,\n        l = a.fireEvent,\n        u = a.hasTouch,\n        c = a.inArray,\n        d = a.isObject,\n        k = a.Legend,\n        x = a.merge,\n        p = a.pick,\n        f = a.Point,\n        b = a.Series,\n        n = a.seriesTypes,\n        z = a.svg,\n        J;J = a.TrackerMixin = { drawTrackerPoint: function () {\n        var a = this,\n            b = a.chart.pointer,\n            c = function (a) {\n          var c = b.getPointFromEvent(a);void 0 !== c && (b.isDirectTouch = !0, c.onMouseOver(a));\n        };t(a.points, function (a) {\n          a.graphic && (a.graphic.element.point = a);a.dataLabel && (a.dataLabel.div ? a.dataLabel.div.point = a : a.dataLabel.element.point = a);\n        });a._hasTracking || (t(a.trackerGroups, function (d) {\n          if (a[d]) {\n            a[d].addClass(\"highcharts-tracker\").on(\"mouseover\", c).on(\"mouseout\", function (a) {\n              b.onTrackerMouseOut(a);\n            });if (u) a[d].on(\"touchstart\", c);a.options.cursor && a[d].css(r).css({ cursor: a.options.cursor });\n          }\n        }), a._hasTracking = !0);l(this, \"afterDrawTracker\");\n      }, drawTrackerGraph: function () {\n        var a = this,\n            b = a.options,\n            c = b.trackByArea,\n            d = [].concat(c ? a.areaPath : a.graphPath),\n            e = d.length,\n            f = a.chart,\n            g = f.pointer,\n            k = f.renderer,\n            p = f.options.tooltip.snap,\n            h = a.tracker,\n            n,\n            r = function () {\n          if (f.hoverSeries !== a) a.onMouseOver();\n        },\n            w = \"rgba(192,192,192,\" + (z ? .0001 : .002) + \")\";if (e && !c) for (n = e + 1; n--;) \"M\" === d[n] && d.splice(n + 1, 0, d[n + 1] - p, d[n + 2], \"L\"), (n && \"M\" === d[n] || n === e) && d.splice(n, 0, \"L\", d[n - 2] + p, d[n - 1]);h ? h.attr({ d: d }) : a.graph && (a.tracker = k.path(d).attr({ \"stroke-linejoin\": \"round\", visibility: a.visible ? \"visible\" : \"hidden\", stroke: w, fill: c ? w : \"none\", \"stroke-width\": a.graph.strokeWidth() + (c ? 0 : 2 * p), zIndex: 2 }).add(a.group), t([a.tracker, a.markerGroup], function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", r).on(\"mouseout\", function (a) {\n            g.onTrackerMouseOut(a);\n          });b.cursor && a.css({ cursor: b.cursor });if (u) a.on(\"touchstart\", r);\n        }));l(this, \"afterDrawTracker\");\n      } };n.column && (n.column.prototype.drawTracker = J.drawTrackerPoint);n.pie && (n.pie.prototype.drawTracker = J.drawTrackerPoint);n.scatter && (n.scatter.prototype.drawTracker = J.drawTrackerPoint);w(k.prototype, { setItemEvents: function (a, b, c) {\n        var d = this,\n            e = d.chart.renderer.boxWrapper,\n            g = \"highcharts-legend-\" + (a instanceof f ? \"point\" : \"series\") + \"-active\";(c ? b : a.legendGroup).on(\"mouseover\", function () {\n          a.setState(\"hover\");e.addClass(g);b.css(d.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          b.css(x(a.visible ? d.itemStyle : d.itemHiddenStyle));e.removeClass(g);a.setState();\n        }).on(\"click\", function (b) {\n          var c = function () {\n            a.setVisible && a.setVisible();\n          };e.removeClass(g);b = { browserEvent: b };a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, c) : l(a, \"legendItemClick\", b, c);\n        });\n      }, createCheckboxForItem: function (a) {\n        a.checkbox = D(\"input\", { type: \"checkbox\", checked: a.selected, defaultChecked: a.selected }, this.options.itemCheckboxStyle, this.chart.container);C(a.checkbox, \"click\", function (b) {\n          l(a.series || a, \"checkboxClick\", { checked: b.target.checked, item: a }, function () {\n            a.select();\n          });\n        });\n      } });g.legend.itemStyle.cursor = \"pointer\";w(F.prototype, { showResetZoom: function () {\n        function a() {\n          b.zoomOut();\n        }var b = this,\n            c = g.lang,\n            d = b.options.chart.resetZoomButton,\n            e = d.theme,\n            f = e.states,\n            k = \"chart\" === d.relativeTo ? null : \"plotBox\";l(this, \"beforeShowResetZoom\", null, function () {\n          b.resetZoomButton = b.renderer.button(c.resetZoom, null, null, a, e, f && f.hover).attr({ align: d.position.align, title: c.resetZoomTitle }).addClass(\"highcharts-reset-zoom\").add().align(d.position, !1, k);\n        });\n      }, zoomOut: function () {\n        l(this, \"selection\", { resetSelection: !0 }, this.zoom);\n      }, zoom: function (a) {\n        var b,\n            c = this.pointer,\n            e = !1,\n            f;!a || a.resetSelection ? (t(this.axes, function (a) {\n          b = a.zoom();\n        }), c.initiated = !1) : t(a.xAxis.concat(a.yAxis), function (a) {\n          var d = a.axis;c[d.isXAxis ? \"zoomX\" : \"zoomY\"] && (b = d.zoom(a.min, a.max), d.displayBtn && (e = !0));\n        });f = this.resetZoomButton;e && !f ? this.showResetZoom() : !e && d(f) && (this.resetZoomButton = f.destroy());b && this.redraw(p(this.options.chart.animation, a && a.animation, 100 > this.pointCount));\n      }, pan: function (a, b) {\n        var c = this,\n            d = c.hoverPoints,\n            e;d && t(d, function (a) {\n          a.setState();\n        });t(\"xy\" === b ? [1, 0] : [1], function (b) {\n          b = c[b ? \"xAxis\" : \"yAxis\"][0];var d = b.horiz,\n              f = a[d ? \"chartX\" : \"chartY\"],\n              d = d ? \"mouseDownX\" : \"mouseDownY\",\n              g = c[d],\n              h = (b.pointRange || 0) / 2,\n              k = b.reversed && !c.inverted || !b.reversed && c.inverted ? -1 : 1,\n              l = b.getExtremes(),\n              m = b.toValue(g - f, !0) + h * k,\n              k = b.toValue(g + b.len - f, !0) - h * k,\n              q = k < m,\n              g = q ? k : m,\n              m = q ? m : k,\n              k = Math.min(l.dataMin, h ? l.min : b.toValue(b.toPixels(l.min) - b.minPixelPadding)),\n              h = Math.max(l.dataMax, h ? l.max : b.toValue(b.toPixels(l.max) + b.minPixelPadding)),\n              q = k - g;0 < q && (m += q, g = k);q = m - h;0 < q && (m = h, g -= q);b.series.length && g !== l.min && m !== l.max && (b.setExtremes(g, m, !1, !1, { trigger: \"pan\" }), e = !0);c[d] = f;\n        });e && c.redraw(!1);r(c.container, { cursor: \"move\" });\n      } });w(f.prototype, { select: function (a, b) {\n        var d = this,\n            e = d.series,\n            f = e.chart;a = p(a, !d.selected);\n        d.firePointEvent(a ? \"select\" : \"unselect\", { accumulate: b }, function () {\n          d.selected = d.options.selected = a;e.options.data[c(d, e.data)] = d.options;d.setState(a && \"select\");b || t(f.getSelectedPoints(), function (a) {\n            a.selected && a !== d && (a.selected = a.options.selected = !1, e.options.data[c(a, e.data)] = a.options, a.setState(\"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n      }, onMouseOver: function (a) {\n        var b = this.series.chart,\n            c = b.pointer;a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted);c.runPointActions(a, this);\n      }, onMouseOut: function () {\n        var a = this.series.chart;this.firePointEvent(\"mouseOut\");t(a.hoverPoints || [], function (a) {\n          a.setState();\n        });a.hoverPoints = a.hoverPoint = null;\n      }, importEvents: function () {\n        if (!this.hasImportedEvents) {\n          var b = this,\n              c = x(b.series.options.point, b.options).events;b.events = c;a.objectEach(c, function (a, c) {\n            C(b, c, a);\n          });this.hasImportedEvents = !0;\n        }\n      }, setState: function (a, b) {\n        var c = Math.floor(this.plotX),\n            d = this.plotY,\n            f = this.series,\n            g = f.options.states[a || \"normal\"] || {},\n            k = e[f.type].marker && f.options.marker,\n            q = k && !1 === k.enabled,\n            n = k && k.states && k.states[a || \"normal\"] || {},\n            h = !1 === n.enabled,\n            r = f.stateMarkerGraphic,\n            t = this.marker || {},\n            u = f.chart,\n            x = f.halo,\n            z,\n            C = k && f.markerAttribs;a = a || \"\";if (!(a === this.state && !b || this.selected && \"select\" !== a || !1 === g.enabled || a && (h || q && !1 === n.enabled) || a && t.states && t.states[a] && !1 === t.states[a].enabled)) {\n          C && (z = f.markerAttribs(this, a));if (this.graphic) this.state && this.graphic.removeClass(\"highcharts-point-\" + this.state), a && this.graphic.addClass(\"highcharts-point-\" + a), this.graphic.animate(f.pointAttribs(this, a), p(u.options.chart.animation, g.animation)), z && this.graphic.animate(z, p(u.options.chart.animation, n.animation, k.animation)), r && r.hide();else {\n            if (a && n) {\n              k = t.symbol || f.symbol;r && r.currentSymbol !== k && (r = r.destroy());if (r) r[b ? \"animate\" : \"attr\"]({ x: z.x, y: z.y });else k && (f.stateMarkerGraphic = r = u.renderer.symbol(k, z.x, z.y, z.width, z.height).add(f.markerGroup), r.currentSymbol = k);r && r.attr(f.pointAttribs(this, a));\n            }r && (r[a && u.isInsidePlot(c, d, u.inverted) ? \"show\" : \"hide\"](), r.element.point = this);\n          }(c = g.halo) && c.size ? (x || (f.halo = x = u.renderer.path().add((this.graphic || r).parentGroup)), x.show()[b ? \"animate\" : \"attr\"]({ d: this.haloPath(c.size) }), x.attr({ \"class\": \"highcharts-halo highcharts-color-\" + p(this.colorIndex, f.colorIndex) + (this.className ? \" \" + this.className : \"\") }), x.point = this, x.attr(w({ fill: this.color || f.color, \"fill-opacity\": c.opacity, zIndex: -1 }, c.attributes))) : x && x.point && x.point.haloPath && x.animate({ d: x.point.haloPath(0) }, null, x.hide);this.state = a;l(this, \"afterSetState\");\n        }\n      }, haloPath: function (a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      } });w(b.prototype, { onMouseOver: function () {\n        var a = this.chart,\n            b = a.hoverSeries;if (b && b !== this) b.onMouseOut();this.options.events.mouseOver && l(this, \"mouseOver\");this.setState(\"hover\");a.hoverSeries = this;\n      }, onMouseOut: function () {\n        var a = this.options,\n            b = this.chart,\n            c = b.tooltip,\n            d = b.hoverPoint;b.hoverSeries = null;if (d) d.onMouseOut();this && a.events.mouseOut && l(this, \"mouseOut\");!c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();this.setState();\n      }, setState: function (a) {\n        var b = this,\n            c = b.options,\n            d = b.graph,\n            e = c.states,\n            f = c.lineWidth,\n            c = 0;a = a || \"\";if (b.state !== a && (t([b.group, b.markerGroup, b.dataLabelsGroup], function (c) {\n          c && (b.state && c.removeClass(\"highcharts-series-\" + b.state), a && c.addClass(\"highcharts-series-\" + a));\n        }), b.state = a, !e[a] || !1 !== e[a].enabled) && (a && (f = e[a].lineWidth || f + (e[a].lineWidthPlus || 0)), d && !d.dashstyle)) for (f = { \"stroke-width\": f }, d.animate(f, p(e[a || \"normal\"] && e[a || \"normal\"].animation, b.chart.options.chart.animation)); b[\"zone-graph-\" + c];) b[\"zone-graph-\" + c].attr(f), c += 1;\n      },\n      setVisible: function (a, b) {\n        var c = this,\n            d = c.chart,\n            e = c.legendItem,\n            f,\n            g = d.options.chart.ignoreHiddenSeries,\n            k = c.visible;f = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !k : a) ? \"show\" : \"hide\";t([\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"], function (a) {\n          if (c[a]) c[a][f]();\n        });if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();e && d.legend.colorizeItem(c, a);c.isDirty = !0;c.options.stacking && t(d.series, function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });t(c.linkedSeries, function (b) {\n          b.setVisible(a, !1);\n        });g && (d.isDirtyBox = !0);!1 !== b && d.redraw();l(c, f);\n      }, show: function () {\n        this.setVisible(!0);\n      }, hide: function () {\n        this.setVisible(!1);\n      }, select: function (a) {\n        this.selected = a = void 0 === a ? !this.selected : a;this.checkbox && (this.checkbox.checked = a);l(this, a ? \"select\" : \"unselect\");\n      }, drawTracker: J.drawTrackerGraph });\n  })(K);(function (a) {\n    var C = a.Chart,\n        F = a.each,\n        D = a.inArray,\n        r = a.isArray,\n        g = a.isObject,\n        e = a.pick,\n        t = a.splat;C.prototype.setResponsive = function (e) {\n      var g = this.options.responsive,\n          r = [],\n          c = this.currentResponsive;\n      g && g.rules && F(g.rules, function (c) {\n        void 0 === c._id && (c._id = a.uniqueKey());this.matchResponsiveRule(c, r, e);\n      }, this);var d = a.merge.apply(0, a.map(r, function (c) {\n        return a.find(g.rules, function (a) {\n          return a._id === c;\n        }).chartOptions;\n      })),\n          r = r.toString() || void 0;r !== (c && c.ruleIds) && (c && this.update(c.undoOptions, e), r ? (this.currentResponsive = { ruleIds: r, mergedOptions: d, undoOptions: this.currentOptions(d) }, this.update(d, e)) : this.currentResponsive = void 0);\n    };C.prototype.matchResponsiveRule = function (a, g) {\n      var l = a.condition;\n      (l.callback || function () {\n        return this.chartWidth <= e(l.maxWidth, Number.MAX_VALUE) && this.chartHeight <= e(l.maxHeight, Number.MAX_VALUE) && this.chartWidth >= e(l.minWidth, 0) && this.chartHeight >= e(l.minHeight, 0);\n      }).call(this) && g.push(a._id);\n    };C.prototype.currentOptions = function (e) {\n      function l(c, d, e, u) {\n        var k;a.objectEach(c, function (a, b) {\n          if (!u && -1 < D(b, [\"series\", \"xAxis\", \"yAxis\"])) for (a = t(a), e[b] = [], k = 0; k < a.length; k++) d[b][k] && (e[b][k] = {}, l(a[k], d[b][k], e[b][k], u + 1));else g(a) ? (e[b] = r(a) ? [] : {}, l(a, d[b] || {}, e[b], u + 1)) : e[b] = d[b] || null;\n        });\n      }var u = {};l(e, this.options, u, 0);return u;\n    };\n  })(K);return K;\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/highcharts/highcharts.js\n// module id = ./node_modules/highcharts/highcharts.js\n// module chunks = 1\n\n//# sourceURL=webpack:///./node_modules/highcharts/highcharts.js?");

/***/ }),

/***/ 1:
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__;\n\n//////////////////\n// WEBPACK FOOTER\n// dll chartDll\n// module id = 1\n// module chunks = 1\n\n//# sourceURL=webpack:///dll_chartDll?");

/***/ })

/******/ });